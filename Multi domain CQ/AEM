AEM 

sling:resourceSuperType: It is used to achieve inheritance in cq. When set, it inherits the specified component to this component. 
sling:resourceType: It is a path, which locates the script to be used for rendering the content. Path used can be absolute or relative.

cq:defineObjects is used to initialize implicit objects of cq. Usually we add cq:defineObjects in global.jsp so that the implicit objects are available in all components that are including global.jsp. 

* Page property is disabled for newly created page in AEM ? What have you missed ? Dialog is missing for this page. 

parsys – It is a placeholder called “Paragraph System”, where we can drag and drop or add other components or scripts at page level. 
iparsys – It is inherited paragraph system, it is similar to parsys except that it allows to inherits parent page “paragraph system”.


Overlay/Override Component:
Overlay/Override Component:
Creating a custom component by copying a foundation component to your project and modifying it based on the need.
For example you copy image component from “/libs/foundation/components/image” to your site folder “/apps/testsite/components” by doing so you are creating a new component with is exactly same as Image component. After copying you can make changes to component based on your requirements. But the problem with this approach would be that if you are upgrading CQ then new version of CQ might have new implementation of “/libs/foundation/components/image” component than those changes will not be reflected in your “/apps/testsite/components/image” component, so you have to manually make those changes in custom component.


Inheritance/Extend Component:
Creating a custom component manually by creating all necessary nodes and setting value of “sling:superResourceType” property as “/libs/foundation/components/image”. By doing this you inherit all the feature of image component, even after upgrade you still inherit the features of image component.

There is a major difference between the two of them. Read the table below for better understanding:
Criteria	Overlaying/Override	Extending/Inheriting
		
Definition	Use the out-of-box component and you want to add some extra feature in it.	Copy the  out-of-box component into your project structure and then extend its functionality
Availability	Universally available across the WEM.	Not universally available across WEM as they are inherited for specific project.
Path	/apps/foundation/components/xyz	/apps/components/xyz
Steps to Create	They are copied from “/libs/foundation/components/ ” to “/apps/foundation/components/”	They are extended by using   
    “ sling:resourceSuperType ” property
Recommendations	Not recommended, as it has global affect and creates problems during CQ updates	Better way to increase a component functionality

Using Overlays (and the Sling Resource Merger)- 

You must not make changes in the /libs branch

Any changes you do make may be lost, because this branch is liable to changes whenever you:
•	upgrade on your instance
•	apply a hotfix
•	install a feature pack


AEM is configured to search the /apps branch first and then the /libs branch to find a resource. This mechanism means that your overlay (and the customizations defined there) will be used. To create an overlay, you:
1.	Recreate the required nodes and node structure as they exist in /libs
2.	Create the overlay node structure in /apps
3.	Make your changes in /apps

Non-Granite overlays and overlays prior to AEM 6.0,  
Method
•	Copy the content from /libs to /apps
You need to copy the entire sub-branch, including properties.
•	Make any changes under /apps
Disadvantages
•	Although your changes will not be lost when something changes under /libs, you might have to recreate certain changes that occur in your overlay under /apps.

AEM 6.0 onwards - for Granite-related overlays
Method
	Reconstruct the appropriate /libs structure under /apps
This does not require a 1:1 copy, the Sling Resource Merger is used to cross-reference the original definitions that are required.
	Make any changes under /apps
Advantages
	More robust to changes under /libs
	Only redefine what is actually required
	
Sling Resource Merger –
Purpose
The Sling Resource Merger provides services to access and merge resources. It merges overlays of resources using resource resolver search paths and diff mechanisms.
A customized sling vocabulary is used to use the resource merger, allowing you to manage overrides of nodes and their properties.
With this, the overlay resources/properties (defined in /apps) are merged with the original resources/properties (from /libs):
•	The content of /apps has a higher priority than that of /libs (i.e. it overlays it).
•	Where necessary, properties defined in /apps, indicate how content merged from /libs is to be used.
Properties
The resource merger provides the following properties:
•	sling:hideProperties (String or String[])
Specifies the property, or list of properties, to hide.
The wildcard * hides all.
•	sling:hideResource (Boolean)
Indicates whether the resources should be completely hidden, including its children.
•	sling:hideChildren (String or String[])
Contains the child node, or list of child nodes, to hide. The properties of the node will be maintained.
The wildcard * hides all.
•	sling:orderBefore (String)
Contains the name of the sibling node that the current node should be positioned in front of.
These properties affect how the corresponding/original resources/properties (from /libs) are used by the overlay (in /apps).

Creating the Overlay Structure
To create an overlay you need to recreate the /libs node, with the equivalent structure, under /apps. For example:
•	The definition of the navigation entry for the Sites console, as shown in the rail is defined at:   /libs/cq/core/content/nav/sites/jcr:title
•	To overlay this, create the following node: /apps/cq/core/content/nav/sites
Then update the property jcr:title as required.
Use Cases
These, in conjunction with standard functionality, enable you to:
•	Add a property
The property does not exist in the /libs definition, but is required in the /apps overlay.
1.	Create the corresponding node within /apps
2.	Create the new property on this node
•	Override a property (not auto-created properties)
             The property is defined in /libs, but a new value is required in the /apps overlay.
         
                  1. Create the corresponding node within /apps
2.	Create the matching property on this node (under /apps)
o	The property will have a priority based on the Sling Resource Resolver configuration.
o	Changing the property type is supported.
If you use a property type different to the one used in /libs, then the property type you define will be used.

•	Override an auto-created property
             By default, auto-created properties (such as jcr:primaryType) are not subject to an   
             overlay to ensure that the node type currently under /libs is respected. To impose an 
            overlay you have to recreate the node in /apps, explicitly hide the property and redefiine 
             it:
1.	Create the corresponding node under /apps with the desired jcr:primaryType
2.	Create the property sling:hideProperties on that node, with the value set to that of the auto-created property; for example, jcr:primaryType
This property, defined under /apps, will now take priority over the one defined under /libs


•	  Override a node and its children
               The node and its children are defined in /libs, but a new configuration is required in the        
              /apps overlay.
Combine the actions of:
1.	Hide children of a node (keeping the properties of the node)
2.	Override the property/properties
     •    Hide a property
              The property is defined in /libs, but not required in the /apps overlay.
1.	Create the corresponding node within /apps
2.	Create a property sling: hideProperties of type String or String[]. Use this specify the properties to be hidden/ignored. Wildcards can also be used. For example:
o	*
o	["*"]
o	jcr:title
o	["jcr:title", "jcr:description"]
   • Hide a node and its children
             The node and its children are defined in /libs, but not required in the /apps overlay.
1.	Create the corresponding node under /apps
2.	Create a property sling: hideResource
o	type: Boolean
o	value:  true
• Hide children of a node (while keeping the properties of the node)
The node, its properties and its children are defined in /libs. The node and its properties are required in the /apps overlay, but some or all of the child nodes are not required in the /apps overlay.
1.	Create the corresponding node under /apps
2.	Create the property sling: hideChildren:
o	type: String []
o	value: a list of the child nodes (as defined in /libs) to hide/ignore
The wildcard * can be used to hid/ignore all child nodes.
• Re-Order nodes
The node and its siblings are defined in /libs. A new position is required so the node is recreated in the /apps overlay, where the new position is defined in reference to the appropriate sibling node in /libs.
                  Use the sling: orderBefore property:
1.	Create the corresponding node under /apps
2.	Create the property sling:orderBefore:
This specifies the node (as in /libs) that the current node should be positioned before:
	type: String
	value: <before-SiblingName>

Validate user input in multifield components
implement the following:
•	"Listener" nodes in the multifield component
•	A validation attribute called beforeadd, whose value is defined through an appropriate JavaScript function

Troubleshoot CRXDE performance issues
If you find CRXDE slow or unresponsive, try the following troubleshooting approaches:
•	Validate the settings for the crxde:paths property. This property holds the paths of the folders that CRXDE mounts. Specifying a large node, such as /content, for this property may lead to performance issues.
•	Assign more memory to CRXDE in the CRXDE.ini file.
•	Delete the hidden .crxde folder from your home directory.
•	Start CRXDE from the command line.
Debugging
•	WCMMODE
•	?wcmmode = design (The WCM is in design mode.)
•	?wcmmode = disabled (The WCM is disabled.)
•	?wcmmode = edit (The WCM is in edit mode.)
•	?wcmmode = preview (The WCM is in preview mode.)
•	Debug
•	?debug = layout (Shows you all details of the components used on your page)
•	?debug = mdev ( display mobile device info as inline HTML)
•	?debug = mdevc (display mobile device info as HTML comment)
•	?debugClientLibs=true (Writes out all Clientlib categories as separate files (check your HTML-source))
•	CTRL+SHIFT+U ( In combination with ?debugClientLibs=true will show you timing information of your page)
Templates
Order of evaluation:
o	cq:allowedTemplates
o	allowedPaths (deprecated)
o	allowedParents
o	allowedChildren


Development Objects in the WEM Environment
Development Objects
Template
A Template is used to create a Page and defines which components can be used within the selected scope. A Template is a hierarchy of nodes that has the same structure as the page to be created, but without any actual content. 
Templates are built up of Components. Components use, and allow access to, Widgets, which are used to author/render content. 
A Template is the basis of a Page. To create a Page, the Template's content must be copied (/apps/<application name>/templates/<template name>) to the corresponding position in the site-tree (this occurs automatically if page is created using CQ5). This copy action also gives the Page its initial content and the property sling:resourceType, the path to the "Page" Component that is used to render the page.
How to create a Template:
1.	Right-click /apps/<application name>/templates – then select Create…, Create Template …
2.	Enter the desired Template “Label”, “Title”, “Description”, “Resource Type”, and “Ranking” in the dialog – then select Next. 
■ Label = the name of the Template/node that will be created ■ contentpage 
■ Title (property jcr:title) = the title that will be assigned to the Template ■ Training Contentpage 
■ Description (property jcr:description) = the description that will be assigned to the Template ■ training project content page component 
■ Resource Type (property sling:resourceType) = the Component's path that will be assigned to the Template and copied to implementing pages ■ training/components/page/contentpage 

NOTE The property sling:resourceType will be created on the Template's jcr:content node. In addition, the Component may not yet exist. This is because you have not yet created it.
3.	■ Ranking (property ranking) = the order (ascending) in which this Template will appear in relation to other Templates. Setting the Rank to 1, will ensure that our Template appears first in the list.
4.	Select Next for “Allowed Paths” .  Allowed  Paths will define paths where this template may be used to create pages.
5.	You will need to add a path to Allowed Paths.  Click on the plus sign and enter the following value:    /content(/.*)?    
                     NOTE : If you forget to enter allowedPaths before clicking on Finish.      
                                   Create the following property on your template node:
                      ■ Name:    allowedPaths 
                       ■ Type:     String[] (String Array) 
                        ■ Value:    /content(/.*)?

6.	Click Next for “Allowed Parents” – then select OK on “Allowed Children”.
7.	Finish
        Note : Allowed parent : path of the template that is allowed to be parent of this template.
                   Allowed children : path of the template that is allowed to be child of this template
                     Allowed path : path of the page that is allowed to be based on this template.




CQ Component

Components are modular, re-usable units that implement specific functionality/logic to render the content of your Web site. They have no hidden configuration files, can include other Components, and can run anywhere within CQ5 or in isolation (e.g. portal). A Component could be described as a collection of scripts (e.g. JSPs, Java servlets, etc.) that completely realize a specific function. More specific, a "Page" Component is typically referenced by a Template
How to create a “Page-rendering” Component using CRXDE Lite:

1.	Right-click /apps/<application name>/components/page – then select Create…, Create Component … 

2.	Enter the desired Component “Label”, “Title”, and “Description” in the dialog – then select Next. 

■ Label = the name of the Component/node that will be created ■ contentpage 
■ Title (property jcr:title) = the title that will be assigned to the Component ■ Training Contentpage 
■ Description (property jcr:description) = the description that will be assigned to the Component ■ NA

3.	Select Next for “Advanced Component Settings” and “Allowed Parents” – then select OK on “Allowed Children”
4.	creation of the component results in the creation of the default script.\




Item : An item is either a node or a property.
Node : Nodes and their properties are defined in the JCR API 2.0 specification (JSR 283). They store content, object definitions, rendering scripts and other data.
Nodes define the content structure, and their properties store the actual content and metadata.
Content nodes drive the rendering. Sling gets the content node from the incoming request. The property sling:resourceType of this node points to the Sling rendering component to be used.
A node, which is a JCR name, is also called a resource in the Sling environment.
For example, to get the properties of the current node, you can use following code in your script:
    PropertyIterator properties = currentNode.getProperties();
With currentNode being the current node object.


Widget : In WEM all user input is managed by widgets. These are often used to control the editing of a piece of content.
Dialogs are built by combining Widgets
Dialog :  A dialog is a special type of widget.
To edit content, WEM uses dialogs defined by the application developer. These combine a series of widgets to present the user with all fields and actions necessary to edit the related content.
Dialogs are also used for editing metadata, and by various administrative tools.

Page : A page is an 'instance' of a template.
A page has a hierarchy node of type cq:Page and a content node of type cq:PageContent. The property sling:resourceType of the content node points to the Page Component used for rendering the page.
For example, to get the name of the current page, you can use following code in your script:
String pageName = currentPage.getName();
With currentPage being the current page object.

Structure within the Repository
•	/apps
Application related; includes component definitions specific to your website. The components that you develop can be based on the out of the box components available at /libs/foundation/components.
•	/content
Content created for your website.
•	/etc
Tools section for detailed information.
•	/home
User and Group information.
•	/libs
Libraries and definitions that belong to the core of WEM. The sub-folders in /libs represent the out of the box WEM features as for example search or replication.  The content in /libs should not be modified as it affects the way WEM works. Features specific to your website should be developed under /apps (see Customizing Components and Other Elements).
•	/tmp
Temporary working area.
•	/var
Files that change and are updated by the system; such as audit logs, statistics, event-handling. The sub-folder /var/classes contains the java servlets in source and compiled forms that have been generated from the components scripts
•	/conf .
•	Oakindex node
Component development:
Create component, a script file will be generated.

Important files to add in component script :  
“Init.jsp”


“global.jsp" (page component)

global.jsp

When you develop the JSP script of a CQ5 component, it is recommended to include the following code at the top of the script: <%@include file="/libs/foundation/global.jsp"%>
The Day provided global.jsp declares the Sling, CQ and JSTL taglibs and exposes the regularly used scripting objects defined by the <cq:defineObjects /> tag. This shortens and simplifies the JSP code of your component.

The <cq:defineObjects> tag exposes the following, regularly used, scripting objects which can be referenced by the developer.

componentContext  
component the current CQ5 component object of the current resource
currentDesign the current design object of the current page
currentPage  the current CQ WCM page object (com.day.cq.wcm.api.Page interface).
currentNode the current JCR node object (javax.jcr.Node interface).
 currentStyle  the current style object of the current cell (com.day.cq.wcm.api.designer.Style interface). 
 designer  the designer object used to access design information (com.day.cq.wcm.api.designer.Designer interface).
 editContext the edit context object of the CQ5 component (com.day.cq.wcm.api.components.EditContext interface). 
pageManager  the page manager object for page level operations (com.day.cq.wcm.api.PageManager interface). 
pageProperties the page properties object of the current page (org.apache.sling.api.resource.ValueMap). 
properties  the properties object of the current resource (org.apache.sling.api.resource.ValueMap). 
 resource  the current Sling resource object (org.apache.sling.api.resource.Resource interface).
 resourceDesign  the design object of the resource page (com.day.cq.wcm.api.designer.Design interface). 
resourcePage  the resource page object (com.day.cq.wcm.api.Page interface)

How to include the global.jsp script in your Training “Page” Component: 
1. Open the .jsp script by double-clicking it. 
2. Enter the include statement in your JSP, similar to below – then Save. .jsp
 <%@include file="/libs/foundation/global.jsp"%> <html </html> 
3. Test your script by requesting a Page in CQ5 Siteadmin that implements this “Page” Component. If successful, you should not notice any difference in the way the Page is rendered
Init.jsp
initialize CQ5 WCM, enabling use of the Sidekick and other content management tools.

Include “<cq:include script="/libs/wcm/core/components/init/init.jsp"/>” in <head> section of the jsp page.
If successful, you should now see the Sidekick appear on the web page.

Accessing Content
There are three methods to access content in AEM WCM:
•	Via the properties object introduced in global.jsp:
The properties object is an instance of a ValueMap (see Sling API) and contains all properties of the current resource.
Example: String pageTitle = properties.get("jcr:title", "no title"); used in the rendering script of a page component.
Example: String paragraphTitle = properties.get("jcr:title", "no title"); used in the rendering script of a standard paragraph component.
•	Via the currentPage object introduced in global.jsp:
The currentPage object is an instance of a page (see CQ5 API). The page class provides some methods to access content.
Example: String pageTitle = currentPage.getTitle();
•	Via currentNode object introduced in global.jsp:
The currentNode object is an instance of a node (see JCR API). The properties of a node can be accessed by the getProperty() method.
Example: String pageTitle = currentNode.getProperty("jcr:title");


The Sling ValueMap makes retrieving properties from CQ easy and removes a lot of the error-prone code you have to use when using the JCR APIs, however it does not allow setting of properties. This unfortunately results in developers using the Sling ValueMap to retrieve properties and JCR Nodes and Properties to set properties. 

Sling also provides an interface which allows for retrieving properties like a ValueMap and an easy faculty for setting properties as well.  The PersistableValueMap differs from the ValueMap only in it's put method does not throw an exception and it offers two more methods.  The reset method, which resets any values set in the current session and the save method, which persists any values set in the current session.

to retrieve a PersistableValueMap, simply call:
PersistableValueMap properties = aResource.adaptTo(PersistableValueMap.class);
Once you have an instance of the PersistableValueMap, you can use it like a Value Map
String value = properties. Get("key”, String. Class);
Or use it to persist values to CQ:
propertes.put("key”,” value");
properties.save();


Simple dialog widget development

Difference between dialog and design dialog?
Criteria	Dialog	Design Dialog
Definition	Dialog will change the content at the page level.	Design dialog will change the content at the template level.
Availability	authored in edit mode	authored in design mode
Naming Convention	cq:Dialog node with name dialog	cq:Dialog node with name design_dialog
Value Storage	stored under pages jcr:content node	stored under design page located under /etc/design
Accessing Values in CQ5 JSPs	via properties object	via currentStyle object.

Dialog :  typically used to edit content, but can also just display information.

Page specific (in this case component dialog is used)
values stored via dialog get stored at page level under component’s node. 

How to retrieve values read from dialog (widget) to jsp?
Sol: String var= properties.get("<name of widget>","");

Design dialog: specifies the design editing options for this component.
Design/Global (in this case design_dialog is used).
value stored via a design dialog is store at design path of your teamplate (see cq:designPath property of root node of your application/page), usually this location is under /etc/design/

How to retrieve values from design_dialog to jsp?
Sol: String var= currentStyle.get("<name of widget>","");
The root node of the Dialog has to be of node type “cq:Dialog” and named “dialog”.
Below this Dialog root node, the nodes for the tabs of the Dialog have to be added. These “tab nodes” must be of node type “cq:WidgetCollection”. Below the “tab nodes” the “widget nodes” can then be added. The “widget nodes” must be of node type “cq:Widget”.

Node structure:  “cq:dialog””cq:widgetCollection””cq:widget”

<%= properties.get("title", currentPage.getTitle()) %>

notice the use of the Sling ValueMap class/object “properties”. This object allows you to easily get properties associated with this instance of this Component.

the property that will define where the content is stored 
1.	Name = name 
2.	Type = String 
3.	 Value = ./title

	the property that will define the Widget type (i.e. user interface control) 
1.	Name = xtype 
2.	Type = String 
3.	Value = textfield 

	the property that will define the label applied to the Widget 
1.	Name = fieldLabel 
2.	 Type = String 
3.	Value = Enter Title Here



using the xtype of cqinclude will reference a part of the existing structure, allowing the custom component and its dialog to take advantage of any future changes to the referenced structure.

Complex component:

Image , most likely an xtype of smartimage , xtype of html5smartimage
Selection control, xtype of selection , 
dropdown control -- type select , options(cqwidgetCollection),O1 (unstructured with text and value properties)..etc
Radio—type radio, options(cqwidgetCollection),O1 (unstructured with text and value properties)..etc
Multifields-
The MultiField is an editable list of form fields for editing multi-value properties. A multifield lets a user dynamically add additional fields to a dialog.

Muiltifields – 
widget of xtype multifieldfieldConfig (unstructured) as custom xtype ejstcustom with properties optionprovider (Ejst.x3.provideOptions2 . that populates the drop-down control in the custom xtype.  This value is implemented as a method) 
widget of xtype multifieldfieldConfig (unstructured) with any defined xtype.
Requirement: “complex” component contain image tab

Requirement analysis:  
The image: 1. Must be editable by a content author. 2. Can be dragged-and-dropped from the Content Finder

Solution:
The image: 1. Is a Dialog Widget, most likely an xtype of smartimage. 2. Must be configured in the Component's cq:editConfig to allow for dragging-and-dropping of images from the Content Finder.


Development:
Stage 1. Dialog for content author 

Steps:  
1.	Create component “complex”
2.	Create dialog 
3.	Below dialog node tab1  items(cq:widgetcollection)
4.	Define the following properties on the items parent of the tab1 node: 
a.  the property that defines widget reference 
■ Name = xtype ■ Type = String ■ Value = cqinclude 
b. the property that defines the path to the reference
■ Name = path ■ Type = String ■ Value = /libs/foundation/components/image/dialog/items.infinity.json



// getting the image from the Dialog/resouce // notice the use of the second parameter "image" -- this signifies that the // image will live on a resource (called image) below the requested resource !Image image = new Image(resource, "image"); // setting the selector so that the "parbase" can work its magic !image.setSelector(".img"); // getting the rich text from the Dialog !String text = properties.get("text", "TEXT NA"); // getting the path from the Design Dialog !String path = currentStyle.get("path", "PATH NA"); %> !<h2><%= path %></h2> !<%= text %><br /> <% !image.draw(out); %>

enables drag-and-drop capabilities from the Content Finder

In order to be able to drag-and-drop assets from the Content Finder to a Component on a Page, there must be a drop targets configuration node called cq:dropTargets (of type nt:unstructured) below the edit configuration node (cq:editConfig) of a Component

Componentcq:editconfig (node)  cq:dropTargets(node) cq:droptargetconfig (node) node (image …etc)

 set the properties as follows (in case of image drag and drop ):
Name	Type	Value
accept	String	image/(gif|jpeg|png)
groups	String	media
propertyName	String	./imageReference



Configuring the Edit Behaviour of a Component
cq:editConfig node properties:
•	cq:actions (String array): defines the actions that can be performed on the component.
Properties :
text:<some text>  (Displays the static text value)
              -                             (add a spacer)
              Add , delete. Insert , copymove   ( add corresponding buttons to the component)
•	cq:layout (String): : defines how the component is edited.
             The cq:layout property (String) defines how the component can be edited.
             Property Value , rollover (component edit available “on mouse over” though click) ,
                                      editbar   (component edit available through toolbar)
                                       Auto (choice left on the client side code )
•	cq:dialogMode (String): defines how the component dialog is opened.
             The cq:dialogMode property (String) defines how the component dialog will be opened.  
              Property Value,  floating , inline , auto
                                 
•	cq:emptyText (String): defines text that is displayed when no visual content is present.
The cq:emptyText property (String) defines text that is displayed when no visual content is present.

•	cq:inherit (Boolean): defines if missing values are inherited from the component that it inherits from.
The cq:inherit property (boolean) defines if missing values are inherited from the component that it inherits from.
It defaults to false.
To inherit the implementation of the component super type, add the following property to the cq:editConfig node:
•	Name: cq:inherit
•	Type: Boolean
•	Value: True

Configuring with cq:editConfig child nodes:
•	cq:dropTargets (node type nt:unstructured): defines a list of drop targets that can accept a drop from an asset of the content finder.
It serves as a collection of nodes of type cq:DropTargetConfig.
Each child node of type cq:DropTargetConfig defines a drop target in the component.
The node name is important because it must be used in the JSP as follows to generate the CSS class name assigned to the DOM element that is the effective drop target:
<drop target css class> = <drag and drop prefix> + <node name of the drop target in the edit configuration>
The <drag and drop prefix> is defined by the Java property  com.day.cq.wcm.api.components.DropTarget.CSS_CLASS_PREFIX.
For example, the class name is defined as follows in the JSP of the Download component (/libs/foundation/components/download/download.jsp):
    String ddClassName = DropTarget.CSS_CLASS_PREFIX + "file";
"file" being the node name of the drop target in the edit configuration of the Download component.
The node of type cq:DropTargetConfig needs to have the following properties:
accept (Regex applied to the asset mime type to validate if dropping is allowed.), group (Array of drop target groups. Each group must match the group type that is defined in the content finder extension and that is attached to the assets.) ,propertyName(Name of the property that will be updated after a valid drop.)

              
•	cq:actionConfigs (node type nt:unstructured): defines a list of new actions that are appended to the list defined by cq:actions property.
               Each child node of cq:actionConfigs defines a new action by defining a widget. The  
               default widget type is CQ.Ext.Button.
•	cq:formParameters (node type nt:unstructured): defines additional parameters that are added to the dialog form.
Each property is mapped to a form parameter.
•	cq:inplaceEditing (node type cq:InplaceEditingConfig): defines an inplace editing configuration for the component.
               It can have the following properties: active Boolean true to enable in place editing of the 
               component. configPath (String) Path of the editor configuration. The configuration can be     
                specified by a configuration node. editorType ((String) Editor type. The available types are: 
               plain text , text {html content that uses rich text}) 
•	cq:listeners (node type cq:EditListenersConfig): defines what happens before or after an action occurs on the component.
Property Name	Default Value
beforedelete	 
beforeedit	 
beforecopy	 
beforeinsert	 
beforemove	 
beforechildinsert	 
afterdelete	REFRESH_SELF
afteredit	REFRESH_SELF
aftercopy	REFRESH_SELF
afterinsert	REFRESH_INSERTED
aftermove	REFRESH_SELFMOVED
afterchildinsert	 
Note
In the case of nested components there are certain restrictions on actions defined as properties on the cq:listeners node:
•	For nested components, the values of the following properties must be REFRESH_PAGE:
o	aftermove
o	aftercopy 
The event handler can be implemented with a custom implementation. For example:
afteredit = "project.customerAction"
where project.customerAction is a static method.
The following example is equivalent to the REFRESH_INSERTED configuration:
afterinsert="function(path, definition) { this.refreshCreated(path, definition); }"
To know the parameters that can be used in the handlers, refer to the before<action> and after<action> events section of the CQ.wcm.EditBar and CQ.wcm.EditRollover widget documentation.
With the following configuration the page is refreshed after the component has been deleted, edited, inserted or moved:
1
2
3
4
5
6	<cq:listeners
    jcr:primaryType="cq:EditListenersConfig"
    afterdelete="REFRESH_PAGE"
    afteredit="REFRESH_PAGE"
    afterinsert="REFRESH_PAGE"
    afterMove="REFRESH_PAGE"/>

Registering custom validators is done by calling the jQuery based $.validator.register method. The register method takes a single JavaScript object literal argument. The parameter looks for four properties: selector, validate, show and clear, of which only selector is required. 


regex	String	/^\/content\/trainingSite\/(.)*$/	Defines the regular expression used to evaluate user input
regexText	String	Please insert a Page under /content/trainingSite	Define the error message if a user's input fails the regular expression

Another approach: 1. Use of listeners with custom validator function 2. Write custom function 
	Dialog.



how to register custom xtypes 

1.	Add a widget to dialog with x-type multifield
2.	Create fieldConfig node (unstructured with x-type “ejstcustom”) with props.  optionsProvider Ejst.x3.provideOptions2/ Ejst.x3.provideOptions

              fieldconfig' is a config option of the CQ.form.MultiField object.
              'optionsProvider' is a configuration of the ejstcustom widget. It is set with the 
               Ejst.x3.provideOptions method

3.	To develop a custom xtype in customwidget.js , you can use a compositeField object, 
Extends the CQ.form.CompositeField widget.

Overrides CQ.Ext.Component#initComponent to add the 3 fields

Overrides the methods setValue, getValue and getRawValue of CQ.form.CompositeField in order to set and retrieve the value of CustomWidget


4.	 register xtype -- CQ.Ext.reg("ejstcustom", Ejst.CustomWidget)
Switch to Design mode by either:
•	adding ?wcmmode=design to the end of the URL and accessing again; for example:
<contextPath>/ Test.html?wcmmode=design
•	clicking Design in Sidekick



Disable Upload Capability of the Image Component
Add a new property to dialog widget:
•	Name: allowUpload
•	Type: String
•	Value: false




Grid component
A Grid Panel represents data in a tabular format of rows and columns.
gridPanel is a CQ.Ext.grid.EditorGridPanel object that can be edited:
•	it is based on the pre-defined store store and on the column model cm
•	afteredit listener makes sure that after a cell in the "Test" column has been edited:
	the property 'test' of the node at the path defined by the "jcr:path" column is set in the repository with the value of the cell
	if the POST is successful, the value is added to the store object, otherwise it is rejected

Store : the model holding the data records (rows) 

A Store object may access a data object using:
o	configured implementation of DataProxy
o	data to automatically pass in data
o	loadData to manually pass in data



proxy: new CQ.Ext.data.HttpProxy({ url: CQ.HTTP.externalize(""),method:""}), The property that is responsible for populating the grid with data is proxy. This property provides access to a data object.
baseParams: An object containing properties which are to be sent as parameters for every HTTP
request. baseParams may be superseded by any params specified in a load request.
reader: The Reader object which processes the data object and returns an Array of
CQ.Ext.data.Record objects which are cached keyed by their id property.
reader is a CQ.Ext.data.JsonReader object that reads the servlet response in json format for COULMNS. A CQ.Ext.data.JsonReader object lets you retrieve grid data by using JSON
       var reader = new CQ.Ext.data.JsonReader ({
                     totalProperty: Name of the property from which to retrieve the total number of records in the dataset. This is only needed if the whole dataset is not passed in one go, but is being paged from the remote server. Defaults to total.
	
                     roots: Required. The name of the property which contains the Array of row objects. Defaults to undefined. An exception will be thrown if the root property is undefined.
                     fields:[{name:’’,type:’’}] // a fields property which the JsonReader will use as an argument to the data Record create method in order to configure the layout of the Records it will produce.


groupField: The field name by which to sort the store's data (defaults to '').



Important: for gridpanel development,

1.	Create an js default grid
2.	Define two funtions function getGridData(grid) and function getGridPanel()
3.	For implementation of getGridPanel() Create an instance of  CQ.Ext.grid.EditorGridPanel With configuration properties  store and colmnModel and so on…..
4.	cm is a CQ.Ext.grid.ColumnModel object with configuration id, header, dataIndex(name of the field in grid mandatory), editor
5.	
6.	Create an instance of CQ.Ext.data.GroupingStore With configuration of proxy , reader property
7.	Reader is an instance of CQ.Ext.data.JsonReader, with configuration properties root , totalproperties and field
8.	  Now develop compoenet jsp defined for the grid that controls the behaviour of the component, including the grid.       
9.	To display a CQ.Ext.grid.EditorGridPanel instance, create a CQ.Ext.Window instance.
10.	getGridPanel, returns a CQ.Ext.grid.EditorGridPanel instance to a variable named gridPanel.

Moving Components to the Publish Instance
•	Use Package Manager to add your components to a package and move them to another AEM instance.
•	Use the Activate Tree replication tool to replicate the components.
Maven configuration for CQ project
Download Maven
You can download Maven 3 from the following URL:
http://maven.apache.org/download.html
Set up a system environment variable to reference Maven.
Set Maven_home = {install directory}
      Path={install directory}/bin

To test whether you properly setup Maven, enter the following Maven command into a command prompt:
%M3_HOME%\bin\mvn -version

copy the Maven configuration file named settings.xml from [install location] to your user profile.
C:\Users\ %userprofile%\.m2\.
Create working directory
Eg. C:\adobe
Run the following Maven command:
mvn archetype: generate -DarchetypeRepository=https://repo.adobe.com/nexus/content/groups/public/ -DarchetypeGroupId=com.day.jcr.vault -DarchetypeArtifactId=multimodule-content-package-archetype -DarchetypeVersion=1.0.2
Change the command prompt to the generated project.
Run the following Maven command:
mvn eclipse:eclipse

After you run this command, you can import the project into Eclipse.
IMPORT PROJECT INTO THE ECLIPSE.
Modules
The main parts of the template are:
•	core: Java bundle containing all core functionality like OSGi services, listeners or schedulers, as well as component-related Java code such as servlets or request filters.
•	ui.apps: contains the /apps (and /etc) parts of the project, ie JS&CSS clientlibs, components, templates, runmode specific configs as well as Hobbes-tests
•	ui.content: contains sample content using the components from the ui.apps
•	ui.tests: Java bundle containing JUnit tests that are executed server-side. This bundle is not to be deployed onto production.
•	ui.launcher: contains glue code that deploys the ui.tests bundle (and dependent bundles) to the server and triggers the remote JUnit execution
How to build
To build all the modules run in the project root directory the following command with Maven 3:
mvn clean install
If you have a running AEM instance you can build and package the whole project and deploy into AEM with
mvn clean install -PautoInstallPackage
Or to deploy it to a publish instance, run
mvn clean install -PautoInstallPackagePublish
Or alternatively
mvn clean install -PautoInstallPackage -Daem.port=4503
Or to deploy only the bundle to the author, run
mvn clean install -PautoInstallBundle
Creating an Adobe Experience Manager 6.3 Project using Adobe Maven Archetype 11

mvn org.apache.maven.plugins:maven-archetype-plugin:2.4:generate 

-DarchetypeGroupId=com.adobe.granite.archetypes 
-DarchetypeArtifactId=aem-project-archetype 
-DarchetypeVersion=11 
-DarchetypeCatalog=https://repo.adobe.com/nexus/content/groups/public/
After you import the project into Eclipse, notice each module is a separate Eclipse project:
•	core - where Java files that are used in OSGi services and sling servlets are located
•	launcher - 
•	tests 
•	apps 
•	content - 

AEM deployment’s with jenkins
Once the Jenkins is installed then the next step is go to dashboard of Jenkins and install plugins as part of this I have installed Maven plugin
 

In the Manage plugins screen go to the the available tabs and select  Maven integration plugin and click on “Download now and install after restart”, you need to restart Jenkins server to see changes, then the next step is configuring global tools
Global Tool Configuration :
Using global tool configuration we can configure tools such as JDK, Maven, GIT, SVN etc…which is applicable for all jobs which are configured in Jenkins server
Configure JDK :
Here, I have mapped to JAVA_HOME but if you want you can install using install automatically by selecting JDK version
 

Configure GIT :
 

Maven Installtion :
You can install either using local file system or using install automatically
 

Once gobal tools configurations is completed  then, we need to create a job to build and deploy code into author and publish environments, FOR this we can do using new item option on left navgation of Jenkins dashboard, the job name here I am using is “dev-aemtoolkit” and type of project you need to select is Maven Project

 All my source code is in GIT Hub so I have selected GitHub Project on the general tab and in the textbox enter github project url
Then go to the source code management and enter repository url and select admin credentials, you can specify branch in branch specifier, here I am connecting to master branch, if you want to connect to development branch then use “*/development”
 

In the Build triggers section select “Build whenever a SNAPSHOT dependency is built” checkbox and then in the Build Goals and Options section enter below command
clean install -X -P autoInstallPackage -Dcrx.host=localhost -Dcrx.port=4503 -Dcrx.user=admin -Dcrx.password=admin -Dvault.timeout=60
If you are connecting to remote machine then you need to change localhost to remote server IP Address and click on save
In the Build Settings Email Notification section enter recipents email address and click on save
 


Once the configuration is completed then go to the dashboard and select the job and click on Build now, if the build is success then you wll see blue color ball symbol other wise symbol will be in red, you can see logs by clicking on these symbol’s
 

The final step is go to the package manager and check for aemtoolkit package  
The Technology Stack that CQ5 is based on
APACHE SLING
JCR
OSGI
OSGI 
Open source gateway initiative-
The OSGi technology is a set of specifications that define a dynamic component system for Java. These specifications enable a development model where an application is composed of several components which are packaged in bundles. Components are communicating through nano-services.
An application in this context represents the functionality desired by the organization.
Components are the reusable building blocks, a.k.a. the bricks, the components provide the implementation code. Since components should be reusable, they should watch their dependencies because any dependency will be added to any application that uses this component.
The OSGi specifications enable components to hide their implementations from other components while communicating through nano-services, which are objects that are explicitly shared between components.
Nano-services are the innovation that OSGi brought to the table. Nano services are the reified links between components. In a well designed OSGi system, all links between components go through a nano-service. Nano services have an API that is defined in a Java package. The API consists of a classes and/or interfaces that are needed for the collaboration between the provider of the service and the consumer of the service. 
A Bundle is the OSGi name for a module, it packages the components with their resources. Bundles are explicitly in their requirements on the environment and the capabilities they will provide to the environment. For example, a Bundle will express what Java packages it needs in what version.
 
OSGi Framework	
The OSGi Framework is made up of three layers – Module, Lifecycle, and Services – that define how extensible applications are built and deployed. The responsibilities of the layers are:
•	Module —  The layer that defines how a bundle can import and export code.
Defines how a module, or a Bundle in OSGi-speak, is defined. Basically, a bundle is just a plain old JAR file, whose manifest file has some defined entries. These entries identify the bundle with a symbolic name, a version and more. In addition, there are headers which define what a bundle provides Export-Package and what a bundle requires to be operative Import-Package and Require-Bundle.
•	Lifecycle — The lifecycle layer defines the states a bundle may be in and describes the state changes. 
By providing a class, which implements the BundleActivator interface and which is named in the Bundle-Activator manifest header, a bundle may hook into the lifecycle process when the bundle is started and stopped.
            The API to install, start, stop, update, and uninstall bundles.
•	Services — For the application to be able to interact, the OSGi Core Specification defines the service layer. This describes a shared registry for services.
•	Security -- The OSGi Security Layer is an optional layer that underlies the OSGi framework. The layer is based on the Java 2 security architecture. It provides the infrastructure to deploy and manage applications that must run in fine-grained controlled environments.


Module layer: jarfile+metadata
The Framework defines a unit of modularization, called a bundle. A bundle is comprised of Java classes and other resources, which together can provide functions to end users. 

Bundles can share Java packages among an exporter bundle and an importer bundle in a well-defined way. In the OSGi framework, bundles are the only entities for deploying Java-based applications.
A bundle is deployed as a Java ARchive (JAR) file.
A bundle is a JAR file that:

--Contains the resources necessary to provide some functionality. These resources may be class files for the Java programming language, as well as other data such as HTML files, help files, icons, and so on. A bundle JAR file can also embed additional JAR files that are available as resources and classes.

-- Contains a manifest file describing the contents of the JAR file and providing information about the bundle. This file uses headers to specify information that the Framework needs to install correctly  and activate a bundle. 
 -- Can contain optional documentation in the OSGI-OPT directory of the JAR file or one of its subdirectories. Any information in this directory is optional.

Bundle Manifest Headers
A bundle can carry descriptive information about itself in the manifest file that is contained in its JAR file under the name of META-INF/ MANIFEST.MF.

Bundle-ActivationPolicy, Bundle-Activator, Bundle-Category, Bundle-ClassPath, Bundle-ManifestVersion, Bundle-Name, Bundle-SymbolicName (Mandatory:The bundle symbolic name should be based on the reverse domain
name convention,), Bundle-Version, DynamicImport-Package, Export-Package, import-Package


Manifest-Version: 1.0
Bnd-LastModified: 1522664582333
Build-Jdk: 1.8.0_141
Built-By: iz5kzla
Bundle-Description: Core bundle for sample-aem
Bundle-ManifestVersion: 2
Bundle-Name: qb-aem - Core
Bundle-SymbolicName: com.adobe.vikas.sample.core
Bundle-Version: 0.0.1.SNAPSHOT
Created-By: Apache Maven Bundle Plugin
DynamicImport-Package, Export-Package, import-Package

Lifecycle layer:

The Life Cycle Layer provides an API to control the security and life cycle operations of bundles. The layer is based on the module and security layer.	

Entities- 

• Bundle - Represents an installed bundle in the Framework.
• Bundle Context - A bundle's execution context within the Framework. The Framework passes this
to a Bundle Activator when a bundle is started or stopped.
• Bundle Activator - An interface implemented by a class in a bundle that is used to start and stop
that bundle.
• Bundle Event - An event that signals a life cycle operation on a bundle. This event is received via a
(Synchronous) Bundle Listener.
• Framework Event - An event that signals an error or Framework state change. The event is received
via a Framework Listener.
• Bundle Listener - A listener to Bundle Events.
• Synchronous Bundle Listener - A listener to synchronously delivered Bundle Events.
• Framework Listener - A listener to Framework events.
• Bundle Exception - An Exception thrown when Framework operations fail.
• System Bundle - A bundle that represents the Framework.
• Framework - An interface implemented by an object that represents the actual framework. It allows
external management of a Framework.
• Framework Factory - An interface implemented by Framework providers that allows the creation
of a framework object.

 

Frameworks:
A launcher can launch a framework implementation and then manage it, regardless of the implementation type of the framework. This allows a launcher to embed an OSGi framework without having to provide code that differs between different implementations.

A framework implementation must provide a factory class. A factory class is an indirection to create
a framework implementation object. The implementation factory class must implement the FrameworkFactory
interface.

The launcher can use the following ways to get this class name:

• Service Provider Configuration model, 
• Get it from some configuration and use Class.forName, or
• Hardcode the name.

The FrameworkFactory interface has a single method: newFramework(Map). The map provides the
sole configuration properties for the framework object. The result of this method is a framework object,
this object implements the Framework interface. The Framework interface extends the Bundle
interface and adds methods to handle the issues unique to launching a framework. The framework
object can be seen as the system bundle, though the framework object and the system bundle do not
have to be identical, implementations are allowed to implement them in different objects.

Before the framework object can be used, the launcher must first initialize it by calling the init
method. After initialization, the framework object can provide a valid Bundle Context and has
registered any framework services, but any installed bundles must be in the INSTALLED state. The
launcher can then configure the framework object by installing bundles, interacting with the framework
services, or registering launcher services. The launcher can also start bundles, but these bundles
will not be started until the framework object becomes ACTIVE.

After the framework object is properly configured, the launcher can start it by calling the start
method. The framework object will become ACTIVE, and it will move the startlevel (if present) to
the configured start level. This can then resolve and start any installed bundle. After a framework
has become ACTIVE, it can be stopped from the framework object, or through the system bundle.
The launcher can wait for a framework object to be stopped with the waitForStop method. This
method will block until the framework is completely stopped and return a Framework event indicating
the cause of the stop. After the framework object has been shutdown, and the waitForStop
method has returned, all installed bundles will be in the INSTALLED state. The same framework object
can be re-initialized, and started again, any number of times.


Life Cycle of a Framework

Once the frameworks are created, it must be in the INSTALLED state. In this state, the framework is
not active and there is no valid Bundle Context. From this point on, the framework object can go
through its life cycle with the following methods.
• init - If the framework object is not active, then this method moves the framework object into the
STARTING state.
• start - Ensure that the framework is in the ACTIVE state. This method can be called only on the
framework because there are no bundles running yet.
• update - Stop the framework. This returns the Framework event STOPPED_UPDATE or
STOPPED_BOOTCLASSPATH_MODIFIED to the waitForStop method and then restarts the framework
to its previous state. The launcher should then take the appropriate action and then call
the waitForStop method again or reboot the VM. The update method can be called on the framework
or on the system bundle. If the framework is not active, this has no effect.
• stop - Move the framework into the RESOLVED state via the STOPPING state. This will return a
Framework STOPPED event from the waitForStop method. The Framework's Bundle Context is
no longer valid. The framework must be initialized again to get a new, valid Bundle Context. The
stop method can be called on the framework or on the system bundle.
• uninstall - Must not be called, will throw an Exception when called.

Initializing the Framework
Before the framework can be used, it must be initialized. Initialization is caused by one of the init
methods or implicitly by the start method. An initialized framework is operational, but none of its
bundles are active. This is reflected in the STARTING state. As long as the framework is in this state,
new bundles can be installed without any installed code interfering. Existing bundles must all be in
the INSTALLED or RESOLVED state. In this state, the framework will run at start level 0.

Starting the Framework
After the framework has been initialized, it can be started with the start method. This start method
must be called on the framework object. The start method moves the framework into the ACTIVE
state. If the framework was not initialized, it must be initialized first.

After the system bundle enters the ACTIVE state, a Framework STARTED event is broadcast.

Stopping a Framework
When the framework is shut down, it first enters the STOPPING state. All ACTIVE bundles are stopped as described in the Bundle.stop method, except that their persistently recorded start state is kept unchanged. Any exceptions that
occur during shutdown must be wrapped in a BundleException and then published as a Framework
event of type FrameworkEvent.ERROR. After a framework object is stopped and in the resolved state, it can be initialized and started again.

The Bundle Object
For each bundle installed in the OSGi framework, there is an associated Bundle object. The Bundle
object for a bundle can be used to manage the bundle's life cycle. This is usually done with a Management
Agent, which is also a Bundle.

Bundle Identifiers

A bundle is identified by a number of names that vary in their scope:
Bundle identifier: A long: Its purpose is to distinguish bundles in a Framework. Bundle identifiers are assigned in ascending order to bundles when they are installed.
The method getBundleId () returns a bundle's identifier.

Bundle location: A name assigned by the management agent (Operator) to a bundle during the installation.
This string is normally interpreted as a URL to the JAR file but this is not mandatory.
Within a particular Framework, a location must be unique. A location string uniquely identifies
a bundle and must not change when a bundle is updated. The getLocation () method retrieves
the location of a bundle.

Bundle Symbolic Name and Bundle Version - A name and version assigned by the developer. The
combination of Bundle Version and Bundle Symbolic Name is a globally unique identifier for a
bundle. The getSymbolicName () method returns the assigned bundle name. The Bundle getVersion ()
method returns the version. Though the pair is unique, it is possible to install the same
bundle multiple times if the org. osgi. Framework. bsnversion framework launching property is
set to managed or multiple.

Bundle State

A bundle can be in one of the following states:
• INSTALLED - The bundle has been successfully installed.
• RESOLVED - All Java classes that the bundle needs are available. This state indicates that the bundle
is either ready to be started or has stopped.
• STARTING - The bundle is being started, the BundleActivator.start method will be called, and this
method has not yet returned. When the bundle has a lazy activation policy, the bundle will remain
in the STARTING state until the bundle is activated. 
• ACTIVE - The bundle has been successfully activated and is running; its Bundle Activator start
method has been called and returned.
• STOPPING - The bundle is being stopped. The BundleActivator.stop method has been called but
the stop method has not yet returned.
• UNINSTALLED - The bundle has been uninstalled. It cannot move into another state.


When a bundle is installed, it is stored in the persistent storage of the Framework and remains there
until it is explicitly uninstalled. Whether a bundle has been started or stopped must be recorded
in the persistent storage of the Framework. A bundle that has been persistently recorded as started
must be started whenever the Framework starts until the bundle is explicitly stopped.

Installing Bundles
The BundleContext interface, which is given to the Bundle Activator of a bundle, defines the following
methods for installing a bundle:

Activation
bundle is activated by calling its Bundle Activator object, if one exists. The BundleActivator interface
defines methods that the Framework invokes when it starts and stops the bundle.

To inform the OSGi environment of the fully qualified class name serving as its Bundle Activator, a
bundle developer must declare a Bundle-Activator manifest header in the bundle's manifest file. The
Framework must instantiate a new object of this class and cast it to a BundleActivator instance. It
must then call the BundleActivator.start method to start the bundle.

The following is an example of a Bundle-Activator manifest header:
Bundle-Activator: com.acme.Activator

A class acting as a Bundle Activator must implement the BundleActivator interface, be declared
public, and have a public default constructor so an instance of it may be created with
Class.newInstance.

The BundleActivator interface defines these methods for starting and stopping a bundle:
• start(BundleContext) –
• stop(BundleContext) -

Activation Policies

The activation of a bundle can also be deferred to a later time from its start using an activation policy.
This policy is specified in the Bundle-ActivationPolicy header with the following syntax:
Bundle-ActivationPolicy ::= policy ( ';' directive )*
policy ::= 'lazy'
The only policy defined is the lazy activation policy. If no Bundle-ActivationPolicy header is specified,
the bundle will use eager activation.


Lazy Activation Policy

A lazy activation policy indicates that the bundle, once started, must not be activated until it receives
the first request to load a class. This request can originate either during normal class loading
or via the Bundle loadClass method.


Stopping Bundles
The Bundle interface defines the stop(int) method for stopping a bundle.

Deactivation

The BundleActivator interface defines a stop(BundleContext) method, which is invoked by the
Framework to stop a bundle. This method must release any resources allocated since activation.
All threads associated with the stopping bundle should be stopped immediately. The threaded code
may no longer use Framework-related objects (such as services and BundleContext objects) once the
stop method returns.
If the stopping bundle had registered any services or Framework listeners during its lifetime, then
the Framework must automatically unregister all registered services and Framework listeners when
the bundle is stopped. It is therefore unnecessary from the Framework's point of view to unregister
any services or Framework listeners in the stop method.


Updating Bundles

The Bundle interface defines two methods for updating a bundle:
• update() - This method updates a bundle.
• update(InputStream) - This method updates a bundle from the specified InputStream object.

The update process supports migration from one revision of a bundle to a newer revision of the
same bundle. The capabilities provided by the new revision must be immediately available to the
Framework. If the old bundle revision has an isInUse() bundle wiring then all capabilities provided
by the old bundle wiring must remain available for existing bundles and future resolves until the
bundle is refreshed, or the Framework is restarted. Otherwise the capabilities
provided by the old revision must be removed.

Uninstalling Bundles
The Bundle interface defines the uninstall() method for uninstalling a bundle from the Framework.
This method causes the Framework to notify other bundles that the bundle is being uninstalled, and
sets the bundle's state to UNINSTALLED. To whatever extent possible, the Framework must remove
any resources related to the bundle. This method must always uninstall the bundle from the persistent
storage of the Framework.

If the uninstalled bundle has one or more revisions with isInUse() bundle wirings then all capabilities
provided by the old in use bundle wirings must remain available for existing bundles and future
resolves until the bundle is refreshed,  or the Framework is restarted.
Otherwise the capabilities provided by the old revision must be removed.


Detecting Bundle Changes

The Bundle object provides a convenient way to detect changes in a bundle. The Framework must
keep the time that a bundle is changed by any of the life cycle operations. The getLastModified()
method will return the last time the bundle was installed, updated, or uninstalled. This last modified
time must be stored persistently.

Retrieving Manifest Headers
The Bundle interface defines two methods to return manifest header information: getHeaders() and
getHeaders(String).
• getHeaders() - Returns a Dictionary object that contains the bundle's manifest headers and values
as key/value pairs. The values returned are localized according to the default locale returned
by java.util.Locale.getDefault.

getHeaders(String) - Returns a Dictionary object that contains the bundle's manifest headers and
values as key/value pairs. The returned values are localized using the specified locale. The locale
may take the following values:
• null - The default locale returned by java.util.Locale.getDefault is used. This makes this
method identical to the getHeaders() method.
• Empty string - The dictionary will contain the raw (unlocalized) manifest headers including
any leading '%'.
• A Specific Locale - The given locale is used to localize the manifest headers.


The Bundle Context
The relationship between the Framework and its installed bundles is realized by the use of Bundle-
Context objects. A BundleContext object represents the execution context of a single bundle within
the OSGi framework, and acts as a proxy to the underlying Framework.

A BundleContext object is created by the Framework when a bundle is started. The bundle can use
this private BundleContext object for the following purposes:
--Installing new bundles into the OSGi environment.
--Interrogating other bundles installed in the OSGi environment.
--Obtaining a persistent storage area.
--Retrieving service objects of registered services.
--Registering services in the Framework service.
--Subscribing or unsubscribing to events broadcast by the Framework.

When a bundle is started, the Framework creates a BundleContext object and provides this object as
an argument to the start(BundleContext) method of the bundle's Bundle Activator. Each bundle is
provided with its own BundleContext object; these objects should not be passed between bundles,
since the BundleContext object is related to the security and resource allocation aspects of a bundle.

After the stop(BundleContext) method has returned, the BundleContext object must no longer be
used. Framework implementations must throw an exception if the BundleContext object is used after
a bundle is stopped.

The BundleContext object is only valid during the { STARTING, ACTIVE, STOPPING } states of a bundle.
However, the BundleContext object becomes invalid after stop(BundleContext) returns (if the
bundle has a Bundle Activator). The BundleContext object becomes invalid before disposing of any
remaining registered services and releasing any remaining services in use.


Persistent Storage
The Framework should provide a private persistent storage area for each installed bundle on platforms
with some form of file system support.

The BundleContext interface defines access to this storage in terms of the File class, which supports
platform-independent definitions of file and directory names.




Events
The OSGi Framework Life Cycle layer supports the following types of events:
• BundleEvent - Reports changes in the life cycle of bundles.
• FrameworkEvent - Reports that the Framework is started, start level has changed, packages have
been refreshed, or that an error has been encountered.

Listeners
A listener interface is associated with each type of event. The following list describes these listeners.

@ BundleListener and SynchronousBundleListener - Called with an event of type BundleEvent
when a bundle's life cycle information has been changed.
SynchronousBundleListener objects are called synchronously during the processing of the event
and must be called before any BundleListener object is called. 

The following events are sent by the Framework after it has moved to a different state: INSTALLED – RESOLVED -LAZY_ACTIVATION -STARTING ,STOPPING , STOP , UNINSTALLED , UNRESOLVED , UPDATE

@ FrameworkListener - Called with an event of type FrameworkEvent. 
Framework events are of type:
• ERROR - Important error that requires the immediate attention of an operator.
• INFO - General information that is of interest in special situations.
• PACKAGES_REFRESHED - The Framework has refreshed the packages.
• STARTED - The Framework has performed all initialization and is running in normal mode.
• STARTLEVEL_CHANGED - Is sent by the Framework after a new start level has been set and
processed.
• STOPPED - Sent by the Framework because of a stop operation on the system bundle.
• STOPPED_BOOTCLASSPATH_MODIFIED - Sent by the Framework because of a stop operation
on the system bundle and a boot class path extension bundle has been installed or updated.
• STOPPED_UPDATE - Sent by the Framework because of an update operation on the system
bundle. The Framework will be restarted after this event is fired.
• WARNING - A warning to the operator that is not crucial but may indicate a potential error situation.

Service layer:



Entities
• Service - An object registered with the service registry under one or more interfaces together with
properties. The service can be discovered and used by bundles.
• Service Registry - Holds the service registrations.
• Service Reference - A reference to a service. Provides access to the service's properties but not the
actual service object. The service object must be acquired through a bundle's Bundle Context.
• Service Registration - The receipt provided when a service is registered. The service registration allows
the update of the service properties and the unregistration of the service.
• Service Permission - The permission to use an interface name when registering or using a service.
• Service Scope - Indicates how service objects are obtained when requesting a service object. The
following service scopes are defined: singleton, bundle, and prototype. The default service scope is
singleton.
• Service Factory - A facility to let the registering bundle customize the service object for each using
bundle. When using a Service Factory, the service scope of the service is bundle.
• Prototype Service Factory - A facility to let the registering bundle customize the service object for
each caller. When using a Prototype Service Factory, the service scope of the service is prototype.
• Service Objects - A facility to let the using bundle obtain multiple service objects for a service with
prototype service scope.
• Service Listener - A listener to Service Events.
• Service Event - An event holding information about the registration, modification, or unregistration
of a service object.
. Filter - An object that implements a simple but powerful filter language. It can select on properties.
• Invalid Syntax Exception - The exception thrown when a filter expression contains an error.


Services

In the OSGi framework, bundles are built around a set of cooperating services available from a
shared service registry. Such an OSGi service is defined semantically by its service interface and implemented
as a service object.

The service object is owned by, and runs within, a bundle. This bundle must register the service object
with the Framework service registry so that the service's functionality is available to other bundles
under control of the Framework.

Dependencies between the bundle owning the service and the bundles using it are managed by the
Framework.

Service References
In general, registered service objects are referenced through ServiceReference objects. This avoids
creating unnecessary dynamic service dependencies between bundles when a bundle needs to know
about a service but does not require the service object itself.

A ServiceReference object can be stored and passed on to other bundles without the implications of
dependencies. A ServiceReference object encapsulates the properties and other meta-information
about the service object it represents. This meta-information can be queried by a bundle to assist in
the selection of a service that best suits its needs.

When a bundle queries the Framework service registry for services, the Framework must provide
the requesting bundle with the ServiceReference objects of the requested services, rather than with
the services themselves.
A ServiceReference object may also be obtained from a ServiceRegistration object.
A ServiceReference object is valid only as long as the service is registered. However, its properties
must remain available as long as the ServiceReference object exists.
When a bundle wishes to use the service object, it can be obtained by using the ServiceReference.


Service Interfaces
A service interface is the specification of the service's public methods.
In practice, a bundle developer creates a service object by implementing its service interface and registers
the service object with the Framework service registry. Once a bundle has registered a service
object under an interface name, the associated service can be acquired by bundles under that interface
name, and its methods can be accessed by way of its service interface. The Framework also supports
registering service objects under a class name, so references to service interface in this specification
can be interpreted to be an interface or class.
When requesting a service object from the Framework, a bundle can specify the name of the service
interface that the requested service object must implement. In the request, the bundle may also
specify a filter string to narrow the search.
Many service interfaces are defined and specified by organizations such as the OSGi Alliance. A service
interface that has been accepted as a standard can be implemented and used by any number of
bundle developers.

Registering Services
A bundle publishes a service by registering a service object with the Framework service registry. A
service object registered with the Framework is exposed to other bundles installed in the OSGi environment.
Every registered service has a unique ServiceRegistration object, and has one or more ServiceReference
objects that refer to it. These ServiceReference objects expose the registration properties of
the service, including the set of service interfaces they implement. The ServiceReference object can
then be used to acquire a service object that implements the desired service interface.
The Framework permits bundles to register and unregister service objects dynamically. Therefore,
a bundle is permitted to register service objects at any time during the STARTING, ACTIVE or STOPPING
states.


A bundle registers a service object with the Framework by calling one of the
BundleContext.registerService methods on its BundleContext object:

• registerService (String, Object, Dictionary) - For a service object registered under a single service
interface.
• registerService (String [], Object, Dictionary) - For a service object registered under multiple service
interfaces.
• registerService (Class, S, Dictionary) - For a service object registered under a single service interface
using the class object for the interface name.


The names of the service interfaces under which a bundle wants to register its service are provided
as arguments to the registerService methods. The Framework must ensure that the service object
actually is an instance of each specified service interfaces, unless the object is a Service Factory.

To perform this check, the Framework must load the Class object for each specified service interface
from either the bundle or a shared package. For each Class object, Class.isInstance must be called
and return true on the Class object with the service object as the argument.
The service object being registered may be further described by a Dictionary object, which contains
the properties of the service as a collection of key/value pairs.
The service interface names under which a service object has been successfully registered are automatically
added to the service's properties under the key objectClass. This value must be set automatically
by the Framework and any value provided by the bundle must be overridden.

If the service object is successfully registered, the Framework must return a ServiceRegistration object
to the caller. A service object can be unregistered only by the holder of its ServiceRegistration
object (see the unregister() method). Every successful service object registration must yield a unique
ServiceRegistration object even if the same service object is registered multiple times.
Using the ServiceRegistration object is the only way to reliably change the service's properties after
it has been registered (see the setProperties(Dictionary) method). Modifying a service's Dictionary
object after the service object is registered may not have any effect on the service's properties.
The process of registering a service object is subject to a permission check. The registering bundle
must have ServicePermission[<name>,REGISTER] to register the service object under all the service
interfaces specified. Otherwise, the service object must not be registered, and a SecurityException
must be thrown.

Service Properties

The service properties are intended to provide information about the service. The properties should
not be used to participate in the actual function of the service. Modifying the properties for the service
registration is a potentially expensive operation.

Properties hold information as key/value pairs. The key must be a String object and the value should
be a type recognized by Filter objects and Collection objects.
service.pid String+ SERVICE_PID The service.pid property optionally identifies
a persistent, unique identifier for
the service object.

service. vendor , service.ranking service.description

The values for these service properties must be set by the Framework;
objectClass, service.id, service. scope, service. bundleid


Service Ranking Order
When registering a service object, a bundle may optionally specify a SERVICE_RANKING service
property of type Integer. This number specifies a ranking order between services. The highest number
has the highest ranking and the lowest number (including negative numbers) has the lowest ranking. 
If no service. ranking service property is specified or its type is not Integer then a ranking of
0 must be used.

The ranking order is defined as follows:
• Sorted on descending ranking number (highest first)
• If the ranking numbers are equal, sorted on ascending service.id property (oldest first).


The ranking order is the reverse of the natural ordering of a ServiceReference object.
The purpose of the ranking order is to allow:
• Selection - When a single service must be chosen but multiple services qualify then the service
with the highest ranking must be selected.
• Ordering - When multiple services must be used in a specified order.

Persistent Identifier (PID)
The purpose of a Persistent Identifier (PID) is to identify a service across Framework restarts.
pid: = symbolic-name



Locating Services

In order to use a service object and call its methods, a bundle must first obtain a ServiceReference
object.

The BundleContext interface defines a number of methods a bundle can call to obtain ServiceReference
objects from the Framework:
getServiceReference(String), getServiceReference(Class) -
+ These methods returns a ServiceReference  object to a service object that implements, and was registered under, the name of the specified service interface.
	if multiple such service objects exist, a ServiceReference object to the service object with the highest SERVICE_RANKING is returned. 
	If there is a tie in ranking, a ServiceReference object to the service object with the lowest SERVICE_ID (the service object that was registered first) is returned. 
	If no matching service objects are registered, then null must be returned.


getServiceReferences(String,String), getServiceReferences(Class,String) - These methods returns
an array or collection, respectively, of ServiceReference objects for service objects that:
• Implement and were registered under the specified service interface.
• Satisfy the search filter specified.

Getting Service Properties

To allow for interrogation of service properties, the ServiceReference interface defines these two
methods:
• getPropertyKeys() - Returns an array of the property keys that are available.
• getProperty(String) - Returns the value of a property.
Both of these methods must continue to provide information about the referenced service object,
even after it has been unregistered from the Framework. This requirement can be useful when a
ServiceReference object is stored with the Log Service.


A service in OSGi is defined by a standard Java class or an interface. The first step to define an OSGi service is to define the class or interface for which you want to provide a service. This is called the service interface.

As a second step you write the implementation class for the service interface.
You can register services implementations and consume existing services via the OSGi runtime. OSGi provides a central service registry for this purpose.
The OSGi declarative services (DS) functionality allows you to define and consume services via metadata (XML) without any dependency in your source code to the OSGi framework. Alternatively, you can also use annotations in your source code to generated this meta-data at build time automatically.
OSGi service low-level API
Declarative Services provide high level abstractions for handling services.
Blue print, DS, Service tracker, Service listener
BundleContext
 Access to the service registry is performed via the BundleContext class.
A bundle can define a Bundle-Activator (Activator) in its declaration. This class must implement the BundleActivator interface.
If defined, OSGi injects the BundleContext into the start() and stop() methods of the implementing Activator class.
public class Activator implements BundleActivator {

        public void start(BundleContext context) throws Exception {
                System.out.println("Starting bundle");
                // do something with the context, e.g.
                // register services
        }

        public void stop(BundleContext context) throws Exception {
                System.out.println("Stopping bundle");
                // do something with the context, e.g.
                // unregister service
        }


If you do not have an Activator, you can use the FrameworkUtil class from the OSGi framework which allows you to retrieve the BundleContext for a class.


BundleContext bundleContext =
                                FrameworkUtil.
                                getBundle(this.getClass()).
                                getBundleContext();



Registering services via API
	A bundle can also register itself for the events ( ServiceEvents ) of the BundleContext. These are, for example, triggered if a new bundle is installed or de-installed or if a new service is registered.	
To publish a service, in your bundle use:
public class Activator implements BundleActivator {
        // ...
        public void start(BundleContext context) throws Exception {
                context.
                  registerService(
                     IMyService.class.getName(),
                     new ServiceImpl(), null
                     );

      }     // ...}
WHERE registerService(String class , Object service , Dictionary <String,?> properties )
properties - The properties for this service. The keys in the properties object must all be String objects.

Accessing a service via API
A bundle can acquire a service via the BundleContext class. The following example demonstrates that.
ServiceReference<?> serviceReference = context. getServiceReference (IMyService.class. getName ());


IMyService service = (IMyService) context.
        getService(serviceReference);
Low-level API vs OSGi declarative services
OSGi services can be dynamically started and stopped. If you work with the OSGI low-level API you have to handle this dynamic in your code. This make the source code unnecessary complex. If you do not handle that correctly your service consumer can keep a reference to the service and the service cannot be removed via the OSGi framework.
To handle the dynamics automatically declarative services were developed. Prefer therefore the usage of OSGi declarative services over the low-level API.
Annotation Type	Description
Activate
Identify the annotated method as the activate method of a Service Component.
Component
Identify the annotated class as a Service Component.
Deactivate
Identify the annotated method as the deactivate method of a Service Component.
Modified
Identify the annotated method as the modified method of a Service Component.
Reference
Identify the annotated member as a reference of a Service Component.

Apache Felix Annotation:
@component
The @Component annotation is the only required annotation. If this annotation is not declared for a Java class, the class is not declared as a component.

ds 
Defaut: true 
SCR Descriptor: -- 
Metatype Descriptor: -- 
Whether Declarative Services descriptor is generated or not. If this parameter set to true, the Declarative Services descriptor is generated in the service descriptor file for this component. Otherwise no Declarative Services descriptor is generated for this component.

metatype 
Defaut: false 
SCR Descriptor: -- 
Metatype Descriptor: -- 
Whether Metatype Service data is generated or not. If this parameter is set to true Metatype Service data is generated in the metatype.xml file for this component. Otherwise no Metatype Service data is generated for this component.

immediate 
Defaut: -- 
SCR Descriptor: component.immediate 
Metatype Descriptor: -- 
Whether the component is immediately activated

@Service
The @Service annotation defines whether and which service interfaces are provided by the component. This is a class annotation.
@Property
The @Property annotation defines properties which are made available to the component through the ComponentContext.getProperties() method. Supported attributes: name , value

name 
Defaut: The name of constant
SCR Descriptor: property.name
value
SCR Descriptor: property.value 

Whats the difference between @component, @service-annotations?
A service can be published without a @Component annotation, but you have to do it programmatically. If you use the annotation then you benefit from the automatic metadata generation in the build tool, and also from the Declarative Services runtime framework. This simplifies a lot of things. If you want to do it with low-level code you have to write an implementation of BundleActivator, declare that with the Bundle-Activator manifest header, call context.registerService etc. Bottom line: just use the @Component annotation!

@service
A component that is not published as a service cannot be accessed from outside the bundle. If you want it to be accessible, then it has to be a service. In case you think this is useless, consider a component that creates an HTTP server. It opens port 80 and responds to network requests from the outside world. So it does something useful even though it's not a service and not accessible from other bundles. This kind of component is like a bridge between your application and the outside world; whereas services are a bridge between one part of your application and another part.

Official OSGi Declarative Services Annotations in AEM(6.2/6.3):
By now you're pretty comfortable writing OSGi components and services using the Felix SCR annotations. 
However, with AEM 6.2 and greater comes support for the official OSGi Declarative Services annotations. 

Declarative Services
Remember that declarative services is a compile time process. In order for the DS annotations to be effective, they must be handled during the build process. 
The Apache Felix SCR annotations require the maven-scr-plugin while the OSGi DS annotations require the maven-bundle-plugin version 3.2.0 or greater.
With the maven-scr-plugin you may be used to finding the DS output under /target/classes/OSGI-INF and/target/classes/OSGI-INF/metatype. 
With the maven-bundle-plugin you will have to unzip the compiled artifact (the jar file) to find the DS output in its /OSG-INF directory.

Java Packages
Rather than using org.apache.felix.scr.annotations.*,you'll use org.osgi.service.component.annotations.* andorg.osgi.service.metatype.annotations.*.
Dependencies
Rather than using the maven-scr-plugin, you need the maven-bundle-plugin version 3.2.0 or greater.
You also need the artifacts 
org.osgi.service.metatype.annotations and org.osgi.service.component.annotations(currently version 1.3.0) rather than org.osgi.core and org.osgi.compendium. See the provided sample project's POM file for more specifics.
Once you update your project's dependencies, you'll find that your IDE will inform you that theorg.apache.felix.scr.annotations.* annotations are deprecated.

Service Configuration
The most noticeable difference between Felix SCR annotations and OSGi DS annotations is where service reference properties are defined.
 With Felix annotations everything is in the Properties and Property annotations either at the head of the class file or inline.
OSGi DS annotations move the service reference properties to it's own class.
The annotations will move to their own class which declutters the component or service. For components with a large amount of options, you might find that you like an independent class, while a component with only one or two properties may be fine as a subclass.
You'll also immediately notice the Activate method becomes much cleaner as the need to useorg.apache.sling.commons.osgi.PropertiesUtil to provide default values has been replaced.
@Component(
	    immediate = true,
	    service = Servlet.class,
	    property = {
	        "sling.servlet.resourceTypes=project/components/component"
	    }
	)
	@Designate(ocd = SampleOsgiServlet.Configuration.class)
	public class SampleOsgiServlet extends SlingSafeMethodsServlet {
	
	    @Activate
	    protected void Activate(Configuration config) {
	        boolean enabled = config.servletname_enabled();
	    }
	
	    @ObjectClassDefinition(name="OSGi Annotation Demo Servlet")
	    public @interface Configuration {
	        @AttributeDefinition(
	            name = "Enable",
	            description = "Enable the servlet"
	        )
	        boolean servletname_enabled() default false;
	    }
	}


Service Reference Properties
The AttributeDefinition method naming convention will immediately seem out of place. It's very Pythonic looking with its use of underscores. You don't need to write your method names that way, but the reason for doing so is that the underscores are converted to dots for display in the Felix console and your OSGi configs. For example, you're probably familiar with seeing properties defined as something like resource.resolver.searchpath. To achieve this in your configuration class, your method would be named resource_resolver_searchpath.
OSGI DS in details,
Intro-
Component-oriented development is a very common and powerful software engineering style where you assemble your application out of components. A component might offer a service, e.g. a scheduler service. Other components can use this scheduler service.

Or a little bit more formal: a component is a piece of software managed by a (component) container. In Java this means this is an instance, created and managed by a container. Therefore it is not the task of the developer to create or configure these instances. This is the task of the container. If the component uses other services, it is also the task of the container to pass these services to the component. Therefore a service is a component which provides one or more services. In Java this means a service implements one or more interfaces where an interface represents the service description or contract.

OSGi Components with Declarative Services—

Components
If you want to write a component which is managed by the container, just add the @Component annotation to your class:
	package com.mycompany.cool.project.impl;
import org.osgi.service.component.annotations.Component;
 @Component
public class MyFirstComponent { }

Build your project, deploy your bundle into an OSGi framework which has SCR running (I recommend the implementation from Apache Felix, version 2.0 or higher) – and your component will be instantiated by the container on bundle start. 

Lifecycle


As noted above, the container manages the lifecycle of the component, its instantiation and removal. In order to make this work, the component class needs the default zero argument constructor. However, if the component wants to do something during the creation or the deletion phase, it can implement an activate and/or deactivate method and mark it with the according annotation: 

package com.mycompany.cool.project.impl;
 
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Deactivate;
  
@Component
public class MyFirstComponent {

    @Activate
    protected void activate() {
        // do something
    }
  
    @Deactivate
    protected void deactivate() {
        // do something
    }
}
 It is good practice to name these methods activate and deactivate – however you could pick any other name if you want. The methods have to be protected with no return value. 


Using Services

A component can use other services by using the @Reference annotation. 

Component Configurations
If you want to make your component configurable, the best way of doing this is to leverage the OSGi Configuration Admin  
Configuration Admin is a service persisting configurations – these configurations are dictionaries where the key is a string and the value can be one of the simple Java types or an array or collection of such a type. This is usually sufficient for most components.
Configuration Admin nicely abstracts managing the configuration from your component. As a component developer you don’t need to know where the actual configuration is stored and how it ends up there. Without a component container, you would ask the configuration admin for “your” configuration.
As mentioned Configuration Admin stores configurations as dictionaries. Whereas the names are of type String, the value can be any type. 
The way to describe a configuration is by defining a so called Component Property Type: an annotation describing all configuration properties.
Let’s assume our component has three configuration properties, then the following annotation would do:
1
2
3
4
5
6
7
8	public @interface MyComponentConfig {
     
    String welcome_message() default "Hello World!";
 
    int welcome_count() default 3;
 
    boolean output_goodbye() default true;
}
Defining an annotation (@interface) instead of a simple interface has the advantage that we can directly specify default values for each property. 
If no value for a property is stored in configuration admin, the default value is used.

 how to use this:

    @Activate
    protected void activate( MyComponentConfig config ){}



When the above component is activated, SCR tries to get a configuration from the Configuration admin and converts it into the used annotation type. Therefore the passed in object returns the value in the correct type for each property. As mentioned if there is no value, the default is returned. This makes handling of configurations very simple and avoids all the usual boilerplate code.

Services
Offering a service  though @Component-

1.	Always explicitly list the service interfaces the component implements:
@Component(service = EventHandler.class}
2.	As a default, always set the service attribute of the component annotations to the empty array. This prevents the automatic registration:
@Component(service = {})

Lifecycle of a Service

A component which does not provide a service is active for as long as it is satisfied (all referenced services are available and some other conditions we get to later). In contrast, services are instantiated lazy or on demand by DS. This means, as long as no one is using your service, your service is never created nor activated! In most cases this is fine. But there is a catch with this approach one should be aware of: if someone else is starting to use your service, it gets created and activated. As soon as your service is not used anymore, it gets deactivated and destroyed.

The OSGi spec does not mandate this behavior. The implementation of Declarative Service is free to keep your service around for some time until it is disposed. By default the current Apache Felix implementation immediately disposes such components. However it is possible to configure such a detailed disposal of components. But this leaves you with the problem of configuring this correctly which might not be that easy.
On the other hand, frequent creation and disposal of an “expensive” service might create a performance bottleneck. For example if this happens being triggered by an event, a request and/or if your service is doing some computation in the activate method.
In many cases, your actual service is combining a “component” and a “service” part. While the “component” part is the expensive one and should only be done once, the “service” part is lightweight and might simply use the component part. In such cases you might think about splitting your implementation accordingly.
Or you can either think about holding the service by someone else and therefore keep a reference to it around (which in general sounds hacky though there are valid use cases). Or you can use the immediate flag on the @Component:
@Component(service=EventHandler.class, immediate=true)
With immediate set to true, the component is activated as soon as possible and kept as long as possible. Obviously, this increases things like startup time, memory consumption etc. So it should really be used with care and maybe only after problems are encountered in this area.

 

Metatype Generation
 

The metatype specification (OSGi Compendium Chapter 105) provides a way to describe the configuration for a component. In general an OSGi configuration is just a dictionary with arbitrary key-value pairs. By defining a metatype description for the configuration, the developer of a component can define which properties together with their type the component expects. Such a metatype information can be used at runtime to generate forms to edit/create the configuration of a component. For example the Apache Felix Web Console does exactly that. 

if a component is configurable it contains already a component annotation for its properties:
 

public @interface MyComponentConfig {
      
    String welcome_message() default "Hello World!";
  
    int welcome_count() default 3;
  
    boolean output_goodbye() default true;
}
 

The above annotation already defines all possible properties together with their default values. Therefore the only thing you have to do is provide some human readable information like a label and a description for both, the configuration as a whole and each property. This can be done with some annotations from the metatype specification: 

import org.osgi.service.metatype.annotations.AttributeDefinition;
import org.osgi.service.metatype.annotations.ObjectClassDefinition;
 
@ObjectClassDefinition(name = "Hello World Configuration",
        description = "The configuration for the hello world component.")
public @interface MyComponentConfig {
      
    @AttributeDefinition(name="Welcome Message", description="This message is displayed on startup of the component.")
    String welcome_message() default "Hello World!";
  
    @AttributeDefinition(name="Welcome Message Count", description="This is the number of times, the welcome message will be displayed. " +
                              "If less than one, no message will be displayed.")
    int welcome_count() default 3;
  
    @AttributeDefinition(name="Output Goodbye", description="Set this if the component should output a goodbye message.")
    boolean output_goodbye() default true;
}
 The @ObjectClassDefinition annotation is used on the whole configuration annotation and for each attribute, the @AttributeDefinition annotation is used. With these annotations a metatype description for the MyComponentConfig class will be generated. However, we want to bind this configuration to our component which is a different class. Therefore you have to specify the @Designate annotation on your component class: 


import org.osgi.service.metatype.annotations.Designate;
 
@Component
@Designate( ocd = MyComponentConfig.class )
public class MyFirstComponent {
  
    @Activate
    protected void activate( MyComponentConfig config ) {
    ...
}

Configuring OSGi

You can manage the configuration settings for OSGI bundles by either:
•	using the Adobe CQ Web console
•	configuring content-nodes (sling:OsgiConfig) in the repository


Adobe CQ Web console

system/console/configMgr SELECT BUNDLE EDIT CONFIGURATION VALUE save

content-nodes (sling:osgiConfig) in the repository
•	This requires manual configuration using CRXDE Lite.
•	Due to the naming conventions of the sling:OsgiConfig nodes, you can tie the configuration to a specific run mode. You can even save configurations for more than one run mode in the same repository.
•	Any appropriate configurations are applied immediately (dependent on the run mode).
Locating your changes to a Configuration
Configuration changes made in the Web Console are persisted in the repository under:
    /apps
The configuration node will be shown 
/apps/system/config/


Creating the Configuration in the Repository
•  Use CRXDE Lite to navigate to:
    /apps/<yourProject>
•  If not already existing, create the config folder (sling:Folder):
•	config - applicable to all run modes
•	config.<run-mode> - specific to a particular run mode
Under this folder create a node:
•	Type: sling:OsgiConfig
•	Name: the persistent identity (PID);
for example for AEM WCM Version Manager use com.day.cq.wcm.core.impl.VersionManagerImpl

For each parameter that you want to configure, create a property on this node
 


Save all changes.

Resolution Order at Startup
The following order of precedence is used:
1.	Repository nodes under /apps/*/config....either with type sling:OsgiConfig or property files (CHECK)
2.	Repository nodes with type sling:OsgiConfig under /libs/*/config.... (ootb defns)
3.	Any .config files from <cq-installation-dir>/crx-quickstart/launchpad/config/.... on the local file system.

Resolution Order at Runtime
Configuration changes made while the system is running trigger a reload with the modified configuration.
Then the following order of precedence applies:
1.	Modifying a configuration in the Web console will take immediate effect as it takes precedence at runtime.
2.	Modifying a configuration in /apps will take immediate effect.
3.	Modifying a configuration in /libs will take immediate effect, unless it is masked by a configuration in /apps.
Resolution of multiple Run Modes
For run mode specific configurations, multiple run modes can be combined. For example, you can create configuration folders in the following style:
/apps/*/config.<runmode1>.<runmode2>/
Configurations in such folders will be applied if all run modes match a run mode defined at startup. 
For example, if an instance was started with the run modes author,dev,emea, configuration nodes in /apps/*/config.emea, /apps/*/config.author.dev/ and /apps/*/config.author.emea.dev/ will be applied, while configuration nodes in /apps/*/config.author.asean/ and /config/author.dev.emea.noldap/ will not be applied.
If multiple configurations for the same PID are applicable, the configuration with the highest number of matching run modes is applied.
For example, if an instance was started with the run modes author,dev,emea, and both /apps/*/config.author/ and /apps/*/config.emea.author/ define a configuration for
com.day.cq.wcm.core.impl.VersionManagerImpl, the configuration in/apps/*/config.emea.author/ will be applied.
This rule's granularity is at a PID level.
You cannot define some properties for the same PID in/apps/*/config.author/ and more specific ones in
/apps/*/config.emea.author/ for the same PID. 
The configuration with the highest number of matching run modes will be effective for the entier PID.

Configuration Persistence
If you change a configuration through the Web console, it is (usually) written into the repository at:
/apps/{somewhere} 
•	By default {somewhere} is system/config so the configuration is written to
/apps/system/config
•	However, if you are editing a configuration which initially came from elsewhere in the repository: for example:
/libs/foo/config/someconfig
Then the updated configuration is written under the original location; for example:
/apps/foo/config/someconfig


Settings that are changed by admin are saved in *.config files under:
/crx-quickstart/launchpad/config
•	This is the private data area of the OSGi configuration admin and holds all configuration details specified by admin, regardless how they entered the system.
•	This is an implementation detail and you must never edit this directory directly.
•	However, it is useful to know the location of these configuration files so that copies can be taken for backup and/or multiple installation:
o	Apache Felix OSGi Management Console
../crx/org/apache/felix/webconsole/internal/servlet/OsgiManager.config
o	CRX Sling Client Repository
../com/day/crx/sling/client/impl/CRXSlingClientRepository/<pid-nr>.config

service.ranking	Integer	0	Any Integer value	Indication of where to place the filter in the filter chain. The higher the number the earlier in the filter chain. T

JCR (JAVA CONTENT REPOSITORY)
A JCR is a type of object database tailored to storing, searching, and retrieving hierarchical data. The JCR API grew out of the needs of content management systems, which require storing documents and other binary objects with associated metadata; however, the API is applicable to many additional types of applications. In addition to object storage, the JCR provides: APIs for versioning of data; transactions; observation of changes in data; and import or export of data to XML in a standard way.
The data in a JCR consists of a tree of nodes with associated properties. Data is stored in the properties, which may hold simple values such as numbers and strings or binary data of arbitrary length. Nodes may optionally have one or more types associated with them which dictate the kinds of properties, number and type of child nodes, and certain behavioral characteristics of the nodes. Nodes may point to other nodes via a special reference type property. In this way nodes in a JCR offer both referential integrity and object-oriented concept of inheritance. Additional node types include the referenceable node type which allows the user to reference said node through use of a universally unique identifier. Another popular type is the versionable type. This makes the repository track a document's history and store copies of each version of the document
Jackrabbit is a complete, and fully compliant implementation of the Content Repository API for Java Technology (JCR) and therefore its primary API is defined by JCR.
JSR 170  and JSR 283 , JSR (java specification request)
importance of using JCR over other databases/repositories ???
JSR-000170 Content Repository for Java technology API 1.0 (JCR 1.0)
JSR-000283 Content Repository for Java technology API 2.0 (JCR 2.0)
The Apache Jackrabbit™ content repository is a fully conforming implementation of the Content Repository for Java Technology API (JCR, specified in JSR 170 and JSR 283).

Jackrabbit is a complete implementation of the JCR API.
Apache Jackrabbit Oak is an effort to implement a scalable and performant hierarchical content repository for use as the foundation of modern world-class web sites and other demanding content applications.
It is the successor to Jackrabbit 2  and is used by AEM 6.0 as the default backend for its content repository, CRX.
CQ/AEM versions       repository 
5.4  to 5.6.1       CRX 2.2 (Adobe , JSR-283-compliant) Apchejackrabbit 2.0
AEM 6.0               CRX 2.3  Apache Jackrabbit Oak 1.0
AEM 6.1            Apache Jackrabbit Oak 1.2. 
AEM 6.2        Apache Jackrabbit Oak 1.4.1.
AEM 6.3   Apache Jackrabbit Oak  1.6.3.
Persistent Workspaces
A JCR repository is composed of one or more persistent workspaces, each consisting of a directed acyclic graph of items where the edges represent the parent-child relation.
Each persistent workspace is identified by a unique name within the repository, which is a string.

Items
An item is either a node or a property. A node can have zero or more child items. A property cannot have child items but can hold zero or more values.
The nodes of a workspace form the structure of the stored data while the actual content is stored in the values of the properties.
Each workspace contains at least one item, the root node. The root node is the only item in the workspace without a parent node; all other items have at least one parent.


Names
The name of the root node of a workspace is always ““ (the empty string). Every other item in a workspace has a name, which must be a JCR name
Paths
The location of an item in the workspace graph can be described by the path from the root node to that item. The path consists of the name (and index in cases of same-name siblings) of each interceding node in order from root to target item, much like a file system path. Relative paths can also be used to describe the location of one item with respect to anothe
Sessions
A user connects to a repository by passing a set of credentials and the name of the workspace that the user wishes to access. The repository returns a session which binds the user to the requested persistent workspace with a level of authorization determined by that user's credentials. A session is always bound to exactly one persistent workspace, though a single persistent workspace may be bound to multiple sessions.
Simple and Full Versioning 
Under simple versioning, each new version is always added as the unique direct successor of the previous version, thus maintaining a linear series of versions. 
Under full versioning, a new version may be added as the direct successor of a version that already has another direct successor, thus producing a branch. A new version may also be added as the direct successor of more than one existing version, thus producing a merge.
Mixin Node
Mixin node types are used to add additional properties or child nodes to a given node instance, typically in order to expose some aspect of a specialized repository feature
OAK
Oak implements the JSR-283 (JCR 2.0) spec. Its principal design objectives are:
•	Better support for big repositories
•	Multiple distributed cluster nodes for high availability
•	Better performance
•	Support for many child nodes and Access Control Levels
 


Storage
The purpose of the Storage layer is to:
•	Implement a tree model
•	Make storage pluggable
•	Provide a clustering mechanism
Oak Core
The Oak Core adds several layers to the storage layer:
•	Access Level Controls
•	Search and Indexing
•	Observation
Oak JCR
The main objective of the Oak JCR is to transform JCR semantics into tree operations. It is also responsible for:
•	Implementing the JCR API
•	Containing commit hooks that implement JCR constraints
Storage overview
The Oak storage layer provides an abstraction layer for the actual storage of the content.
Tar Storage
The Tar storage uses tar files. It stores the content as various types of records within larger segments. Journals are used to track the latest state of the repository.
There are several key design principles it was build around:
•	Immutable Segments
The content is stored in segments that can be up to 256KiB in size. They are immutable, which makes it easy to cache frequently accessed segments and reduce system errors that may corrupt the repository.  
Each segment is identified by a unique identifier (UUID) and contains a continuous subset of the content tree. In addition, segments can reference other content. Each segment keeps a list of UUIDs of other referenced segments.
•	Locality
Related records like a node and its immediate children are usually stored in the same segment. This makes searching the repository very fast and avoids most cache misses for typical clients that access more than one related node per session.
•	Compactness
The formatting of records is optimized for size to reduce IO costs and to fit as much content in caches as possible.

Apache Sling 
•	REST based web framework
•	Content-driven, using a JCR content repository
•	Powered by OSGi
•	Scripting inside, multiple languages (JSP, server-side javascript, Scala, etc.)
•	Apache Open Source project
•	Apache Sling is a web framework that uses a Java Content Repository, such as Apache Jackrabbit, to store and manage content.
•	Sling applications use either scripts or Java servlets, selected based on simple name conventions, to process HTTP requests in a RESTful way.
•	The embedded Apache Felix OSGi framework and console provide a dynamic runtime environment, where code and content bundles can be loaded, unloaded and reconfigured at runtime.
•	As the first web framework dedicated to JSR-170 Java Content Repositories, Sling makes it very simple to implement simple applications, while providing an enterprise-level framework for more complex applications. 
Sling:
•	is based on REST principles to provide easy development of contet-oriented applications.
•	is embedded within CQ5.
•	is used to process HTTP rendering and data-storage requests which assemble, render and send the content to a client (i.e. the new delivery).
•	maps Content objects to Components (which render them and process incoming data).
•	comes with both server-side and AJAX scripting support.
•	can be used with a range of scripting languages, including JSP, ESP and Ruby.
•	started as an internal project of Day Management AG .
•	has been contributed to the Apache Software Foundation.
REST framework
REST (REpresentational State Transfer) is an architectural style, and an approach to communications that is often used in the development of Web services.
The REST architectural style describes six architectural constraints:
1.	 Uniform Interface 
The uniform interface constraint defines the interface between clients and servers. It simplifies and decouples the architecture, which enables each part to evolve independently. The four guiding principles of the uniform interface are:
Resource-Based
Individual resources are identified in requests using URIs as resource identifiers. The resources themselves are conceptually separate from the representations that are returned to the client. 
For example, the server does not send its database, but rather, some HTML, XML or JSON that represents some database records expressed, for instance, in Finnish and encoded in UTF-8, depending on the details of the request and the server implementation.
Manipulation of Resources Through Representations
When a client holds a representation of a resource, including any metadata attached, it has enough information to modify or delete the resource on the server, provided it has permission to do so.
Self-descriptive Messages
Each message includes enough information to describe how to process the message. For example, which parser to invoke may be specified by an Internet media type (previously known as a MIME type). Responses also explicitly indicate their cache-ability.
Hypermedia as the Engine of Application State (HATEOAS)
Clients deliver state via body contents, query-string parameters, request headers and the requested URI (the resource name). Services deliver state to clients via body content, response codes, and response headers. This is technically referred-to as hypermedia (or hyperlinks within hypertext).
Aside from the description above, HATEOS also means that, where necessary, links are contained in the returned body (or headers) to supply the URI for retrieval of the object itself or related objects. We’ll talk about this in more detail later.
The uniform interface that any REST services must provide is fundamental to its design
2.	Stateless 
As REST is an acronym for REpresentational State Transfer, statelessness is key. Essentially, it means that the necessary state to handle the request is contained within the request itself, whether as part of the URI, query-string parameters, body, or headers.
The URI uniquely identifies the “resource and the body “contains the state (or state change) of that resource. Then after the server does it’s processing, the appropriate state, or the piece(s) of state that matter, are communicated back to the client via headers, status and response body.
Most of us who have been in the industry for a while are accustomed to programming within a container which provides us with the concept of “session” which maintains state across multiple HTTP requests.
 In REST, the client must include all information for the server to fulfill the request, resending state as necessary if that state must span multiple requests. 
Statelessness enables greater scalability since the server does not have to maintain, update or communicate that session state. Additionally, load balancers don’t have to worry about session affinity for stateless systems.
So, what’s the difference between state and a resource? 
State, or application state, is that which the server cares about to fulfill a request—data necessary for the current session or request. 
A resource, or resource state, is the data that defines the resource representation—the data stored in the database, for instance. Consider application state to be data that could vary by client, and per request.
Resource state, on the other hand, is constant across every client who requests it.
Ever had back-button issues with a web application where it went AWOL at a certain point because it expected you to do things in a certain order? That’s because it violated the statelessness principle. There are cases that don’t honor the statelessness principle, such as three-legged OAuth, API call rate limiting, etc. However, make every effort to ensure that application state doesn’t span multiple requests of your service(s).
3.	Cacheable 
As on the World Wide Web, clients can cache responses. Responses must therefore, implicitly or explicitly, define themselves as cacheable, or not, to prevent clients reusing stale or inappropriate data in response to further requests. 
Well-managed caching partially or completely eliminates some client–server interactions, further improving scalability and performance.
4.	Client-Server 
 The uniform interface separates clients from servers. This separation of concerns means that, for example, clients are not concerned with data storage, which remains internal to each server, so that the portability of client code is improved. Servers are not concerned with the user interface or user state, so that servers can be simpler and more scalable. Servers and clients may also be replaced and developed independently, as long as the interface is not altered.
5.	Layered System 
A client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary along the way. Intermediary servers may improve system scalability by enabling load-balancing and by providing shared caches. Layers may also enforce security policies.
6.	Code on Demand (optional) Servers are able to temporarily extend or customize the functionality of a client by transferring logic to it that it can execute. Examples of this may include compiled components such as Java applets and client-side scripts such as JavaScript.Complying with these constraints, and thus conforming to the REST architectural style, will enable any kind of distributed hypermedia system to have desirable emergent properties, such as performance, scalability, simplicity, modifiability, visibility, portability and reliabilitY. NOTE: The only optional constraint of REST architecture is code on demand. If a service violates any other constraint, it cannot strictly be referred to as RESTful.

Sling URL resolution

Locating the script
When the appropriate resource (content node) is located, the sling resource type is extracted. This is a path, which locates the script to be used for rendering the content.
The path specified by the sling:resourceType can be either:
•	absolute
•	relative, to a configuration parameter

Relative paths are recommended by Adobe as they increase portability.
All Sling scripts are stored in subfolders of either /apps or /libs, which will be searched in this order

A few other points to note are:
•	when the Method (GET, POST) is required, it will be specified in uppercase as according to the HTTP specification e.g. jobs.POST.esp (see below)
•	various script engines are supported:
o	.esp, .ecma: ECMAScript (JavaScript) Pages (server-side execution)
o	.jsp: Java Server Pages (server-side execution)
o	.java: Java Servlet Compiler (server-side execution)
o	.jst: JavaScript templates (client-side execution)

URL decomposition
During the Resource Resolution step, the client request URI (as being returned by HttpServletRequest.getRequestURI()) is decomposed into the following parts (in exactly this order):
1.	Resource Path - For existing resources the resource path is the longest match (also considering its mappings) pointing to a resource where the next character is either a dot (.) or it is the full request URI. Otherwise (for a path not matching any existing resource) the resource path ends at the first dot (.) in the request url. The exact logic for retrieving the resource path is implemented at ResourceResolver.resolve(HttpServletRequest,String). It is impossible to tell from just looking at the request URI where the resource path part ends. You have to know the underlying resource structure to know how a URL is decomposed. You cannot safely assume that the resource path will always end at the first dot!.
2.	Selectors - If the first character in the request URL after the resource path is a dot (.), the string after the dot up to but not including the last dot before the next slash character or the end of the request URL comprises the selectors. If the resource path spans the complete request URL no selectors exist. If only one dot follows the resource path before the end of the request URL or the next slash, also no selectors exist.
3.	Extension - The string after the last dot after the resource path in the request URL but before the end of the request URL or the next slash after the resource path in the request URL is the extension. 
4.	Suffix - If the request URL contains a slash character after the resource path and optional selectors and extension, the path starting with the slash up to the end of the request URL is the suffix path. Otherwise, the suffix path is empty. Note, that after the resource path at least a dot must be in the URL to let Sling detect the suffix.
Those decomposed parts can be accessed through the RequestPathInfo object, which is retrieved via SlingHttpServletRequest.getPathInfo().

URL Decomposition 
http:// www.mywebsite.com /products/product1 .print.a4. html / a/b ? x=12

protocol: http://
host: www.mywebsite.com 
content PATH:  products/product1
selector(s): .print.a4 
extension: .html 
suffix: a/b 
param: x=12

Sling Resource Resolution – Mapping URL to Respective JCR Node :

Rule 1. The mapping uses the content path extracted from the request to locate the resource
http:/www.mywebsite.com 	/content 	yes 	
Prefix the URI paths of the requests sent to this domain with the string /content

sling:match string http:/www.mywebsite.com
Sling:internalredirect string /content

SRR 1: content path extracted after the url decomposition.
SRR 2: mapping append the /content string to the content path. This way AEM exposes its internal directory to the request internally.
SRR 3.  The repository is searched for the requested resource (content node):

           •first Sling checks whether a node exists at the location specified in the request; e.g.                
           /content/products/product1.html
           • if no node is found, the extension is dropped and the search repeated; e.g.     
          /content/products/product1
          • if no node is found then Sling will return the http code 404 (Not Found).
SRR 4. jcr: content of product1 page contains property sling: ResourceType. 
           sling:ResourceType String mywebsite/components/mycomponents
           sling needs to check for myComponent under /apps folder. 


SRR 5: sling Analyse selectors and extension
           Sling append the selectors and extension name after the component name.
            Eg: mycomponent.print.a4.html
           If it found this component then it render it else it drops the extension and search again. 

When we create a component, then aem creates a default rendering script by .jsp extension i.e myComponent.jsp

So, If the component contains .html and .jsp files , then the first preference goes to jsp.
mycomponent.print.a4.html.jsp (Selector1+Selector2 +Extension)
mycomponent.print.html.jsp	(Selector1 +Extension)
mycomponent.print.a4.jsp	(selector1 +)
mycomponent.print.jsp
mycomponent.html.jsp
html.jsp
mycomponent.jsp
mycomponent.html
GET.jsp

Case: mycomponent.jsp
if we double click our page http://localhost:4502/cf#/content/ products/product1.html then by default myComponent.jsp script will be called because here .html is an extension not selector 

while resolving the script we see for extension in URL(HTML), in crxde we compare it with node name(myComponent) We can ignore the last part .jsp from node name. 
Its only relevance is .jsp gets priority over .html(sightly) file. 

priority of resolution in Descending order (Highest to lowest):- 
1.	Selector +Extension .jsp –> mycomponent.print.a4.html
2.	Selector.jsp –> test.jsp 
3.	Extension.jsp –>html.jsp 
4.	Node_Name.jsp –> myComponent.jsp 
5.	method name.jsp (Based on type of request we make Either GET or POST) –> GET.jsp or POST.jsp

                  -If no match is found then it will look for sling:resourceSuperType if available on the 
                  component, then it goes to parent component and again run above 5 rules for script resolution.
The path with reference to root directory is called absolute. The path with reference to current directory is called relative.

If you have mentioned a path like /apps/your_project_name/path/to/resource, Sling will resolve to this path directly, 
but if you have mentioned a path like your_project/path/to/resource then sling will first look into apps directory and if resource is not resolved then it checks in libs directory.



Resource/ResourceResolver/ResourceResolverFactory
Best practice
1st rule: Session leaks = memory leaks
2nd pattern: Ownership: You open it (session) — you close it. 
3rd rule: Prefer the ResourceResolver over the JCR Session.
4th rule: Do not share nodes, resources and pages between threads and requests.
If you want to run a session with a less privileged user than the admin, you should use the impersonation feature of JCR. Do not hardcode any user password in your code. This code fragment shows how you can use impersonation to creat a session with a different user than admin, but without hardcoding the password of that user

1. The ResourceResolverFactory defines the service API to get and create ResourceResolvers.
public interface ResourceResolverFactory

	method summary
	getAdministrativeResourceResolver(Map<String,Object> authenticationInfo)

          Deprecated. as of 2.4 (bundle version 2.5.0) because of inherent security issues. Services requiring specific permissions should use the getServiceResourceResolver(Map) instead.

NOTE: This method is intended for use by infrastructure bundles to access the repository and provide general services. This method MUST not be used to handle client requests of whatever kinds. To handle client requests a regular authenticated resource resolver retrieved through getResourceResolver(Map) must be used.

Services running in the Sling system should use the getServiceResourceResolver(Map) method instead.

If the authenticationInfo map is null the ResourceResolver returned will generally not be authenticated and only provide minimal privileges, if any at all. 



	getResourceResolver(Map<String,Object> authenticationInfo)
          Returns a new ResourceResolver instance with further configuration taken from the given authenticationInfo map.
	getServiceResourceResolver(Map<String,Object> authenticationInfo)
 Returns a new ResourceResolver instance with privileges assigned to the service provided by the calling bundle.

As soon as the resource resolver is not used anymore, ResourceResolver.close() should be called.
The ResourceResolver we get from SlingHttpServletRequest is managed by container, we should not close it.

As per the official documentation


A Resource Resolver has a life cycle which begins with the creation of the Resource Resolver using any of the factory methods and ends with calling the close() method. It is very important to call the close() method once the resource resolver is not used any more to ensure any system resources are properly clean up.

So the ResourceResolver we get from factory should be managed by our own code. Also have a look at this link. This gives good insight around ResourceResolver and Sessions which are important from Sling and JCR prespective
Best practice is to create and close the session where ever necessary instead of creating it globally !
2. The ResourceResolver defines the service API which may be used to resolve Resource objects.
The resource resolver is available to the request processing servlet through the SlingHttpServletRequest.getResourceResolver() method. 
A resource resolver can also be created through the ResourceResolverFactory. 
ResourceResolver resr=ResourceResolverFactory.getResourceResolver();
Resource res=resr.getResource();
A ResourceResolver is generally not thread safe! As a consequence, an application which uses the resolver, its returned resources and/or objects resulting from adapting either the resolver or a resource, must provide proper synchronization to ensure no more than one thread concurrently operates against a single resolver, resource or resulting objects.

Accessing Resources
This interface defines two kinds of methods to access resources: The resolve methods and the getResource methods.
Resolve- method :  (Returns NonExistingResource if no resource)= Path is always assumed to be absolute. Uses elaborate resource resolution algorithm. This kind of method is intended to resolve request URLs to resources.
getResource method (Returns null if no resource found)= Directly access resources with absolute path. For relative paths, the search path is applied. This method is intended to be used by request processing scripts to access further resources as required.
Lifecycle
A Resource Resolver has a life cycle which begins with the creation of the Resource Resolver using any of the factory methods and ends with calling the close() method. 
It is very important to call the close() method once the resource resolver is not used any more to ensure any system resources are properly cleaned up.
3. Resource
Resources are pieces of content on which Sling acts.
The Resource is also an Adaptable to get adapters to other types. A JCR based resource might support adapting to the JCR Node on which the resource is based.
adaptTo
Adapts the adaptable to another type.

Experience fragment in AEM
Steps to create –
1.	{Domain} /aem/start.html
2.	Click on Experience fragmenent
3.	Create project specific folder/structure
4.	Click Create Experience fragment at right top
5.	On “Create Experience Fragment” wizard -properties
 provide  -title, name ,description, tags
6.	First variant-

Dynamic / Editable template
Template Folders
For organizing your dynamic  templates you can use the following folders:
•	global
•	Site-specific
The site-specific folders that you create to organize your templates are created with an account holding admin priviliges.

In a standard AEM instance the global folder already exists in the template console. This holds default templates and acts as a fallback if no policies and/or template-types are found in the current folder. You can add your default templates to this folder or create a new folder (recommended).
Steps to create editable template
1. Go to Tools -> General -> Configuration Browser
 
Fig - Configuration Browser Option 
2. Create Configuration, Title should be your project name and check on editable templates.
     

3.It will create the basic hierarchy of templates in /conf directory.
 
Fig - Hierarchy of editable template under conf directory

There are three parts of template editor: 
•	templates Here all the dynamic templates are contained which are created by template authors.
•	policies: There are two types of policies:
1.	Template Level Policy: This policy is used to define client side libraries of all the pages, created from a particular template.
2.	Component Level Policy: These policies are used to define components for a particular responsive grid (parsys)for all the pages created from the template.
•	template-types: This is a base template on the basis of which template author creates all its templates at the run time.

There are three parts of a template:
•	initial: Initial Content mode is used to define content that will appear when a page is first created based on the template.The initial content can then be edited and removed by page authors.
•	policies: Here a particular template is linked to a policy by using cq:policy property.
•	structure:
1.	The structure allows you to define the structure of the template.
2.	The components defined in the template level can’t be removed from the resulting page.
3.	If you want that template authors can add and remove components, add a paragraph system to the template.
4.	Components can be locked and unlocked to allow you to define initial content.

To start working on dynamic templates, we need to create a page Component.—
1.Go to the project hierarchy, and click on Create Component.
 
Fig - Creation of Page Component
3.	No need to create page.html because it will be getting fetched from sling:resourceSuperType (core/wcm/components/page/v1/page).

Now create a base template-type
1. Creation of a template-type is a job of developer which helps template authors to create it’s dynamic (editable) templates.
2. Go to /conf/my-project/settings/wcm/template-types.Create a node “empty-page” of type cq:Template.
 

3. Create a node named “jcr:content” of type “cq:pageContent” under “empty-page”  having “jcr:title” and “jcr:description”.
 
Fig - add basic property in template-type

4. Create “initial” of type “cq:page” inside “empty-page”.
 
Fig - Creation of Initial Hierarchy of Template-types

5. Create a Node “jcr:content” of type cq:pageContent under initial node and add a property "sling:resourceType" pointing to a page Component (myproject/components/page/page).
 
Fig - Adding the page component as a rsource type in intial structure of template-types

initial hierarchy:
    +initial(cq:Page) 
       +--jcr:content(cq:PageContent) 
            sling:resourceType :myproject/components/page/page

6. Create structure node hierarchy exactly like you have created initial hierarchy under “empty-page”.
structure hierarchy: 
   +structure(cq:Page) 
       +--jcr:content(cq:PageContent) 
            sling:resourceType :myproject/components/page/page
            cq:deviceGroups :/etc/mobile/groups/responsive
             +--root(nt:unstructured)
              sling:resourceType :wcm/foundation/components/responsivegrid
              +--cq:responsive
                 +--breakpoints
                   +--phone
                      title: Smaller Screen
                      width{Long}: 650
                   +--tablet
                      title: Tablet
                      width{Long}: 1200

7. Now create policies hierarchy under “empty-page”.

policies hierarchy:
   +policies(cq:Page) 
       +--jcr:content
            sling:resourceType : wcm/core/components/policies/mappings
            +--root(cq:PageContent)
            sling:resourceType : wcm/core/components/policies/mapping

8. Create a image of name “thumbnail.png” to create a thumbnail of template-type. Now I am ready with the base template type and the role of template author has been started.


Editable Boolean true is important properties to add on parsys node in order to make the template editable in siteadmn page.
How Template author Creates Dynamic Templates?


1. Go to Templates-> Go to your project-> Create-> Choose empty template.
 
Fig - Creation of Editable Template from Template-tyes
2. Name the template(i.e., Base Page Template) and Open the template.

3. There will be a responsive grid available.
 
Fig - Responsive Grid (Layout - Container) in the Editable Template

Now Understand what is Template Level Policy?

Template level policy allow you to define specific client-side-libraries for a particular template.
1.Go to the template Page Design.
 
Fig - Select the Page Design option for creating the template level policy in Editable template 


2.You can see the dialog over template author can add client side libraries at the run time by creating a template level policy.
 
Fig -  Creation of Template Level Policy 

Understand the structure of the template level policy on node levels.
 

Benefits of Template level policy:
•	Now there is no need to include or hard code client libraries in the page component.
•	Template authors can dynamically add or remove client side libraries as per the requirements

Now Understand what is Component Level Policy?
We are going to have the policy of a Layout container.
 
 Fig - Option for creating the Component Level Policy
 
 Fig - Creation of  Component Level Policy

So, In layout level Policy, you can create a policy and allowed component for a particular layout container. Only the selected components in the policy will be able to use by page authors for that specific container.
Note:Configuring a policy is mandatory for container components as it enables you to define components that will be available in the container.
Note: If we want to provide flexibility to page authors to drag components in the container, then don’t forget to unlock parsys.
 
 Fig - Flow and Structure of Component Level Policy
Note: Enable the template and you can create multiple pages for your website from a particular template.
But there is a need to allow template under a hierarchy,where you want to create pages from that template.
Create a page without a template(you need to create page manually) and add a property in page properties dialog.
 
 Fig - Allowed Template for creating the page 

 
 Fig - Page Creation from editable template

Now you will see the templates when you create pages from that template.


How to Configure Emulator in a Page

Emulator Icon won’t be displayed directly in the pages created from the template while using Dynamic Templates. So there is a need to add a configuration in Felix console:
 
Fig - Emulator Configuration

1.Go to the OSGi configuration named “com.day.cq.wcm.mobile.com.impl.MobileEmulatorProvider” Add your base page Component path in this configuration:

2. Make sure that the template-types (e.g.,empty-page) are having a property named cq:deviceGroups in structure hierarchy shown below.
 

3 The emulator icon will start showing up on the page.
 
Fig - Emulator option in the page
But if you want to resize responsive grid using layout editor, the resizing won’t work by default. So there is a need to have a CSS file named grid.less, that helps to use and resize layout container.

Default Components:In the Responsive grid policy you can see a tab having default components.
 
Fig - Default Component option in the responsive grid (parsys)
On the Default Components tab, you define which components are being associated with given media types so that when an author drags an asset from the asset browser(content finder), AEM knows that this mime type need to be associated  with which component.
Note: Only components with drop zones (drop targets in cq:editConfig node) are available for such configuration.
Click or tap Add Mapping to add an entirely new component and MIME type mapping.
Select a component in the list and click or tap Add type to add an additional MIME type to an already mapped component.

Click the Delete icon to remove a MIME type.

Design Dialog with Template Editor

Design dialogs plays a very vital role with template editor. If you create a component having a design_dialog, you can save its value at the template level and all the pages created from that template can use those values.

How it works?
So if we have a design_dialog of a component, it can be configured in the component policy.

Note: Design mode is only available for static templates. 

Sling Servlet
Request processing diagram in sling:
1. client send a request.
2. Servlet container get the request and forward it to OSGI HttpService.
3.  OSGi HttpService looks for responsible registered Servlet or  resource
4. OSGi HttpService calls handleSecurity of the HttpContext associated with the servlet/resource. 
-  In case of  Sling, it calls into SlingMainServlet.handleSecurity and into     
    SlingAuthenticator.authenticate
-   SlingAuthenticator selects an authentication handler for the request and forwards the 
     authenticate call. On success a javax.jcr.Session is created,
-   If authentication fails either an anonymous session is acquired (if anonymous is allowed per
    configuration) or the login method is called
-   The login method selects an AuthenticationHandler and forwards the login call to the      
    AuthenticationHandler.requestAuthentication method  to cause the client to authenticate.      
    Request processing stops here (SlingMainServlet.handleSecurity returns false).
5.	After getting a response the HttpService either terminates the request (if authentication failed and SlingMainServlet.handleSecurity returned false) or continues by either spooling the resource or in the case of Sling calling the SlingMainServlet.service method.
6.	 The SlingMainServlet.service method is the entry point into the Sling proper. This method sets up the request:
Wraps the HttpServletRequest and the HttpServletResponse into the SlingHttpServletRequest and the SlingHttpServletResponse
Checks if Sling is ready for processing the request (checks at the moment for an existing ResourceResolverFactory service, a ServletResolver service and a MimeTypeService)
Create the ResourceResolver based on the Session (by default creates a JcrResourceResolver2)
Locate the Resource on the basis of the request by calling ResourceResovler.resolve through RequestData.initResource (see also URL decomposition)
Locate the servlet or script (see Servlets) by calling ServletResolver.resolveServlet through RequestData.initServlet

     SlingSafeMethodsServlet class

this base class is intended for applications where data is only read. As such, this servlet by itself does not support the POST, PUT and DELETE methods. Extensions of this class should either overwrite any of the doXXX methods of this class or add support for other read-only methods only. Applications wishing to support data modification should rather use or extend the SlingAllMethodsServlet which also contains support for the POST, PUT and DELETE methods. This latter class should also be overwritten to add support for HTTP methods modifying data.

     SlingAllMethodsServlet class
base class for data modifying Servlets used in Sling. This class extends the SlingSafeMethodsServlet by support for the POST, PUT and DELETE methods. 
Implementors note: The methods in this class are all declared to throw the exceptions according to the intentions of the Servlet API rather than throwing their Sling RuntimeException counter parts. This is done to easy the integration with traditional servlets. 
  
      Registering a Servlet using Java Annotations
       There are two ways of doing this, either with a Sling-specific @SlingServlet annotation or    
        with the more generic maven-scr-plugin annotations.
      The @SlingServlet annotation using resource type
@SlingServlet(
    resourceTypes = "sling/servlet/default",
    selectors = "hello",
    extensions = "html",
    methods = "GET")

public class MyServlet extends SlingSafeMethodsServlet {

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        ...
    }
}
OR 
 The @SlingServlet annotation using path 
     @SlingServlet( paths={"/services/unicom/v1/"})
                                   
@Properties({
    @Property(name="service.pid", value="com.adobe.unicom.v1.servlets.OmnnitureLoggingServlet",propertyPrivate=false),
    @Property(name="service.description",value="Omniture service call logging servlet", propertyPrivate=false),
    @Property(name="service.vendor",value="Adobe Systems Incorporated - Adobe@Adobe Team", propertyPrivate=false)
})

                     
The @Properties and @Property annotations
@Component(metatype = true)
@Service(Servlet.class)
@Properties({
    @Property(name = "sling.servlet.resourceTypes", value = "sling/servlet/default"),
    @Property(name = "sling.servlet.selectors", value = "hello"),
    @Property(name = "sling.servlet.extensions", value = "html"),
    @Property(name = "sling.servlet.methods", value = "GET")
})
public class MyServlet extends SlingSafeMethodsServlet {

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws ServletException, IOException {
        ...
    }
}
	
IMP: paths property of the @SlingServlet annotation overrides the resourceTypes and methods properties

Sling  Servlet 
Servlets can be registered as OSGi services. 
The following service reference properties are evaluated for Servlets defined as OSGi services of type javax.servlet.Servlet 

(all those property names are defined 
in org.apache.sling.api.servlets.ServletResolverConstants (since API 2.15.2) 
or 
org.apache.sling.servlets.resolver.internal.ServletResolverConstants (before API 2.15.2)):

Sling Servlet can be registered as OSGI service through either:
1.	Registering a Servlet using Java Annotations ( maven scr plugin)–

       @Component(metatype = true)
       @Service(Servlet.class)
       @Properties({
         @Property(name = "sling.servlet.resourceTypes", value =            
         "sling/servlet/default"),
       @Property(name = "sling.servlet.selectors", value = "hello"),
       @Property(name = "sling.servlet.extensions", value = "html"),
       @Property(name = "sling.servlet.methods", value = "GET")})

       public class MyServlet extends SlingSafeMethodsServlet {

       @Override
      protected void doGet(SlingHttpServletRequest request,     
                           SlingHttpServletResponse response) throws   
      ServletException, IOException {
        ...
                                    }
          }
 
           
2.	Registering a Servlet using Java Annotations (AEM 6.3 OSGI DS annotation ) –Maven-bundle-plugin
public final class ServletResolverConstants
                      Service registration properties and common values used for registering a Sling 
                      Servlet. That is provided by ServletResolverConstants



@Component(
service = { Servlet.class },
property = { 
    SLING_SERVLET_RESOURCE_TYPES + "=/apps/my/type"
    SLING_SERVLET_METHODS + "=GET",
    SLING_SERVLET_EXTENSIONS + "=html",
    SLING_SERVLET_SELECTORS + "=hello",
  })



3.	Registering with  The @SlingServlet annotation (evaluated by maven-scr-plugin)

:@SlingServlet(
resourceTypes = "/apps/my/type",
   selectors = "hello",
      extensions = "html",
methods = "GET")

 
 sling.servlet.paths  -- A list of absolute paths under which the servlet is accessible as a Resource. The property value must either be a single String, an array of Strings or a Vector of Strings.
A servlet using this property might be ignored unless its path is included in the Execution Paths (servletresolver.paths) configuration setting of the SlingServletResolver service. Either this property or the sling.servlet.resourceTypes property must be set, or the servlet is ignored. If both are set, the servlet is registered using both ways.
sling.servlet.resourceTypes --
The resource type(s) supported by the servlet. The property value must either be a single String, an array of Strings or a Vector of Strings. Either this property or the sling.servlet.paths property must be set, or the servlet is ignored. If both are set, the servlet is registered using both ways.

sling.servlet.selectors- 
The request URL selectors supported by the servlet. The selectors must be configured as they would be specified in the URL that is as a list of dot-separated strings such as print.a4. The property value must either be a single String, an array of Strings or a Vector of Strings. This property is only considered for the registration with sling.servlet.resourceTypes.



sling.servlet.extensions-
The request URL extensions supported by the servlet for requests. The property value must either be a single String, an array of Strings or a Vector of Strings. This property is only considered for the registration with sling.servlet.resourceTypes.

sling.servlet.methods –
The request methods supported by the servlet. The property value must either be a single String, an array of Strings or a Vector of Strings. This property is only considered for the registration with sling.servlet.resourceTypes. If this property is missing, the value defaults to GET and HEAD, regardless of which methods are actually implemented/handled by the servlet.

sling.servlet.prefix-
The prefix or numeric index to make relative paths absolute. If the value of this property is a number (int), it defines the index of the search path entries from the resource resolver to be used as the prefix. The defined search path is used as a prefix to mount this servlet. The number can be -1 which always points to the last search entry. If the specified value is higher than than the highest index of the search paths, the last entry is used. The index starts with 0. If the value of this property is a string and parseable as a number, the value is treated as if it would be a number. If the value of this property is a string starting with "/", this value is applied as a prefix, regardless of the configured search paths! If the value is anything else, it is ignored. If this property is not specified, it defaults to the default configuration of the sling servlet resolver.

Supported types of events
At the moment you will get two different types of SlingRequestEvent:
events types (SlingRequestEvent.EventType)	point in time
EVENT_INIT	after entering the service method in SlingMainServlet. Note that this will be after the handleSecurity call.
EVENT_DESTROY	at the end of the service method in SlingMainServlet

Apache Sling Selectors and Request Parameters: Getting it Straight 
It’s time to break down the fundamental differences between using an Apache Sling selector and using an HTTP request parameter. They are often confused or used interchangeably. 
Have you ever said anything like the following?
•	“You can use a selector or a request parameter. Either one will work fine.”
•	“You should use a selector so that your page can still be cached by the dispatcher.”
•	“Selectors are the way you pass values to a servlet with Apache Sling, not request parameters.”
These incorrect statements demonstrate common misunderstandings of the purpose for the Sling selector and/or a misunderstanding of how to utilize the RESTful interface that Sling enables. I’ve been there. It’s not completely obvious when to use these two concepts, especially if you are new to Sling and/or AEM. My intention is to more clearly define when to use Sling selectors and when to use request parameters.
Why the confusion?
Sling selectors and request parameters both allow you to dictate information about an HTTP request that you’ll make. They are both included in the HTTP request (both on the request URL if making a GET request). They can both be accessed using the Sling Java API via SlingHttpServletRequest.getRequestParameters() or SlingHttpServletRequest.getRequestPathInfo(). getSelectors (). 
Despite the fact that they often can be used in the same way, they are actually meant to serve different functions.
Selectors vs. Request Parameters
A request parameter is like an input to a function. 
If you know you have some kind of operation that occurs at /get/me/some/info.json, you can attach request parameters to your GET request URI to retrieve the output of that servlet.
For example, /get/me/some/info.json?on=football tells the servlet that you want some information on football. 
It functions much like a Java method that would take a single argument and return an object containing info (i.e. public InfoBean getMeSomeInfo(String on)). In fact, the doGet( ) method of this hypothetical servlet will probably invoke a function just like that.
Request parameters allow you to cheat (so to speak) when building an HTTP-accessible interface. You can build an API that isn’t really all that RESTful. In other words, your request path doesn’t have to be the logical location of the resource you are requesting. 
You can put your servlet wherever you want, because your request parameters are pretty much the only thing that affects the output of the operation. Putting servlets under the /bin directory is a perfect example of this. Nothing about request parameters requires (or should even encourage) you to avoid the principles of REST, but it happens a lot. 
Apache Sling selectors provide a different mechanism for inputting information into a servlet. However, when using a selector, you input a fundamentally different kind of information. Selectors are a descriptor of  how you want to receive a resource, given the path to it (via the URI). 
Unlike request parameters, a selector is not an input to be processed to create an output.
Selectors are a lot like file extensions. When you make a request to /some/page.html, you are telling the web server, “Get me the ‘page’ resource, located in the ‘some’ directory, and return it as an HTML file.” 
The extension doesn’t impact what the resource is or the resource’s state – simply how you want it (specifically, what type of file). The selector does the same exact thing, save the dictation of file type. For example, a request to /some/page.html returns the same resource (the same thing) as /some/page.mobile.html. The only difference is that the latter request says, “Get me the ‘page’ resource, located in the ‘some’ directory, and return it as mobile-friendly HTML.”
Getting it Right
This can get confusing, and it’s far too easy to do the wrong thing. I believe that if you try to follow these practices as closely as possible, you’ll avoid situations where you misuse Sling selectors and the Sling RESTful API.
Use RESTful Paths
If you resolve resources by making requests to their natural, RESTful locations, it will help you avoid the temptation to use selectors to define what the resource is. Making a request to /bin/something.fancy.json isn’t RESTful, because it’s making a request to some arbitrary URL to which you registered a servlet. Nothing about the URL naturally describes the thing you are trying to get.
Making a request to the location that the desired resource naturally resides enables you to let the resource define its own state. It gives you an opportunity to provide a description of how you want the resource (the selector). The resource may or may not have a special renderer for that selector, but that’s irrelevant to the requester. The resource knows how it needs to render. 
Whenever possible make requests directly to the resource, then allow JSPs within that resource type (component) -or Sling Servlets registered to that resource type- to resolve the request, considering the selector, if needed.
Don’t use Dispatcher Caching as an Excuse
Yes, by default the CQ5/AEM dispatcher will cache requests made to resources, even if the request contains selectors. Yes, adding request parameters to a request will automatically bypass the Dispatcher cache. However, this does not mean that you should use Sling selectors simply because you want to cache a resource. 
If you adhere to the definitions of selectors and parameters that I just provided, you’ll find that this default caching rule is actually quite appropriate. The responses for requests made with parameters should be unique every time and therefore should not be cached (here are some inputs, what output do they produce?). Requests made with selectors should not change until a content author activates a content or state change for the resource. The author’s activation will invalidate the cache, when it is appropriate. The key difference is that the selector should have no impact on the structure or state of the resource being returned, so caching is (by default) appropriate.
When you do find an exception to this rule, and occasionally you will, use the dispatcher setting to ignore certain request parameters when deciding whether to cache. Don’t just stuff your inputs into selectors.
Only Use Selectors for Servlet Registration
Sling is built to ingest URLs that may contain selectors. It has rules about how those selectors affect what servlet (JSP or Java Servlet) will be used to render the requested resource. Stick to using selectors for only the purpose of giving Sling an indicator as to which servlet to use. That means only refer to them in the Java annotations that register a Sling Servlet or in the filenames of JSPs that effectively do the same thing.
If you find yourself tempted to get the request’s selectors via SlingHttpServletRequest.getRequestPathInfo().getSelectors(), that should be a big red flag that you are trying to use that selector like you would an input to a function. In other words, you are trying to use a selector like a request parameter. Rethink your approach.

     
Request Parameter Handling in Sling
Servlet API
The Servlet API specification provides the following methods to access the parameters of a request
Method	Description
HttpServletRequest.getQueryString()	Returns the query part of the request URL
ServletRequest.getParameter(String)	Returns the (first) named parameter
ServletRequest.getParameterValues(String)	Returns all parameters of that name
ServletRequest.getParameterMap()	Returns all parameters as a map of String[]()
ServletRequest.getParameterNames()	Returns an enumeration of the names of the parameters
ServletRequest.getParts()	Returns all parts of the multipart request (since v3.0)
ServletRequest.getPart(String)	Returns the request part with that name in case of multipart requests (since v3.0)


Useful APIs:

For page level operation:
PageManager interface provides methods for page level operations:


COPY page/COPY resource , CREATE page/Create revision , Delete page/resource
Other Operations:  getContainingPage that contain path/resource/
move page/resource , getTemplate (parentPath/ templatePath)
For Replication operation:
The Replicator is the replication service. It can be used to replicate content.
Its provides Method: 

void	replicate(Session session, ReplicationActionType type, String path) 
          Triggers a new replication with supplied options.
 void	replicate(Session session, ReplicationActionType type, String path, ReplicationOptions options)

session - user session
type - The type of replication
path - The path specified the content to be replicated 
             options - Additional replication options	

The ReplicationOptions encapsulate optional configuration parameters for a replication.	
public enum ReplicationActionType , ACTIVATE(Content is activated), DEACTIVATE (Content is deactivated), 
DELETE(Content is deleted),(INTERNAL_POLL Content is polled by reverse replication)

For workflows:
interface WorkflowProcess
WorkflowProcess is the interface to be used for automatic workflow steps implemented in Java.
Method: 
 void	execute(WorkItem item, WorkflowSession session, MetaDataMap args) 
          Executes a new Java process with the given WorkItem and WorkflowSession.

  
public interface ParticipantStepChooser
The ParticipantStepChooser interface is intended for impls that will define the participant dynamically. 
String
getParticipant(WorkItem workItem, WorkflowSession workflowSession, MetaDataMap args) 
          Returns the dynamically resolved Principal id


For Users Management related:

Interface Authorizable, Known Subinterfaces: Group, User
The Authorizable is the common base interface for User and Group. It provides access to the Principals associated with an Authorizable (see below) and allow to access and modify additional properties such as e.g. full name, e-mail or address. 
Please note the difference between Authorizable and Principal.
An Authorizable is repository object that is neither associated with nor depending from a particular Session and thus independent of the login mechanisms creating Sessions.

On the other hand, Principals are representations of user identities. In other words: each Principal within the set associated with the Session's Subject upon login represents an identity for that user.
User: defined to be an Authorizable that can be authenticated (by using Credentials) and impersonated.
Group: defined to be a collection of other Authorizables.
Interface Authorizable, provides the methods,
getID , getPath , getPrincipal ,
Interface Principal, provides methods, getName , hashcode
Interface Group, provides methods, getMember , isMemeber, removeMember, addmember
Interface User, provides method, getCredential, getImpersantion





Run Mode Install & Start an Author Instance:

A CQ5 quickstart JAR ■ A valid CQ5 license key ■ A JDK >= 1.5 ■ Approximately 1Gb of free space ■ Minimum of 1 GB of RAM

1.	Create a folder structure on your file system where you will store, install, and start CQ5
2.	Copy the CQ5 quickstart JAR and license.properties
3.	Rename the CQ5 quickstart JAR to cq-author-4502.jar 
•	cq = the application
•	author = the WCM mode it will run in (e.g. author or publish)
•	4502 = the port it will run in (e.g. any available port is acceptable)
•	If no port number is provided in the file name, CQ5 will select the first available port from the following list: 1) 4502, 2) 8080, 3) 8081, 4) 8082, 5) 8083, 6) 8084, 7) 8085, 8) 8888, 9) 9362, 10) rand
4.	 Double-click the cq-author-4502.jar file
Run modes 
Run modes allow you to configure CQ and AEM instances for specific purposes. For example, author instances use the author run mode, and publish instances use the publish run mode. 
Once set, run modes are used to tune each instance by defining collections of configuration parameters for each run mode or combination of run modes. Default sets of configurations are applied to all run modes. 
Set publish or author run mode using quickstart naming
The naming convention to use for CQ 5.6 and earlier is:
cq-<optional-version-or-identifier>-<standard-run-mode>-<port-number>
The naming convention to for AEM 5.6.1 and later is:
aem-<optional-version-or-indentifier>-<standard-run-mode>-<port-number>

Set up run modes using the Sling properties file
Run modes can be specified within the sling.properties file. This file can be found at <cq-installation-dir>/crx-quickstart/launchpad/sling.properties. Set the property, sling.run.modes, to a comma-delimited list of run modes to apply.
For example:
sling.run.modes=author,test,uk
or 
sling.run.modes=publish,development

Set up run modes using JVM arguments
A JVM argument, -Dsling.run.modes, can be used to specify run modes as well. This argument can be used on the command line, as a system property or within a startup script.
For example:
java -Xmx512m -jar cq-quickstart-5.6.1.jar -Dsling.run.modes=publish,prod,us
Behavior when run modes are specified more than one way
The run mode specified in the naming of the jar file takes precedence. If run modes are not specified in the naming of the jar file, the values in the sling.properties file are used. If run modes are not specified in either the naming of the jar file or the sling.properties file, the system property (or JVM argument) is used.
Run modes AEM 6.3 – 
•	author
•	publish
•	samplecontent
•	nosamplecontent
Customized Run Modes
You can also create your own, customized, run modes. These can be combined to cover scenarios such as:
•	author + development
•	publish + test
•	publish + test + golive

•	publish + intranet
•	as required . . .
Customized run modes can also be selected at each startup.
Using samplecontent and nosamplecontent
These modes allow you to control the use of sample content. The sample content is defined before the quickstart is built and can include packages, configurations, etc:
•	The samplecontent run mode will install this content (the default mode).
•	The nosamplecontent mode will not install the sample content.
The nosamplecontent run mode is designed for production installations.
Clientlibs in AEM 
A client-side library folder is a repository node of type cq:ClientLibraryFolder.
categories: List of tags or dynamic dependencies. If a category is used in the ClientLibraryManager.include() method, all cq:ClientLibrarys tagged with this category will be included in the html

dependencies: A list of either categories or paths to cq:ClientLibrarys that have to be included in resulted html. This is a list of other client library categories on which this library folder depends. For example, given two cq:ClientLibraryFolder nodes F and G, if a file in F requires another file in G in order to function properly, then at least one of the categories of G should be among the dependencies of F.
embed
A library can embed other libraries. This is useful to reduce the amount of includes or to bypass some access restrictions of libraries that reside in a read-protected area.
When a library defines categories to be embedded, if only embeds the direct dependencies that match the same type (obviously) and theme.
Referencing Client-Side Libraries in HTML
Add a cq: includeClientLib tag to your JSP code to add a link to client libraries in the generated HTML page.
To reference the libraries, you use the value of the categories property of the cq: ClientLibrary node.
Creating Client Library Folders
Add clientlibs type of node  clientlibraryfolder.
Add js and css folder
Add js.text and css .text parallel to node  clientlibraryfolder.
    Open the file and type the following text to identify the root of the path of the source files:
   #base=[root]
   Replace [root] with the path to the folder that contains the source files, relative to the TXT file. For      
   example, use the following text when the source files are in the same folder as the TXT file: #base=.
   The following code sets the root as the folder named mobile below the cq:ClientLibraryFolder node:
    #base=mobile
Note:- If we don’t add TXT files to client library folder then aem wont treat it as client library folder, because inside client library folder it looks for txt file to understand what are files it need to include in our component jsp.

What we want is that the user gets the resources from /etc/designs/<project>, so that /apps can be closed for the production configuration. And on top of that we want that the resources will be merged into a single .js and .css reference.
Create a new folder “aproject” in /etc/designs, then create the structure as shown below. The js.txt and css.txt should be empty files.
The “clientlib” node has the following properties  with the “embed” property it embeds all the resources of “myproject.components”
Embedding code is useful for providing access to libraries that are stored in secured areas of the repository. 
The HTML Library Manager service processes cq:ClientLibraryFolder tags and generates the libraries at runtime.
To link your pages to the mywebsite design, in CRXDE Lite, select the /content/mywebsite/en/jcr:content node. On the Properties tab, type the following values for a new property and then click Add:
•	Name: cq:designPath
•	Type: String
•	Value: /etc/designs/mywebsite
Using ClientlIbrary in AEM 6.3
Referencing Client-Side Libraries
Because HTL is the preferred technology for developing AEM sites, HTL should be used to include client-side libraries in AEM. However it is also possible to do so using JSP.
Using HTL
In HTL, client libraries are loaded through a helper template provided by AEM, which can be accessed through data-sly-use. Three templates are available in this file, which can be called through data-sly-call:

•	css - Loads only the CSS files of the referenced client libraries.
Adobe recommends placing Clientlibs under etc. The typical way a clientlib is included is use of  <sly data-sly-use.clientLib=
"/libs/granite/sightly/templates/clientlib.html"
 data-sly-call="${clientLib.css @ categories='AEM63.all'}" data-sly-unwrap/>
•	js  - Loads only the JavaScript files of the referenced client libraries.
Adobe recommends placing Clientlibs under etc. The typical way a clientlib is included is use of  <sly data-sly-use.clientLib=
"/libs/granite/sightly/templates/clientlib.html"
 data-sly-call="${clientLib.js @ categories='AEM63.all'}" data-sly-unwrap/>

•	all - Loads all the files of the referenced client libraries (both CSS and JavaScript).
Adobe recommends placing Clientlibs under etc. The typical way a clientlib is included is use of  <sly data-sly-use.clientLib=
"/libs/granite/sightly/templates/clientlib.html"
 data-sly-call="${clientLib.all @ categories='AEM63.all'}" data-sly-unwrap/>

Locating a Client Library Folder and Using the Proxy Client Libraries Servlet
Client library folders were located below /etc/clientlibs in the repository. This is still supported, however it is recommended that client libraries now be located under /apps. This is to locate the client libraries near the other scripts, which are generally found below /apps and /libs.
In order to better isolate code from content and configuration, it is recommended to locate client libraries under /apps and expose them via /etc.clientlibs by leveraging the allowProxy property.

In order for the client libraries under /apps to be accessible, a proxy servelt is used. The ACLs are still enforced on the client library folder, but the servlet allows for the content to be read via /etc.clientlibs/ if the allowProxy property is set to true.
A static resource can only be accessed via the proxy, if it resides below a resource below the client library folder.
As an example:
•	You have a clientlib in /apps/myproject/clientlibs/foo
•	You have a static image in /apps/myprojects/clientlibs/foo/resources/icon.png
Then you set the allowProxy property on foo to true.
•	You can then request /etc.clientlibs/myprojects/clientlibs/foo.js
•	You can then reference the image via /etc.clientlibs/myprojects/clientlibs/foo/resources/icon.png
Caution:
When using proxied client libraries, the AEM Dispatcher configuration may require an update to ensure the URIs with the extension clientlibs are allowed.
Caution:
Adobe recommends locating client libraries under /apps and making them available using the proxy servlet. However keep in mind that best practice still requires that public sites never include anything that is served directly over an /apps or /libs path.

Merging files through embed  property
To merge the several clientlib files into one, we define a clientlibs that is embedding the other categories. Example here is taken from /apps/weretail/clientlibs/clientlib-base.

 

Minify and Gzip
To deliver a better performance you can enable “Minify” and “Gzip” for the “Adobe Granite HTML Library Manager” (previously also called “Day CQ HTML Library Manager”), in the Felix Configuration console (http://server/system/console/configMgr). These settings are recommended for production installations.
 

Replication and reverse replication:
Replication agents are central to Adobe Experience Manager (AEM) as the mechanism used to:
•	Publish (activate) content from an author to a publish environment.
•	Explicitly flush content from the Dispatcher cache.
•	Return user input (for example, form input) from the publish environment to the author environment (under control of the author environment).
Replicating from Author to Publish
Replication, to a publish instance or dispatcher, takes place in several steps:
•	the author requests that certain content be published (activated); this can be initiated by a manual request, or by automatic triggers which have been preconfigured.
•	the request is passed to the appropriate default replication agent; an environment can have several default agents which will always be selected for such actions.
•	the replication agent "packages" the content and places it in the replication queue.
•	in the Websites tab the colored status indicator is set for the individual pages.
•	the content is lifted from the queue and transported to the publish environment using the configured protocol; usually this is HTTP.
•	a servlet in the publish environment receives the request and publishes the received content; the default servlet is http://localhost:4503/bin/receive.
•	multiple author and publish environments can be configured.
Replicating from Publish to Author
Features such as comments and forms, allow users to enter information on a publish instance. For this a type of replication is needed to return this information to the author environment, from where it is redistributed to other publish environments. However, due to security considerations, any traffic from the publish to the author environment must be strictly controlled.
This is known as reverse replication and functions using an agent in the publish environment which references the author environment. This agent places the input into an outbox. This outbox is matched with replication listeners in the author environment. The listeners poll the outboxes to collect any input made and then distribute it as necessary. This ensures that the author environment controls all traffic.
Replication Agents - Out of the Box
•  Default Agent
Used for replicating from author to publish. 
•  Dispatcher Flush
This is used for managing the Dispatcher cache. See Invalidating Dispatcher Cache from the Authoring Environment and Invalidating Dispatcher Cache from a Publishing Instance for more information. 
•  Reverse Replication
Used for replicating from publish to author. 
•  Static Agent
This is an "Agent that stores a static representation of a node into the filesystem.".
For example with the default settings, content pages and dam assets are stored under /tmp, either as HTML or the appropriate asset format. See the Settings and Rules tabs for the configuration.
This was requested so that when the page is requested directly from the application server the content can be seen. This is a specialized agent and (probably) will not be required for most instances.

Configuring Reverse Replication
This is done with:
•	an outbox in the publish environment where the content is placed.
•	an agent (publish) in the author environment which periodically polls the outbox for new content.
A reverse replication agent in the publish environment (an outbox)
This is the passive element as it acts as an "outbox". User input is placed here, from where it is collected by the agent in the author environment.

Binaryless replication
Binaryless replication or shared data store works on the basis that binaries are not copied across datastores. Only the metadata is replicated or transferred between the instances. The setup can be applied between authors and publishers. Alternatively data store can be shared between author instances also in a cold standby setup.

 It has 3 major use cases:
1.	When you are dealing with very large DAM assets (high res images or videos), any replication involving binary copies over network is very costly. Binaryless is shared data store so binaries are not copied and you save on internal network traffic. It saves time and cost for some setup.
2.	When you have lots of publishers, binary  copy can bottleneck your author network. This reduces the load of that transfer and publishers can be scaled without impacting network usage exponentially.
3.	TarMK cold standby has a limit of 2GB binary sync transfer across primary and standby standalone data stores. Binaryless (or shared datastore) is the only workaround for this limit.
For very large datastores you also save time in backups and restores as there is only one store as opposed to 2 stores for author and publishers.
To configure it, the following steps are needed.  Please note that this feature will NOT work if the Data Store is a ClusterDataStore.  If you have clustered instances, contact Adobe Support for a hotfix.

1)	Change the Data Store type from ClusterDataStore to FileDataStore, point the FileDataStore on all instances to a shared network folder that is READ and WRITE enabled for all instances, and then copy the “author” instance’s Data Store contents to the new shared network folder. 

2)	 Start all instances and ensure that there are no exceptions related to this change.

3)	 Change the “Serialization Type” of the “Publish” replication agent from “Default” (Durbo) to “Binary Less”.


 

4) Add an additional argument (binaryless=true) to the replication agent’s “Transport URI”  so that it looks like something like this:
http://localhost:4503/bin/receive?sling:authRequestLogin=1&binaryless=true

Save the changes.

  In the “author” instance’s error.log, you should see log entries such as follows:
*INFO* [ObservationManager] com.day.cq.replication.impl.AgentManagerImpl AgentConfig at /etc/replication/agents.author/publish updated.
*INFO* [ObservationManager] com.day.cq.replication.Agent.publish Agent stopped.
*INFO* [ObservationManager] com.day.cq.replication.Agent.publish Agent stopped for configuration
*INFO* [ObservationManager] com.day.cq.replication.Agent.publish Agent configuration updated at /etc/replication/agents.author/publish/jcr:content
*INFO* [ObservationManager] com.day.cq.replication.Agent.publish Agent updated. State is enabled and valid
*INFO* [ObservationManager] com.day.cq.replication.Agent.publish Agent started.
You can verify that these changes to the “Publish” replication agent have been persisted by navigating to /var/replication/agents.author/publish/jcr:content  (using CRX DE Lite at /crx/de/index.jsp)
 
Check the properties of the jcr:content node, it should look something like this:
 
5) Also verify by activating some digital assets from the “author” instance and trying to consume them on the “publish” instance.
If you somehow screwed it up, you’ll get error messages such as this:
*WARN* org.apache.commons.io.IOExceptionWithCause: org.apache.jackrabbit.core.data.DataStoreException: Record does not exist.
NOTE:  After the change, only run Data Store Garbage Collection from the “author” instance.
Working with AEM Workflow
In general, Workflow is a well-defined series of steps to produce a desired out, usually include many participants in between these steps and processes in an organization. 

Workflow?
Workflows enable you to automate AEM activities. It consists of a series of automated steps also called process steps that are executed in a specific order. When you want to use workflow in CQ5 then first, you have to create workflow models.


Workflow model?
workflow models can be think as an architecture of a workflow that shows you how your workflow steps are arranged and how they connect with each other. Workflow model is made up of workflow step nodes and workflow transitions nodes. Workflow Model must have a start node and end node.

Model
Is made of WorkflowNodes and WorkflowTransitions. The transitions connect the nodes and define the "flow". The Model has always a start node and an end node.
Workflow models are versioned. Running Workflow Instances keep the initial workflow model version that is set when the workflow is started.


Workflow Transitions?
Workflow transitions are also nodes created in repository, they indicate how these process steps are related or you may think as these transition node define the path how these workflow process step will be executed. It can also be think as a link between two consecutive process steps.

Transition
Defines the link between two consecutive steps.
It is possible to apply rules.

WorkItem
Is the "there is a task identifier" and is put into the respective inbox.
A workflow instance can have one or many WorkItems at the same time (depending on the workflow model).
The WorkItem references the workflow instance.
In the repository the WorkItem is stored below the workflow instance.

Workflow Step Nodes?
workflow nodes are created for each steps you create in a workflow model for ex. if you created three process steps in your model then it will create three different nodes for all of these steps. These nodes are called workflow nodes.

Automated  Step?
These are the actual place where all the processing is done, there logic can be written in ECMA script or in process steps using Java. AEM itself provide some Out Of the Box processes. These step may be interactive or non interactive i.e. these step can get input from author or they can only do processing without any intervention of author. Due to all of these factor these steps are called automated steps.

Workflow Payload?
Workflow payload can be think of a resource on which a workflow instance is activated. i.e. payload could be any resource (node or page) or a collection of resources.

The payload implementation references a resource in the repository (by either a path or an UUID) or a resource by a URL or by a serialized java object.

Inbox
Each logged in user has its own workflow inbox in which the assigned WorkItems are accessible. 

The WorkItems are assigned either to the user itself or to the group to which he belongs. 

Lifecycle
Is created when starting a new workflow (by choosing the respective workflow model and defining the payload) and ends when the end node is processed. 
The following actions are possible on a workflow instance:   
Terminate
Suspend
Resume
Restart
Completed and terminated instances are archived.


AEM welcome Screen -> Select workflow tab
Here you will see four tabs

1). Model
List of all workflow models available in AEM.

2). Instances
List of all active instances of workflow model i.e. when you start a workflow then it's instance will be displayed in instances tab with many properties, all properties will be covered in this series of tutorial.

3). Archive
When a workflow instance has been finished successfully or terminated then it's information is visible in this tab.

4). Launcher
This is a tab to define a condition for starting a workflow automatically i.e. when a condition is satisfied a workflow will be started automatically. I will discuss it in details just leave it for this introductory post.

5). Failure
This tab show all the workflow instances failed i.e. any error occur while executing a process step of workflow instance. This tab give you the facility to fix the error and resume the workflow. 

This the basic architecture of a workflow model consists of three nodes:

Go to 
/etc/workflow/models/ , This is the place where all models has been saved. Just expend your model i.e. blog you will see all nodes as-

This flow Node having only one sub node named as participant. All the nodes under this directory represents the intermediate steps nodes between Start and End step.


Start, Participant, End steps 

Each of these node have a subnode metaData which will hold the information, which is available only when the workflow execution will reach to that particular step.

Participant metaData information is available only at participant step not before this step and also not after this step. 

when you execute a workflow then it's instance will be created under /etc/workflow/instance directory & all the real work has been down using that model instance node.

Creating Workflow Model: 
Create a workflow model to define a series of steps to execute. New workflow models include Flow Start and Flow End steps that represent the beginning and end of the workflow.

The new model appears in the Models tab.

Adding a Step to a Model
At run time, steps are executed in the order in which they appear in the model.

Editing a Workflow Step
Right-click a process step in the workflow model and click Edit:
Configure the step properties

Developing Custom steps:

To create a custom workflow step component, copy an existing step component to your application folder and modify it as required
Saving Property Values in Workflow Metadata
The name property of cq:widget items specifies the JCR node that stores the widget's value. When widgets in the dialog of workflow step compnents store values below the ./metaData node, the value is added to the workflow MetaDataMap. 
For example, a text field in a dialog is a cq:widget node that has the following properites:
Name	Type	Value
xtype	String	textarea
name	String	./metaData/subject
fieldLabel	String	Email Subject
The value that is specified in this text field is added to the workflow instance's MetaDataMap object, and is associated with the subject key. 
Note: When the key is PROCESS_ARGS, the value is readily available in ECMA script implementations via the args variable. In this case, the value of the name property is ./metaData/PROCESS_ARGS.



Developing Process Step Implementations
When process steps are started during the process of a workflow, the steps send a request to an OSGi service or execute an ECMA script.

Implementing a Process Step with a Java Class
~~The OSGI component needs to implement the WorkflowProcess interface with its execute() method.
~~The package name needs to be added to the <Private-Package> section of the maven-bundle-plugin configuration.
~~ Add the SCR property "process.label" (@Property(value = "My Sample Workflow Process"))
•  Open the CQ Workflow console, add the process step to the workflow using the generic Process Step component. 
 In the edit dialog, go to the Process tab and select your process implementation.  
 If you use arguments in your code, set the Process Arguments . For example: false. And Save the changes.
execute(WorkItem item, WorkflowSession session, MetaDataMap args)
{
// A WorkflowData instance "carries" the data pushed through the Workflow. A WorkItem is the unit that is passed through an Workflow instance of a WorkflowModel. It contains the WorkflowData the instances acts on and a reference to the WorkflowNode that describes the underlying workflow step.
WorkflowData wfd=item.getworkflowdata();
String path=wfd.getpayload.toString();
// persisting data through subsequent workflow steps, the following example adds an item to the workflow MetaDataMap object and then logs each item
MetaDataMap wfd = item.getWorkflow().getMetaDataMap();
 
    wfd.put("mykey", "My Step Value");
         
}

Developing a Participant Chooser Using a Java class

To define a participant step as an OSGI service component (Java class):
1.	The OSGI component needs to implement the ParticipantStepChooser interface with its getParticipant() method. See the example code below. 
Create the bundle and deploy it into the OSGI container. 
2.	Add the SCR property "chooser.label" and set the value as you please. This will be the name as which your participant chooser is listed, using the Dynamic Participant Step component. See the example below.
3.	In the CQ Workflow console, add the dynamic participant step to the workflow using the generic Dynamic Participant Step component.
4.	In the edit dialog select the Participant Chooser tab and select your chooser implementation.
5.	If  you use arguments in your code set the Process Arguments. For this example: /content/geometrixx/en.
6.	Save the changes.
public String getParticipant(WorkItem workItem, WorkflowSession workflowSession, MetaDataMap args) throws WorkflowException {
        WorkflowData workflowData = workItem.getWorkflowData();
        if (workflowData.getPayloadType().equals(TYPE_JCR_PATH)) {
            String path = workflowData.getPayload().toString();
            String pathFromArgument = args.get("PROCESS_ARGS", String.class);
            if (pathFromArgument != null && path.startsWith(pathFromArgument)) {
                return "admin";
          }
        }
        return "administrators";
   }



Starting Workflows

There are several ways to start a workflow: from a form submission, from the Workflow Console, from the Websites Console, from the Workflow tab in the Sidekick.

In every case a workflow need to be linked to its payload. The payload (including pages, nodes, resources) will then be subject to this instance of the workflow.

  Starting a workflow from the Workflow console
            • Open the Workflow console.
            • From the Models tab select the required workflow.
            • Click Start from the top navigation.
            •  The Start Workflow dialog opens allowing you to enter the payload and an optional                   
              title and comment.
            Click OK to start a workflow instance with the properties you configured. Now the         
            workflow is running.

Starting a workflow from Sidekick
• Open the Websites console.
• Open the required page.
• Select the Workflow tab from the Sidekick.
• Expand the Workflow dialog, allowing you to select the Workflow and optionally enter Workflow Title and Comment.
Click Start Workflow to start a new workflow instance with the properties you configured and the current page as the payload. Now the workflow is running.

Starting Workflows When Nodes Change
The Workflow Launcher, provides one component to monitor all changes in the content repository and launch workflows dependent on the location and resource type of the changed node.

Using the Launcher tab you can:
•	see the workflows already launched for specific nodes.
•	select a workflow to be launched when a certain node/node-type has been modified.
•	remove an existing workflow-to-node relationship.
A launcher can be created for any node. However, changes to certain nodes do not launch workflows. Changes to nodes below the following paths do not cause workflows to launch:
•	/var/audit
•	/var/classes
•	/var/eventing
•	/var/linkchecker
•	/var/mobile
•	/tmp
•	/etc/workflow/instances
•	Any workflow-inbox node located anywhere in the /home/users branch
•	/var/statistics (Exception: Changes to nodes below /var/statistics/tracking do cause workflows to launch.)

Adding a Launcher
• On the Workflow page, click the Launcher tab.
• Click Add and configure the new workflow-to-node relationship as required:
•	Event Type: The event type that will launch the workflow:
o	Created
o	Modified
o	Removed
•	Node type: The type of node that the workflow launcher applies to.
•	Path: The path that the workflow launcher applies to.
•	Conditions: Conditions for node values that, when evaluated, determine whether the workflow is launched. For example, the following condition causes the workflow to launch when the node has a property name with the value User:
name==User
•	Workflow: The workflow to launch when the Event Type occurs on the Nodetype and/or Path under the defined Condition.
•	Activate: Controls whether the workflow launcher is activated:
•	Select Enable to launch workflows when the configuration properties are satisfied.
•	Select Disable when the workflow should not execute when the configuration properties are satisfied.
•	Run Mode(s): The type of server that the workflow launcher applies to. Select Author, Publish, or Author & Publish.

Delegating a Participant Step
If a step has been assigned to you, but for any reason you are unable to take action, you can delegate the step to another user or group.
The users who are available for delegation depend on who was assigned the work item:
•	If the work item was assigned to a group, the group members are available. 
•	If the work item was assigned to a group and then delegated to a user, the group members and the group are available. 
•	If the work item was assigned to a single user, the work item cannot be delegated.

Workflow Reference:
Workflow Steps:

Workflow models consist of a series of steps of various types which can be extended with scripts to provide the functionality and control you require.

Common Step Properties
The following properties are available for most workflow step components, on the Common tab of the properties dialog:
Title : The title for the step.
Description: A description of the step.
Timeout: The period after which the step will be "timed out". You can select between Off, Immediate, 1h, 6h, 12h, 24h.

Timeout Handler: The handler which will control the workflow when the step times out; for example :com.day.cq. workflow. timeout. autoadvance. Auto Advancer.


Participant Step
A participant step enables you to assign ownership for a particular action. The workflow will only proceed when the user has manually acknowledged the step. This is used when you want someone to take an action on the workflow; for example, a review step.
Although not directly related, user authorization must be considered when assigning an action; the user must have access to the page that is the workflow payload.

The following properties are available:
User/Group:
A drop down selection box will allow you to navigate and select a user or group.
If you assign the step to a specific user, then only this user can take action on the step.
If you assign the step to an entire group, then when the workflow reaches this step all users in this group will have the action in their Workflow Inbox.

Email:
You can notify participant(s) by sending them an email when the workflow reaches the step.
If set to On, an email will be sent to the user defined by the property User/Group or to each member of the group if a group is defined.


Dialog Participant Step
Use a Dialog Participant Step to collect information from the user who is assigned the work item. This step is useful for collecting small amounts of data that is used later in the workflow.
Upon completing the step, the Complete Work Item dialog contains the fields that you define in your dialog. The data that is collected in the fields is stored in nodes of the workflow payload. Subsequent workflow steps can then read the value from the repository.
Creating the dialog
Dialogs for Dialog Participant Steps are similar to dialogs that you create for authoring components. Dialogs have the following node structure:
dialog
   |- items
      |- widget0
      |- widget1
You can store widget data in the workflow payload or in the work item metadata. The format of the name property of the widget node determines where the data is stored.

Store Data with the Payload
To store widget data as a property of the workflow payload, use the following format for the value of the name property of the cq:Widget node:
“./jcr:content/nodename”
The data is stored in the “nodename” property of the payload node. If the node does not contain that property, the property is created.
When stored with the payload, subsequent uses of the dialog with the same payload overwrites the value of the property.
Store Data with the Work Item
To store widget data as a property of the work item metadata, use the following format for the value of the name property:
“Nodename”
Configuring the Dialog Participant Step
Path to store dialog participant step value , /etc/workflow/dialogs/
In addition to the same properties of the Participant Step, the Dialog Participant Step includes the Dialog Path property. The value of the Dialog Path property is the path to the cq:Dialog node of you dialog.
The dialog of the previous example is contained in a component named EmailWatch that is stored in the /etc/workflows/dialogs node. The following value is used for the Dialog Path property:
/etc/workflow/dialogs/EmailWatch/dialog
Dynamic Participant Step

The Dynamic Participant Step component is similar to Participant Step except the participant is selected automatically at run time. To configure the step, you select a participant chooser that identifies the participant to assign the work item.
Developing the participant chooser
Create an OSGi service or an ECMA script that selects a user to assign the work item.
ECMA script
Scripts must include a function named getParticipant that returns a user ID as a String value. Store the script in the /etc/workflow/scripts folder, or a subfolder.
OSGi service
Services must implement the com.day.cq.workflow.exec.ParticipantStepChooser interface. The interface defines the following members:
•	SERVICE_PROPERTY_LABEL field: Use this field to specify the name of the participant chooser. The name appears in a list of available participant choosers in the Dynamic Participant Step properties.
•	getParticipant method: Returns the user ID as a String value.

Process Step
A process step executes an ECMA script or calls an OSGi service to perform automatic processing.
Process step component consist of three fields,
Process
The process implementation to execute. Use the drop-down menu to select the ECMA script or OSGi service that are available
Handler Advance
Select this option to automatically advance the workflow to the next step after execution. If no selected, the implementation script must handle workflow advancement.
Arguments
Arguments to be passed to the process.

Container Step
A container step starts another workflow model that executes as a child workflow.
This container can allow you to reuse workflow models to implement common sequences of steps. For example, a translation workflow model could be used in multiple editing workflows.

The following properties are available:
Sub Workflow
Select the workflow to start.

AND Split
An AND Split creates a split in the workflow; both branches will be active. This component enables you to introduce multiple processing paths into the workflow. 
Create a split in the workflow, whereby only one branch is active. This allows you to introduce conditional processing paths into your workflow.
Script Path
The path to a file that contains the script.
Script
Add the script in the box.
Default Route
The default branch is followed when no script is defined for any branches in the split, or neither are fulfilled. You can specify only one branch as the default


AEM Built-in process steps:

For each process step, the following common characteristics are described:
Java class or ECMAScript path: Process steps are defined either by a Java class or an ECMAscript. For the Java class processes, the fully qualified class name is provided. For the ECMAscript processes the path to the script is provided.

Payload: The payload is the entity upon which a workflow instance acts. The payload is selected impicitly by the context within which a workflow instance is started.
A JCR Node payload is passed as a string that is either a JCR path or a JCR identifier (UUID)
Arguments: Some workflow processes accept arguments, which the administrator specifies when setting up the workflow step. Arguments are entered as a single string in the Process Arguments property in the Properties pane of the workflow editor (see image above). For each process described below, the format of the argument string is described in a simple EBNF grammar
Timeout: The administrator can set a timeout after which the workflow step is no longer operational. Some workflow processes respect the timeout, while for others it does not apply and is ignored.

Workflow Control Processes
The following processes do not perform any actions on content. They serve to control the behavior of the workflow itself:
AutoAdvancer
This process automatically advances the workflow to the next step. If there is more than one possible next step (for example, if there is an OR split) then this process will advance the workflow along the default route, if one has been specified, otherwise the workflow will not be advanced.
Java Class: com.day.cq.workflow.timeout.autoadvance.AutoAdvancer
Payload: None.
Arguments: None.
Timeout: Process times out after set length of time.
AbsoluteTimeAutoAdvancer
This process behaves identically to AutoAdvancer, above, except that it times out after a given time and date, instead of after a given length of time.
Java Class: com.day.cq.workflow.timeout.autoadvance.AbsoluteTimeAutoAdvancer
Payload: None.
Arguments: None.
Timeout: Process times out when set time and date is reached.
Basic Processes
The following processes perform simple tasks or serve as examples.
noop
This is the null process. It performs no operation but does log a debug message.
ECMAScript path: /etc/workflow/scripts/noop.ecma
Payload: None.
Arguments: None.
Timeout: Ignored.
sample
This is a sample ECMAScript process.
ECMAScript path: /etc/workflow/scripts/sample.ecma
Payload: None.
Arguments: None.
Timeout: Ignored.
Delete Node
The item at the given path is deleted.
ECMAScript path: /etc/workflow/scripts/delete.ecma
Payload: JCR path.
Arguments: None.
Timeout: Ignored.
Lock Payload Process
Locks the payload of the workflow. The step has no effect under the following circumstances:
•	The payload is already locked.
•	The payload node does not contain a jcr:content child node.
Java class: com.day.cq.workflow.impl.process.LockProcess
Payload: JCR_PATH and JCR_UUID 
Arguments: None
Timeout: Ignored
Unlock Payload Process
Unlocks the payload of the workflow. The step has no effect under the following circumstances:
•	The payload is already unlocked.
•	The payload node does not contain a jcr:content child node.
Java class: com.day.cq.workflow.impl.process.UnlockProcess
Payload: JCR_PATH and JCR_UUID 
Arguments: None
Timeout: Ignored

WCM Processes
The following processes perform WCM-related tasks.
ActivatePageProcess
This process activates the payload. The process first checks access control. In case the session starting the process is lacking the privilege to replicate, a “request for activation” workflow event is sent out. Listeners to this event may then handle this situation.
Java class: com.day.cq.wcm.workflow.process.ActivatePageProcess
Payload: A JCR path or UUID.
Arguments: None.
Timeout: Ignored.
Reverse Replicate Content
Generates an event that causes the reverse replication of the workflow payload. The replication action type is ACTIVATE.
Java class: com.day.cq.wcm.workflow.process.ReverseReplicateProcess
Payload: A JCR path or UUID. 
Arguments:
•	Replicate As Participant: Select this option to perform the reverse replication using the context of the most recent participant of the workflow. If no participant is found from the steps that executed previously in the workflow instance, the context of the admin user is used. When this option is not selected, the context of the admin user is used. 
Timeout: Ignored
DeactivatePageProcess
This process deactivates the payload. The process first checks access control. In case the session starting the process is lacking the privilege to replicate, a “request for deactivation” workflow event is sent out. Listeners to this event may then handle this situation.
Java class: com.day.cq.wcm.workflow.process.DeactivatePageProcess
Payload: A JCR path or UUID.
Arguments: None.
Timeout: Ignored.
Versioning Processes
The following process performs a version-related task.
CreateVersionProcess
Creates a new version of the workflow payload (AEM page or DAM asset).
Java class: com.day.cq.wcm.workflow.process.CreateVersionProcess
Payload: A JCR path or UUID that refers to a page or DAM asset.
Arguments: None.
Timeout: Respected.

DAM Processes
The following processes perform DAM-related tasks.
AssetSetLastModifiedProcess
Java class: com.day.cq.dam.core.process.AssetSetLastModifiedProcess
Payload: A JCR path. The node at the path location must be either of node type dam:Asset or be in the subtree of a dam:Asset.
Arguments: Optional. If present, specifies addtional properties to update.
CreateSubAssetsProcess
This process creates subassets for the payload asset. For example, makes each single page from PDF asset into a distinct subasset of that PDF.
Java class: com.day.cq.dam.core.process.CreateSubAssetsProcess
Payload:The JCR path of a dam:Asset or a node within the subtree of a dam:Asset.
Arguments: None.
Timeout: Respected.
DeleteAssetProcess
Deletes the asset in the /content/dam subtree when its corresponding asset in /var/dam is deleted.
Java class: com.day.cq.dam.core.process.DeleteAssetProcess
Payload:The JCR path of a dam:Asset or a node within the subtree of a dam:Asset.
Arguments: None.
Timeout: Respected.
ExtractMetadataProcess
Reads the metadata of the payload asset and and stores it along with the asset (in a node called metadata below the jcr:content node of the dam:Asset).
Java class: com.day.cq.dam.core.process.ExtractMetadataProcess
Payload:The JCR path of a dam:Asset or a node within the subtree of a dam:Asset.
Arguments: None.
Timeout: Respected.
Workflow Best Practices
Workflows enable you to automate Adobe Experience Manager (AEM) activities.
They often represent a large amount of the processing that occurs in an AEM environment, so when custom workflow steps are not written according to best practices, or out-of-the-box workflows are not configured to run as efficiently as possible, the system can suffer as a result. 
 It is therefore highly recommended to plan your workflows implementations carefully.
Configuration
When configuring workflow processes (customized and/or out-of-the-box), there are a few things that should be kept in mind.
Transient Workflows
To optimize high ingestion loads you can define a workflow as transient.
When a workflow is transient the runtime data related to the intermediate worksteps are not persisted in the JCR when they run (the output renditions are persisted of course).
The advantages can include:
•	A reduction in the workflow processing time; of upto 10%.
•	Significantly reduce repository growth.
•	No more CRUD workflows are required to purge.
•	In addition, it reduces the number of TAR files to compact. 
•	Caution:
•	If your business dictates that you persist/archive workflow runtime data for audit purposes, do not enable this feature. 
Creating a Transient Workflow
You can create a Transient workflow model when creating a new model, or by editing an existing one:
1.	Create and/or edit the workflow model according to the UI you are using.
2.	Select the Page tab of sidekick, followed by Page Properties... to open the dialog.
3.	In the dialog activate Transient Workflow (or deactivate if required):
 
1.	Click OK to save this setting, followed by Save (editor toolbar) to save the updates to the workflow model.

DAM Media Handlers
CQ5 DAM comes with a set of default workflows and media handlers to process assets. The workflow defines the general tasks to be executed on the assets, then delegates the specific tasks to the media handlers, for example thumbnail generation or metadata extraction.
Media handlers are services inside CQ5 DAM that perform specific actions on assets. For example, when an MP3 audio file is uploaded into CQ5, a workflow triggers an MP3 handler that extracts the metadata and generates a thumbnail. Media handlers are usually used in combination with workflows.

All the handlers perform the following tasks:
•	extracting all available metadata from the asset.
•	creating a thumbnail image out of the asset.
It is possible to view the active media handlers:
1.	In your browser, navigate to http://<host>:<port>/system/console/components.
2.	Click the link com.day.cq.dam.core.impl.store.AssetStoreImpl.
3.	A list with all the active media handlers is displayed
Using Media Handlers in Workflows to perform tasks on Assets
Media handlers are services that are usually used in combination with workflows.
CQ5 has some default workflows to process assets. To view them, open the Workflow console and click the Models tab: the workflow titles that start with DAM are the assets specific ones.
Existing workflows can be extended and new ones can be created to process assets according to specific requirements.
Disabling/Enabling a Media Handler
The media handlers can be disabled or enabled through the Apache Felix Web Management Console. When the media handler is disabled, its tasks are not performed on the assets.

Creating a new Media Handler
To support a new media type or to execute specific tasks on an asset, it is necessary to create a new media handler. This section describes how to proceed.
The best way to start an implementation is to inherit from a provided abstract implementation that takes care of most things and provides reasonable default behaviour: the com.day.cq.dam.core.AbstractAssetHandler Class.
This class already provides an abstract service descriptor. So if you inherit from this class and use the maven-sling-plugin, make sure that you set the inherit flag to true.
The following methods need to be implemented:
•	extractMetadata(): this method extracts all available metadata.
•	getThumbnailImage(): this method creates a thumbnail image out of the passed asset.
•	getMimeTypes(): this method returns the asset mime type(s).

com.day.cq.dam.api.handler.AssetHandler Interface
•	This interface describes the service which adds support for specific mime types. Adding a new mime type requires to implement this interface. The interface contains methods for importing and exporting the specific documents, for creating thumbnails and extracting metadata.
com.day.cq.dam.core.AbstractAssetHandler Class
•	This class serves as basis for all other asset handler implementations and provides common used functionality.
The following methods need to be implemented:
•	extractMetadata(): this method extracts all available metadata.
•	getThumbnailImage(): this method creates a thumbnail image out of the passed asset.
•	getMimeTypes(): this method returns the asset mime type(s).

Steps to develop custom asset handler.
1.	Create a class named MyHandler that extends AbstractAssetHandler.
2.	To ensure that your custom DAM media handler is called, and not the default ones that are available with AEM, you can use Constants.SERVICE_RANKING value. Set the intValue value to an integer value. The priority is given to the higher value 
3.	Since,  MyHandler extends AbstractAssetHandler, create a method named extractMetadata. 
This method is invoked by the ExtractMetadataProcess, which is part of the DAM Update Asset workflow during import or update of a digital asset.
 
4.	A method named extractMetadata , returns com.day.cq.dam.api.metadata.ExtractedMetadata object which may be empty if no metadata is extracted, or contains the metadata values extracted from the binary being imported/updated at the time. 
5.	The parameter that is passed to the extractMetadata method is a com.day.cq.dam.api.Asset object. This value represents the digital asset that is uploaded to the AEM DAM. 
6.	To extract metadata, convert the Asset to a Node, invoke the getInputStream method, and pass the Node, as shown in the following code. 
7.	Once you have an InputStream object that represents the uploaded digital asset, you can perform various tasks. 
8.	To determine what type of digital asset your DAM media handler responds to, define the getMimeTypes method.

Event Handling in CQ
Event handling can be done in a lot of different ways within CQ, that all have their cost, their impact, and their benefits.
5 ways of doing so are detailed here :
– At the JCR level with observation
– At the Sling level with event handlers and jobs
– At the CQ level with workflows & launchers
– Particular case of scheduled events
– Particular case of POST to the repository
JCR Observer 
is the lowest-level event handling in CQ. As its name indicates it, is at JCR level and allows to listen to JCR-level events, gathered in sets (corresponding to persistence transactions). javax.jcr.observation.Event lists following types:
·       Event.NODE_ADDED
·       Event.NODE_MOVED
·       Event.NODE_REMOVED
·       Event.PERSIST
·       Event.PROPERTY_ADDED
·       Event.PROPERTY_CHANGED
·       Event.PROPERTY_REMOVED
In order to listen to such an event, you have to:
·       Manage a live session through which you will listen to the repository
·       Decide how and when you listen to it.
·       Implement the handler that receive all JCR events filtered by your definition.

Steps,
Create a class which implements EventListener interface.
You use an ObservationManager instance to define the characteristics of the event handler. Allows for the registration and deregistration of event listeners.

addEventListener(EventListener listener, int eventTypes, java.lang.String absPath, boolean isDeep, java.lang.String[] uuid, java.lang.String[] nodeTypeName, boolean noLocal)

Adds an event listener that listens for the specified eventTypes (a combination of one or more event types encoded as a bit mask value).
The set of events can be filtered by specifying restrictions based on characteristics of the node associated with the event. In the case of event types NODE_ADDED and NODE_REMOVED, the node associated with an event is the node at (or formerly at) the path returned by Event.getPath. In the case of event types PROPERTY_ADDED, PROPERTY_REMOVED and PROPERTY_CHANGED, the node associated with an event is the parent node of the property at (or formerly at) the path returned by Event.getPath
absPath, isDeep: Only events whose associated node is at absPath (or within its subtree, if isDeep is true) will be received. It is permissible to register a listener for a path where no node currently exists.
uuid: Only events whose associated node has one of the UUIDs in this list will be received. If his parameter is null then no UUID-related restriction is placed on events received.
nodeTypeName: Only events whose associated node has one of the node types (or a subtype of one of the node types) in this list will be received. If his parameter is null then no node type-related restriction is placed on events received.

if noLocal is true, then events generated by the session through which the listener was registered are ignored. Otherwise, they are not ignored.

addEventListener(
      this, //handler
      Event.PROPERTY_ADDED|Event.NODE_ADDED, //binary combination of event types
      "/apps/example", //path
      true, //is Deep?
      null, //uuids filter
      null, //nodetypes filter
      false);


When the event occurs, the event handler invokes the onEvent method. This method must be part of the event handler class because the class implements EventListener.

Application level event sending
@Reference
EventAdmin eventAdmin;
public void createExample(…) throws RepositoryException {
 ...
 final Dictionary<String,Object> properties = new Hashtable();
 properties.put(Example.PN_NAME, name);
 properties.put(Example.PN_DESC,description);
 Event event = new Event(Example.EVENT_TOPIC, properties);
 eventAdmin.postEvent(event);


Note here that eventAdmin.postEvent is the asynchronous sending, you can synchronously send your event by using sendEvent API (with the performance risks it can imply).

Handler
This handler is listening to the kind of event above, plus Replication events
@Component
@Service
@Property(name="event.topics",value= {ReplicationAction.EVENT_TOPIC, Example.EVENT_TOPIC})
public class ExampleEventHandler implements EventHandler {
 Logger log = LoggerFactory.getLogger(this.getClass());
 public void handleEvent(Event event) {
  if (event.getTopic().equals(Example.EVENT_TOPIC)){
   log.info("Example {}, with description {} has been created...",event.getProperty(Example.PN_NAME),event.getProperty(Example.PN_DESC));
  } else if (event.getTopic().equals(ReplicationAction.EVENT_TOPIC)){
   ReplicationAction action = ReplicationAction.fromEvent(event);
   log.info("User {} has tried to replicate {}",action.getUserId(),action.getPath());
  }
 }
}

finally, you can be in the situation where your application wants the guarantee of having its event processed. This is the job use case, in which you will use JobUtil and JobProcessor.
Note that often your listener can be also a JobProcessor, like following :
public void handleEvent(org.osgi.service.event.Event event) {
 if (EventUtil.isLocal(event)) {
  JobUtil.processJob(event, this);
 }
}


CQ topics you can listen to :
Synchronous:
·       ForumEvent.Type.TopicAdded
·       ForumEvent.Type.PostAdded
Asynchronous:
·       Page Events (MSM, CRUD, …) with PageEvent.EVENT_TOPIC and PageEvent.fromEvent API
·       Replication event with ReplicationAction.EVENT_TOPIC and ReplicationAction API
·       Workflow event (you should look following section)



Apache Sling Eventing and Job Handling


A job consists of two parts, the job topic describing the nature of the job and the payload which is a key value map of serializable objects. A client can initiate a job by calling the JobManager.addJob method

@Reference
        private JobManager jobManager;

public void startJob() {
	
final Map<String, Object> props = new HashMap<String, Object>();
            props.put("item1", "/something");
            props.put("count", 5);

            jobManager.addJob("my/special/jobtopic", props);
        }        
    }





All objects in the payload must be serializable and publically available (exported by a bundle). This is required as the job is persisted and unmarshalled before processing.


JobBuilder
Instead of creating the jobs by calling JobManager.addJob("my/special/jobtopic", props);
JobBuilder can be used, which is retrieved via JobManager.createJob("my/special/jobtopic")



Scheduled Jobs
Scheduled Jobs are put in the queue at a specific time (optionally periodically). For that the ScheduleBuilder must be used which is retrieved via JobBuilder.schedule().

@Reference
    private JobManager jobManager;

public void startScheduledJob() {
        ScheduleBuilder scheduleBuilder = jobManager.startJob("my/special/jobtopic").schedule();
        scheduleBuilder.daily(0,0); // execute daily at midnight
        if (scheduleBuilder.add() == null) {
            // something went wrong here, use scheduleBuilder.add(List<String>) instead to get further information about the error
        }
    }



Internally the scheduled Jobs use the Commons Scheduler Service. But in addition they are persisted (by default below /var/eventing/scheduled-jobs) and survive therefore even server restarts. When the scheduled time is reached, the job is automatically added as regular Sling Job through the JobManager.


Job Consumers
A job consumer is a service consuming and processing a job. It registers itself as an OSGi service together with a property defining which topics this consumer can process:
@Component
    @Service(value={JobConsumer.class})
    @Property(name=JobConsumer.PROPERTY_TOPICS, value="my/special/jobtopic",)
    public class MyJobConsumer implements JobConsumer {

        public JobResult process(final Job job) {
            // process the job and return the result
            return JobResult.OK;
        }
    }

The Job interface allows to query the topic, the payload and additional information about the current job. The consumer can either return JobResult.OK indicating that the job has been processed, JobResult.FAILED indicating the processing failed, but can be retried or JobResult.CANCEL the processing has failed permanently.


Job Handling
New jobs are first persisted in the resource tree (for failover etc.), then the job is distributed to an instance responsible for processing the job and on that instance the job is put into a processing queue. There are different types of queues defining how the jobs are processed (one after the other, in parallel etc.).
For managing queues, the Sling Job Handler uses the OSGi ConfigAdmin - it is possible to configure one or more queue configurations through the ConfigAdmin. One way of creating and configuring such configurations is the Apache Felix WebConsole. If there is no specific queue configuration maintained for the given job topic, the Sling Job Handler falls back to using the Apache Sling Job Default Queue (which can be configured through OSGi as well).


Job Distributing
For job distribution (= distributing the processing in a cluster), the job handling uses the topology feature from Sling - each instance in the topology announces the set of topics (consumers) it currently has - and this defines the job capabilities, a mapping from an instance to the topics it can process.
When a job is scheduled, the job manager uses these capabilities to find out the set of instances which is able to process the request. If the queue type is ordered then all jobs are processed by the leader of this set. For parallel queues, the jobs are distributed equally amongst those instance.
Failover is handled by the leader: if an instance dies, the leader will detect this through the topology framework and then redistribute jobs from the dead instance to the available instances. Of course this takes a leader change into account as well. In addition if the job capabilities change and this require a reschedule of jobs, that's done by the leader as well.




Scheduler
Scheduling with a cron expression
Service(value = Runnable.class)
@Property( name = "scheduler.expression", value = "0 * * * * ?")

public class ScheduledCronJob implements Runnable {

public void run() {}
}

Scheduling at periodic times
@Service(value = Runnable.class)
@Property( name = "scheduler.period", longValue = 10)
public class ScheduledPeriodicJob implements Runnable {
public void run() {}
}



Preventing concurrent execution
@Property(name="scheduler.concurrent", boolValue=false)





Scheduled jobs registered through the scheduler API

Defining the job
The following code sample defines a job object that writes a message in the logs:
final Runnable job = new Runnable() {
    public void run() {
        log.info("Executing the job");
    }
};


Scheduling with a cron expression
To execute the job as defined above at 10:15am every Monday, Tuesday, Wednesday, Thursday and Friday, you can use the addJob() method with the following parameters:
String schedulingExpression = "0 15 10 ? * MON-FRI";
this.scheduler.addJob("myJob", job, null, schedulingExpression, true);


Scheduling at periodic times
To execute the job as defined above every 3 minutes (180 seconds), you can use the addPeriodicJob() method with the following parameters:
long period = 3*60; //the period is expressed in seconds
this.scheduler.addPeriodicJob("myJob", job, null, period, true);


Scheduling at periodic times
To execute the job as defined above every 3 minutes (180 seconds), you can use the addPeriodicJob() method with the following parameters:
long period = 3*60; //the period is expressed in seconds
this.scheduler.addPeriodicJob("myJob", job, null, period, true);	







Dispatcher
The Dispatcher contains mechanisms to generate, and update, static HTML based on the content of the dynamic site. You can specify in detail which documents are stored as static files and which are always generated dynamically.
The Dispatcher helps realize an environment that is both fast and dynamic. It works as part of a static HTML server, such as Apache, with the aim of:
•	storing (or "caching") as much of the site content as is possible, in the form of a static website
•	accessing the layout engine as little as possible.
Which means that:
•	static content is handled with exactly the same speed and ease as on a static web server; additionally you can use the administration and security tools available for your static web server(s).
•	dynamic content is generated as needed, without slowing the system down any more than absolutely necessary.
Static pages are created once, so the same content will be delivered for each request.
This process is very simple, and thus extremely efficient. If a visitor requests a file (e.g. a HTML page), the file is usually taken directly from memory, at worst it is read from the local drive
How Dispatcher performs Caching
The Cache Directory  For caching, the Dispatcher module uses the web server's ability to serve static content. The Dispatcher places the cached documents in the document root of the web server.
Methods for Caching
The Dispatcher has two primary methods for updating the cache content when changes are made to the website.
•	Content Updates remove the pages that have changed, as well as files that are directly associated with them.
•	Auto-Invalidation automatically invalidates those parts of the cache that may be out of date after an update. i.e. it effectively flags relevant pages as being out of date, without deleting anything.

Content Updates
In a content update, one or more AEM documents change. AEM sends a syndication request to the Dispatcher, which updates the cache accordingly:
1.	It deletes the modified file(s) from the cache.
2.	It deletes all files that start with the same handle from the cache. For example, if the file /en/index.html is updated, all the files that start with /en/index. are deleted. This mechanism allows you to design cache-efficient sites, especially in regard to picture navigations.
3.	It touches the so-called statfile; this updates the timestamp of the statfile to indicate the date of the last change. 

The following points should be noted:
•	Content Updates are typically used in conjunction with an authoring system which "knows" what must be replaced.
•	Files that are affected by a content update are removed, but not replaced immediately. The next time such a file is requested, the Dispatcher fetches the new file from the AEM instance and places it in the cache, thereby overwriting the old content.
•	Typically, automatically generated pictures that incorporate text from a page are stored in picture files starting with the same handle - thus ensuring that the association exists for deletion. For example, you may store the title text of the page mypage.html as the picture mypage.titlePicture.gif in the same folder. This way the picture is automatically deleted from the cache each time the page is updated, so you can be sure that the picture always reflects the current version of the page.
•	You may have several statfiles, for example one per language folder. If a page is updated, AEM looks for the next parent folder containing a statfile, and touches that file.

Auto-invalidation
Auto-invalidation automatically invalidates parts of the cache - without physically deleting any files. At every content update, the so-called statfile is touched, so its timestamp reflects the last content update.
The Dispatcher has a list of files that are subject to auto-invalidation. When a document from that list is requested, the Dispatcher compares the date of the cached document with the timestamp of the statfile:
•	if the cached document is newer, the Dispatcher returns it.
•	if it is older, the Dispatcher retrieves the current version from the AEM instance.

Again, certain points should be noted:
•	Auto invalidation is typically used when the inter-relations are complex e.g. for HTML pages. These pages contain links and navigation entries, so they usually have to be updated after a content update. If you have automatically generated PDF or picture files, you may choose to auto-invalidate those too.
•	Auto-invalidation does not involve any action by the dispatcher at update time, except for touching the statfile. However, touching the statfile automatically renders the cache content obsolete, without physically removing it from the cache.
How Dispatcher returns Documents 
Determining whether a document is subject to caching
1.	Document request to dispatcher. The Dispatcher checks the request against the list of cacheable documents. If the document is not in this list, the Dispatcher requests the document from the AEM instance.
The Dispatcher always requests the document directly from the AEM instance in the following cases:
•	If the HTTP method is not GET. Other common methods are POST for form data and HEAD for the HTTP header.
•	If the request URI contains a question mark "?". This usually indicates a dynamic page, such as a search result, which does not need to be cached.
•	The file extension is missing. The web server needs the extension to determine the document type (the MIME-type).
•	The authentication header is set (this can be configured)

Determining if a document is cached
The Dispatcher stores the cached files on the web server as if they were part of a static website. If a user requests a cacheable document, the Dispatcher checks whether that document exists in the web server's file system:
•	if the document is cached, Dispatcher returns the file.
•	if it is not cached, the Dispatcher requests the document from the AEM instance.

Determining if a document is up-to-date
To find out if a document is up to date, the Dispatcher performs two steps:
1.	It checks whether the document is subject to auto-invalidation. If not, the document is considered up-to-date.
2.	If the document is configured for auto-invalidation, the Dispatcher checks whether it is older or newer than the last change available. If it is older, the Dispatcher requests the current version from the AEM instance and replaces the version in the cache.
The Benefits of Load Balancing
Load Balancing is the practice of distributing the computational load of the website across several instances of AEM.
You gain:
•	increased processing power

In practice this means that the Dispatcher shares document requests between several instances of AEM. Because each instance now has fewer documents to process, you have faster response times. The Dispatcher keeps internal statistics for each document category, so it can estimate the load and distribute the queries efficiently.
•	increased fail-safe coverage
If the Dispatcher does not receive responses from an instance, it will automatically relay requests to one of the other instance(s). Thus, if an instance becomes unavailable, the only effect is a slowdown of the site, proportionate to the computational power lost. However, all services will continue.
•	you can also manage different websites on the same static web server.
How the Dispatcher performs Load Balancing?
Performance Statistics
The Dispatcher keeps internal statistics about how fast each instance of AEM processes documents. Based on this data, the Dispatcher estimates which instance will provide the quickest response time when answering a request, and so it reserves the necessary computation time on that instance.
Different types of requests may have differing average completion times, so the Dispatcher allows you to specify document categories. These are then considered when computing the time estimates. For example, you can make a distinction between HTML pages and images, as the typical response times may well differ.
If you use an elaborate search function, you may create a new category for search queries. This helps the Dispatcher send search queries to the instance that responds fastest. This prevents a slower instance from stalling when it receives several "expensive" search queries, while the others get the "cheaper" requests.
Personalized content (Sticky Connections)
Sticky connections ensure that documents for one user are all composed on the same instance of AEM. This is important if you use personalized pages and session data. The data is stored on the instance, so subsequent requests from the same user must return to that instance or the data is lost.
Because sticky connections restrict the Dispatcher's ability to optimize the requests, you should use them only when needed. You can specify the folder that contains the "sticky" documents, thus ensuring all documents in that folder are composed on the same instance for each user.


Using Dispatcher with a CDN
A content delivery network (CDN), such as Akamai Edge Delivery or Amazon Cloud Front, deliver content from a location close to the end user. By that it
•	speeds up response times for end users
•	takes load off your servers 
As an HTTP infrastructure component, a CDN works much like Dispatcher: when a CDN node receives a request, it serves the request from its cache if possible (the resource is available in the cache and is valid). Otherwise, it reaches out to the next closest server to retrieve the resource and cache it for further requests if appropriate.
The "next closest server" depends on your specific setup.

Controlling a CDN cache
There are a number of ways to control for how long a CDN will cache a resource before it re-fetches is from Dispatcher.
1.	Explicit configuration
Configure, how long particular resources are held in the CDN's cache, depending on mime type, extension, request type, etc.
2.	Expiration and cache-control headers
Most CDNs will honor Expires: and Cache-Control: HTTP Headers if sent by the upstream server. This can be achieved e.g. by using the mod_expires Apache Module.
3.	Manual invalidation
CDNs allow resources to be removed from the cache through web interfaces.
4.	API based invalidation
Most CDNs also offer a REST and/or SOAP API that allows resources to be removed from the cache.


Installing dispatcher with MS IIS –
1.	Obtain the latest Dispatcher installation file for your operating system and web server.
2.	The following file naming convention is used for dispatcher : dispatcher-<web-server>-<operating-system>-<dispatcher-version-number>.<file-format>
Each archive contains the following files:
3.	the Dispatcher modules
4.	an example configuration file
5.	the README file that contains installation instructions and last-minute information
6.	the CHANGES file that lists issues fixed in current and past releases  
The ZIP file contains the following files:
File	 Description
 disp_iis.dll	The Dispatcher dynamic link library file.
 disp_iis.ini	Configuration file for the IIS. This example can be updated with your requirements.
NOTE: The ini file must have the same name-root as the dll.
 dispatcher.any	An example configuration file for the Dispatcher.
author_dispatcher.any	An example configuration file for Dispatcher working with the author instance.
README	Readme file that contains installation instructions and last-minute information.
Note: Please check this file before starting the installation. 
CHANGES	Changes file that lists issues fixed in current and past releases.


Use the following procedure to copy the Dispatcher files to the correct location.
1.	Use Windows Explorer to create the <IIS_INSTALLDIR>/Scripts directory,
for example, C:\inetpub\Scripts.
2.	Extract the following files from the Dispatcher package into this Scripts directory:
o	disp_iis.dll
o	disp_iis.ini
o	One of the following files depending on if Dispatcher is working with an AEM author instance or publish instance:
	Author intance: author_dispatcher.any
	Publish instance: dispatcher.any
Microsoft IIS - Configure the Dispatcher INI File
Edit the disp_iis.ini file to configure the Dispatcher intallation. The basic format of the .ini file is as follows:
[main]
configpath=<path to dispatcher.any>
logfile 	The location of the dispatcher.log file.  If this is not set then log messages go to the windows event log.
loglevel=1|2|3
servervariables=0|1
replaceauthorization=0|1


The following table describes each property.
Parameter	Description
configpath	The location of dispatcher.any within the local file system (absolute path).
logfile	The location of the dispatcher.log file.  If this is not set then log messages go to the windows event log.
loglevel	Defines the Log Level used to output messages to the event log. The following values may be specified:
0: error messages only.
1: errors and warnings.
2: errors, warnings and informational messages.
3: errors, warnings, informational and debug messages.

Note: It is recommended to set the log level to 3 during installation and testing, then revert to 0 when running in a production environment.
replaceauthorization	Specifies how authorization headers in the HTTP request are handled. The following values are valid:
0: Authorization headers are not modified.
1: Replaces any header named "Authorization" other than "Basic" with its "Basic <IIS:LOGON_USER>" equivalent.
servervariables	Defines how server variables are processed.
0: IIS server variables are sent to neither the Dispatcher nor AEM.
1: all IIS server variables (such as LOGON_USER, QUERY_STRING, ...) are sent to the Dispatcher, together with the request headers (and also to the AEM instance if not cached).

Server variables include AUTH_USER, LOGON_USER, HTTPS_KEYSIZE and many others. See the IIS documentation for the full list of variables, with details.


To add dispatcher to list of ISAPI filter. Perform following task:

Configure the Virtual Directory:
1.	Open Administrative Tools, then select Internet Information Services (IIS) Manager.
2.	Select your site in the tree, then using the context menu (usually right mouse click) select Add Virtual Directory....
3.	Enter the alias Scripts and the physical path of the directory created above (C:\Inetpub\Scripts).
Register the ISAPI filter:
1.	Open Administrative Tools, then select Internet Information Services (IIS) Manager.
2.	Select your site in the tree, then the tab Features View (at the bottom).
3.	Open the feature ISAPI Filters in the view.
4.	Click Add... and enter the following settings:
o	Filter Name: CQ
o	Executable: the path to disp_iis.dll (C:\Inetpub\Scripts)
5.	Click OK to save.

Register the ISAPI handler:
1.	Open Administrative Tools, then select Internet Information Services (IIS) Manager.
2.	Select your site in the tree, then the tab Features View (at the bottom).
3.	Open the feature Handler Mappings in the view.
4.	Click Add Script Map... and enter the following settings:
o	Request Path: /Scripts/disp_iis.dll
o	Executable: the path to disp_iis.dll (C:\Inetpub\Scripts)
o	Name: CQ
5.	Click OK to save.
6.	Open the feature Configuration Editor.
7.	Select the section system.webServer\handlers from Application.config.
8.	Select the first Collection (at the top), then click on ... (at the far right).
9.	The Collection Editor will appear, select the handler CQ (at the top).
10.	Change the value of the allowPathInfo flag (at the bottom) to true.
11.	Close the Collection Editor and click Apply.

Register the .json extension:
1.	Open Administrative Tools, then select Internet Information Services (IIS) Manager.
2.	Select your site in the tree, then the tab Features View (at the bottom).
3.	Open the feature MIME Types in the view.
4.	Click Add... and enter the following settings:
o	File name extension: .json
o	MIME type: application/json
5.	Click OK to save.

Invalidating Cached Pages from AEM
Setting up AEM User Accounts
The default admin user account is used to authenticate the replication agents that are installed by default. You should create a dedicated user account for use with replication agents.
Invalidating Dispatcher Cache from the Authoring Environment
A replication agent on the AEM author instance sends a cache invalidation request to Dispatcher when a page is published. The request causes Dispatcher to eventually refresh the file in the cache as new content is published. Cache invalidation requests for a page are also generated for any aliases or vanity URLs that are configured in the page properties. 
Use the following procedure to configure a replication agent on the AEM author instance for invalidating the Dispatcher cache upon page activation:
1.	Open the AEM Tools console. (http://localhost:4502/miscadmin#/etc)
2.	Open the required replication agent below Tools/replication/Agents on author. You can use the Dispatcher Flush agent that is installed by default.
3.	Click Edit, and in the Settings tab ensure that Enabled is selected.
4.	On the Transport tab, enter the URI needed to access Dispatcher.
If you are using the standard Dispatcher Flush agent you will probably need to update the hostname and port; for example, http://<dispatcherHost>:<portApache>/dispatcher/invalidate.cache
5.	• Configure other parameters as required.
6.	• Click OK to activate the agent.
7.	Note: The agent for flushing dispatcher cache does not have to have a user name and password, but if configured they will be sent with basic authentication.

Invalidating Dispatcher Cache from a Publishing Instance
Under certain circumstances performance gains can be made by transferring cache management from the authoring environment to a publishing instance. It will then be the publishing environment (not the AEM authoring environment) that sends a cache invalidation request to Dispatcher when a published page is received.
Cache invalidation requests for a page are also generated for any aliases or vanity URLs that are configured in the page properties. 
Such circumstances include:
•	Preventing possible timing conflicts between Dispatcher and the publish instance (see Invalidating Dispatcher cache from the Authoring Environment).
•	The system includes several publishing instances that reside on high performance servers, and only one authoring instance.
Manually Invalidating the Dispatcher Cache
To invalidate (or flush) the Dispatcher cache without activating a page, you can issue an HTTP request to the dispatcher. For example, you can create an AEM application that enables administrators or other applications to flush the cache.
The HTTP request causes Dispatcher to delete specific files from the cache. Optionally, the Dispatcher then refreshes the cache with a new copy.
The HTTP request has the following form:
POST /dispatcher/invalidate.cache HTTP/1.1
CQ-Action: Activate
CQ-Handle: path-pattern
Content-Length: 0 
Dispatcher flushes (deletes) the cached files and folders that have names that match the value of the CQ-Handler header. For example, a CQ-Handle of /content/geomtrixx-outdoors/en matches the following items:
•	All files (of any file extension) named en in the geometrixx-outdoors directory
•	Any directory named "_jcr_content" below the en directory (which, if it exists, contains cached renderings of sub-nodes of the page)


All other files in the dispatcher cache (or up to a particular level, depending on the /statfileslevel setting) are invalidated by touching the .stat file. This file's last modification date is compared to the last modification date of a cached document and the document is re-fetched if the .stat file is newer.
Delete and recache files
Issue an HTTP request that causes Dispatcher to delete cached files, and immediately retrieve and recache the file. Delete and immediately re-cache files when web sites are likely to receive simultaneous client requests for the same page. Immediate recaching ensures that Dispatcher retrieves and caches the page only once, instead of once for each of the simultaneous client requests.
Note: Deleting and recaching fies should be performed on the publish instance only. When performed from the author instance, race conditions occur when attempts to recache resources occur before they haved been published. 
The HTTP request has the following form:
POST /dispatcher/invalidate.cache HTTP/1.1
CQ-Action: Activate 
Content-Type: text/plain
CQ-Handle: path-pattern
Content-Length: numchars in bodypage_path0
page_path1
...
page_pathn
The page paths to immediately recache are listed on separate lines in the message body. The value of CQ-Handle is the path of a page that invalidates the pages to recache. (See the /statfileslevel parameter of the Cache configuration item.) The following example HTTP request message deletes and recaches the /content/geometroxx-outdoors/en.html page:
POST /dispatcher/invalidate.cache HTTP/1.1
CQ-Action: Activate
Content-Type: text/plain 
CQ-Handle: /content/geometrixx-outdoors/en/men.html
Content-Length: 36
/content/geometrixx-outdoors/en.html


Configuring dispatcher. Any file:
By default, the Dispatcher configuration is stored in the dispatcher.any text file, though you can change the name and location of this file during installation.
The configuration file contains a series of single-valued or multi-valued properties that control the behavior of Dispatcher:
•	Property names are prefixed with a forward slash ("/").
•	Multi-valued properties enclose child items using braces ("{ }").

/name # name of the dispatcher
    / farm # each farm configures a set of (loadbalanced) renders
          /website   # first farm entry
               /clientheaders
       {
       # List of headers that are passed on
       }
         /virtualhosts
       {
       # List of URLs for this Web site
       }
        /sessionmanagement 
       {
       # settings for user authentification
       }
        /renders
        {
       # List of AEM instances that render the documents
       }
        /filter
       {
       # List of filters
       }
        /vanity-urls
       {
       # List of vanity URLs
       }
       /cache
       {
       # Cache configuration
                           /rules
                    {
                    # List of cachable documents
                    }
               /invalidate
                    {
                    # List of auto-invalidated documents
                    }
        }
       /statistics
         {
                     /categories
                        {
                   # The document categories that are used for load balancing estimates
                         }
         }

     /stickyConnectionsFor "/myFolder"
     /health_check
       {
       # Page gets contacted when an instance returns a 500
       }
     /retryDelay "1"
     /numberOfRetries "5"
     /unavailablePenalty "1"
     /failover "1"
     }
 }


You can include other files that contribute to the configuration:
•	If your configuration file is large you can split it into several smaller files (that are easier to manage) then include these. 
•	To include files that are generated automatically.
For example, to include the file myFarm.any in the /farms configuration use the following code:
1
2
3
4	/farms
  {
  $include "myFarm.any"
  }
Code samples are intended for illustration purposes only.
Use the asterisk ("*") as a wildcard to specify a range of files to include.
For example, if the files farm_1.any through to farm_5.any contain the configuration of farms one to five, you can include them as follows:
1
2
3
4	/farms
  {
  $include "farm_*.any"
  }


Naming the Dispatcher Instance - /name
Use the /name property to specify a unique name to identify your Dispatcher instance. The /name property is a top-level property in the configuration structure.

Specifying the HTTP Headers to Pass Through - /clientheaders
The /clientheaders property defines a list of HTTP headers that Dispatcher passes from the client HTTP request to the renderer (AEM instance).
By default, Dispatcher forwards the standard HTTP headers to the AEM instance. In some instances, you might want forward additional headers, or remove specific headers:
•	Add headers, such as custom headers, that your AEM instance expects in the HTTP request.
•	Remove headers, such as authentication headers, that are only relevant to the web server. 
For example, a Dispatcher instance that handles page activation requests for publish instances requires the PATH header in the /clientheaders section. The PATH header enables communication between the replication agent and the dispatcher. 
Identifying Virtual Hosts - /virtualhosts
The /virtualhosts property defines a list of all hostname/URI combinations that Dispatcher accepts for this farm. You can use the asterisk ("*") character as a wildcard. Values for the /virtualhosts property use the following format: [scheme]host[uri][*]
•	scheme: (Optional) Either http:// or https://.
•	host: The name or IP address of the host computer and the port number if necessary. (See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.23)
•	uri: (Optional) The path to the resources.
Dispatcher finds the best-matching virtual host value in the following manner:
•	The first-encountered virtual host that matches all three of the host, the scheme, and the uri of the request is used.
•	If no virtualhosts values has scheme and uri parts that both match the scheme and uri of the request, the first-encountered virtual host that matches the host of the request is used.

•	If no virtualhosts values have a host part that matches the host of the request, the topmost virtual host of the topmost farm is used.
Therefore, you should place your default virtual host at the top of the virtualhosts property in the topmost farm of your dispatcher.any file.
Example Virtual Host Resolution
The following example represents a snippet from a dispatcher.any file that defines two Dispatcher farms, and each farm defines a virtualhosts property. 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
	/farms
  {
  /myProducts 
    { 
    /virtualhosts
      {
      "www.mycompany.com"
      }
    /renders
      {
      /hostname "server1.myCompany.com"
      /port "80"
      }
    }
  /myCompany 
    { 
    /virtualhosts
      {
      "www.mycompany.com/products/*"
      }
    /renders
      {
      /hostname "server2.myCompany.com"
      /port "80"
      }
    }
  }
Code samples are intended for illustration purposes only.
Using this example, the following table shows the virtual hosts that are resolved for the given HTTP requests:
Request URL	Resolved virtual host
http://www.mycompany.com/products/gloves.html	www.mycompany.com/products/*
http://www.mycompany.com/about.html	www.mycompany.com
Enabling Secure Sessions - /sessionmanagement
Caution - /allowAuthorized must be set to "0" in the /cache section in order to enable this feature.

Create a secure session for access to the render farm so that users need to log in to access any page in the farm. After logging in, users can access all pages in the farm. The /sessionmanagement property is a subproperty of /farms.
/directory (mandatory)
The directory that stores the session information. If the directory does not exist, it is created.
/encode (optional)
How the session information is encoded? Use "md5" for encryption using the md5 algorithm, or "hex" for hexadecimal encoding. If you encrypt the session data, a user with access to the file system cannot read the session contents. The default is "md5".
/header (optional)
The name of the HTTP header or cookie that stores the authorization information. If you store the information in the http header, use HTTP:<header-name>. To store the information in a cookie, use Cookie:<header-name>. If you do not specify a value HTTP: authorization is used.
/timeout (optional)
The number of seconds until the session times out after it has been used last. If not specified "800" is used, so the session times out a little over 13 minutes after the last request of the user.
An example configuration looks as follows:
1
2
3
4
5
6
7	/sessionmanagement 
  { 
  /directory "/usr/local/apache/.sessions" 
  /encode "md5" 
  /header "HTTP:authorization" 
  /timeout "800" 
  }
Defining Page Renderers - /renders
The /renders property defines the URL to which Dispatcher sends requests to render a document.
/renders
  {
    /myFirstRenderer
      {
      /hostname "aem.myCompany.com"
      /port "4503"
      }
    /mySecondRenderer
      {
      /hostname "127.0.0.1"
      /port "4503"
      }
  }
/timeout
specifies the connection timeout accessing the AEM instance in milliseconds. The default is "0", causing the Dispatcher to wait indefinitely.
/receiveTimeout
specifies the time in milliseconds that a response is allowed to take. The default is "600000", causing Dispatcher to wait for 10 Minutes. A setting of "0" eliminates the timeout completely.
If the timeout is reached while parsing response headers, an HTTP Status of 504 (Bad Gateway) is returned. If the timeout is reached while the response body is read, the Dispatcher will return the incomplete response to the client but delete any cache file that might have been written.
/ipv4
Specifies whether Dispatcher uses the getaddrinfo function (for IPv6) or the gethostbyname function (for IPv4) for obtaining the IP address of the render. A value of 0 causes getaddrinfo to be used. A value of 1 causes gethostbyname to be used. The default value is 0.  
The getaddrinfo function returns a list of IP addresses. Dispatcher iterates the list of addresses until it establishes a TCP/IP connection. Therefore, the ipv4 property is important when the render hostname is associated with mutliple IP addresses and the host, in response to the getaddrinfo function, returns a list of IP addresses that are always in the same order. In this situation, you should use the gethostbyname function so that the IP address that Dispatcher connects with is randomized.
Amazon Elastic Load Balancing (ELB) is such a service that responds to getaddrinfo with a potentially same-ordered list of IP addresses.
Configuring Access to Content - /filter
Use the /filter section to specify the HTTP requests that Dispatcher accepts. All other requests are sent back to the web server with a 404 error code (page not found). 
If no /filter section exists, all requests are accepted.
The /filter section consist of a series of rules that either deny or allow access to content according to patterns in the request-line part of the HTTP request. You should use a whiltelist strategy for your /filter section:
•	First, deny access to everything.
•	Allow access to content as needed.
Defining a Filter
Each item in the /filter section includes a type and a pattern that is matched with a specific element of the request line or the entire request line. Each filter can contain the following items:
•	Type: The /type indicates whether to allow or deny access for the requests that match the pattern. The value can be either allow or deny. 
•	Element of the Request Line: Include /method, /url, /query, or /protocol and a pattern for filtering requests according to these specific parts of the request-line part of the HTTP request. Filtering on elements of the request line (rather than on the entire request line) is the preferred filter method.
•	glob Property: The /glob property is used to match with the entire request-line of the HTTP request.
The request-line Part of HTTP Requests
HTTP/1.1 defines the request-line as follows:
Method Request-URI HTTP-Version<CRLF>
The <CRLF> characters repesent a carriage return followed by a line feed. The following example is the request-line that is recieved when a client requests the en page of the Geometrixx-Outoors site:
GET /content/geometrixx-outdoors/en.html HTTP.1.1<CRLF>
Your patterns must take into account the space characters in the request-line and the <CRLF> characters.
Example Filter: Deny All
The following example filter section causes Dispatcher to deny requests for all files. You should deny access to all files and then allow access to specific areas. 
1	/0001  { /glob "*" /type "deny" }
Code samples are intended for illustration purposes only.
Requests to an explicitly denied area result in a 404 error code (page not found) being returned.
Example Filter: Deny Access to Specific Areas
Filters also allow you to deny access to various elements for example ASP pages and sensitive areas within a publish instance. The following filter denies access to ASP pages:
1	/0002  { /type "deny" /url "*.asp"  }
Code samples are intended for illustration purposes only.
Example Filter: Enable POST Requests
The following example filter allows submitting form data by the POST method:
1
2
3
4	/filter {
    /0001 { /glob "*" /type "deny" }
    /0002 { /type "allow" /method "POST" /url "/content/[.]*.form.html" }
}
Code samples are intended for illustration purposes only.
Example Filter: Allow Access to the Workflow Console
The following example shows a filter used to deny external access to the Workflow console:
1
2
3
4	/filter {
    /0001 {/glob "*" /type "deny" }
    /0002 {/type "allow" /url "/libs/cq/workflow/content/console*"  }
}
Code samples are intended for illustration purposes only.
If yours publish instance uses a web application context (for example publish) this can also be added to your filter definition.
1	/0003   { /type "deny"  /url "/publish/libs/cq/workflow/content/console/archive*"  }
Code samples are intended for illustration purposes only.
If you still need to access single pages within the restricted area, you can allow access to them. For example, to allow access to the Archive tab within the Workflow console add the following section:
1	/0004  { /type "allow"  /url "/libs/cq/workflow/content/console/archive*"   }
Example filter: Using Regular Expressions
This filter enables extensions in non-public content directories using a regular expression, defined here between single quotes:
1	/005  {  /type "allow" /extension '(css|gif|ico|js|png|swf|jpe?g)' }
Code samples are intended for illustration purposes only.
Example filter: Filter Additional Elements of a Request URL
One of the enhancements introduced in NPR-6365 is the ability to filter additional elements of the request URL. The new elements introduced are:
•	path
•	selectors
•	extension
•	suffix
These can be configured by adding the property of the same name to the filtering rule: /path, /selectors, /extension and /suffix respectively.
Below is a rule example that blocks content grabbing from the /content path, using filters for path, selectors and extensions:
1
2
3
4
5
6	/006 {
        /type "deny"
        /path "/content"
        /selectors '(feed|rss|pages|languages|blueprint|infinity|tidy)'
        /extension '(json|xml|html)'
        }
A single entry can have either glob or some combination of method,url,query and version but not both.
Enabling Access to Vanity URLs - /vanity_urls
Configure Dispatcher to enable access to vanity URLs that are configured for your CQ or AEM pages.
When access to vanity URLs is enabled, Dispatcher periodically calls a service that runs on the render instance to obtain a list of vanity URLs. Dispatcher stores this list in a local file. When a request for a page is denied due to a filter in the /filter section, Dispatcher consults the list of vanity URLs. If the denied URL is on the list, Dispatcher allows access to the vanity URL.
The /vanity_urls section contains the following properties:
•	/url: The path to the vanity URL service that runs on the render instance. The value of this property must be "/libs/granite/dispatcher/content/vanityUrls.html".
•	/file: The path to the local file where Dispatcher stores the list of vanity URLs. Make sure that Dispatcher has write-access to this file.
•	/delay: (Seconds) The time between calls to the vanity URL service. 

Forwarding Syndication Requests - /propagateSyndPost
Syndication requests are usually intended for Dispatcher only, so by default they are not sent to the renderer (for example, an AEM instance).
If necessary, set the /propagateSyndPost property to "1" to forward syndication requests to Dispatcher. If set, you must make sure that POST requests are not denied in the filter section.
 Configuring the Dispatcher Cache - /cache
The /cache section controls how Dispatcher caches documents. Configure several sub-properties to implement your caching strategies:
 
•	/docroot 
•	/statfile
•	/serveStaleOnError
•	/allowAuthorized
•	/rules
•	/statfileslevel 
•	/invalidate
•	/invalidateHandler
•	/allowedClients
•	/ignoreUrlParams
•	/headers
/cache
  {
  /docroot "/opt/dispatcher/cache"
  /statfile  "/tmp/dispatcher-website.stat"          
  /allowAuthorized "0"
       
  /rules
    {
    # List of files that are cached
    }
 
  /invalidate
    {
    # List of files that are auto-invalidated
    }
  }
Specifying the Cache Directory
The /docroot property identifies the directory where cached files are stored.
The value must be the exact same path as the document root of the web server so that Dispatcher and the web server handle the same files.
If you use multiple farms, each farm must use  a different document root.
Naming the Statfile
The /statfile property identifies the file to use as the statfile. Dispatcher uses this file to register the time of the most recent content update. The statfile can be any file on the web server.
The statfile has no content. When content is updated, Dispatcher updates the timestamp. The default statfile is named .stat and is stored in the docroot. Dispatcher blocks access to the statfile.

If /statfileslevel is configured, Dispatcher ignores the /statfile property and uses .stat as the name.

Caching When Authentication is Used
The /allowAuthorized property controls whether requests that contain any of the following authentication information are cached:
•	The authorization header.
•	A cookie named authorization.
•	A cookie named login-token.

By default, requests that include this authentication information are not cached because authentication is not performed when a cached document is returned to the client. This configuration prevents Dispatcher from serving cached documents to users who do not have the necessary rights.
To enable session management (using the /sessionmanagement property), the /allowAuthorized property must be set to "0".

Specifying the Documents to Cache
The /rules property controls which documents are cached according to the document path. Regardless of the /rules property, Dispatcher never caches a document in the following circumstances:
•	If the HTTP method is not GET.
Other common methods are POST for form data and HEAD for the HTTP header.
•	If the request URI contains a question mark ("?").
This usually indicates a dynamic page, such as a search result that does not need to be cached.
•	The file extension is missing.
The web server needs the extension to determine the document type (the MIME-type).
•	The authentication header is set (this can be configured)
•	If the AEM instance responds with the following headers: 
o	no-cache
o	no-store
o	must-revalidate
Each item in the /rules property includes a glob pattern and a type:
•	The glob pattern is used to match the path of the document.
•	The type indicates whether to cache the documents  that match the glob pattern. The value can be either allow (to cache the document) or deny (to always render the document).  
•	/rules
•	  { 
•	    /0000  {  /glob "*"   /type "allow" }
•	  }


Instead of invalidating all files, only the files on the same path as an updated file are cached. 
For example, a multi-language website uses the structure /content/myWebsite/xx/topics, where xx represents the 2-letter identifier for each language. When /statfileslevel is three, (/statfileslevel = "3"), a .stat file is created in the following folders:
•	/content
•	/content/myWebsite
•	/content/myWebsite/xx (each language folder contains a .stat file)
When a file in the /content/myWebsite/fr/topics folder is activated, the .stat file below /content/myWebsite/fr is touched. All files in the fr folder are invalidated.

Automatically Invalidating Cached Files
The /invalidate property defines the documents that are automatically invalidated when content is updated.
With automatic invalidation, Dispatcher does not delete cached files after a content update, but checks their validity when they are next requested. Documents in the cache that are not auto-invalidated will remain in the cache until a content update explicitly deletes them.
Automatic invalidation is typically used for HTML pages. HTML pages often contain links to other pages, making it difficult to determine whether a content update affects a page. To make sure that all relevent pages are invalidated when content is updated, automatically invalidate all HTML pages. The following configuration invalidates all HTML pages:
1
2
3
4
5	/invalidate
{
 /0000  { /glob "*" /type "deny" }
 /0001  { /glob "*.html" /type "allow" }
}
Using custom invalidation scripts
The /invalidateHandler property allows you to define a script which is called for each invalidation request received by Dispatcher.
It is called with the following arguments:
•	Handle
The content path that is invalidated
•	Action
The replication Action (e.g. Activate, Deactivate)
•	Action Scope
The replication Action's Scope (empty, unless a header of CQ-Action-Scope: ResourceOnly is sent, see Invalidating Cached Pages from AEM for details)
This can be used to cover a number of different use cases, such as invalidating other application specific caches, or to handle cases where the externalized URL of a page and its place in the docroot does not match the content path.
Below example script logs each invalidate request to a file.
/invalidateHandler "/opt/dispatcher/scripts/invalidate.sh"
Code samples are intended for illustration purposes only.
sample invalidation handler script
#!/bin/bash
 
printf "%-15s: %s %s" $1 $2 $3>> /opt/dispatcher/logs/invalidate.log
Limiting the Clients That Can Flush the Cache
The /allowedClients property defines specific clients that are allowed to flush the cache. The globbing patterns are matched against the IP.
The following example:
1.	denies access to any client
2.	explicitly allows access to the localhost
1
2
3
4
5	/allowedClients
  {
   /0001 { /glob "*.*.*.*"  /type "deny" }
   /0002 { /glob "127.0.0.1" /type "allow" }
  }

Ignoring URL Parameters
The ignoreUrlParams section defines which URL parameters are ignored when determining whether a page is cached or delivered from cache:
•	When a request URL contains parameters that are all ignored, the page is cached.
•	When a request URL contains one or more parameters that are not ignored, the page is not cached.
When a parameter is ignored for a page, the page is cached the first time that the page is requested. Subsequent requests for the page are served the cached page, regardless of the value of the parameter in the request. 
To specify which parameters are ignored, add glob rules to the ignoreUrlParams property:
•	To ignore a parameter, create a glob property that allows the parameter. 
•	To prevent the page to be cached, create a glob property that denies the parameter.
The following example causes Dispatcher to ignores the "q" parameter, so that request URLs that include the q parameter are cached:
1
2
3
4
5	/ignoreUrlParams
{
    /0001 { /glob "*" /type "deny" }
    /0002 { /glob "q" /type "allow" }
}
Code samples are intended for illustration purposes only.
Using the example ignoreUrlParams value, the following HTTP request causes the page to be cached because the q parameter is ignored:
GET /mypage.html?q=5
Code samples are intended for illustration purposes only.
Using the example ignoreUrlParams value, the following HTTP request causes the page to not be cached because the p parameter is not ignored:
GET /mypage.html?q=5&p=4
Configuring Load Balancing - /statistics
The /statistics section defines categories of files for which Dispatcher scores the responsiveness of each render. Dispatcher uses the scores to determine which render to send a request.
Each category that you create defines a glob pattern. Dispatcher compares the URI of the requested content to these patterns to determine the category of the requested content:
•	The order of the categories determines the order in which they are compared to the URI.
•	The first category pattern that matches the URI is the category of the file. No more category patterns are evaluated. 
Dispatcher supports a maximum of 8 statistics categories. If you define more than 8 categories, only the first 8 are used.
Render Selection
Each time Dispatcher requires a rendered page, it uses the following algorithm to select the render:
1.	If the request contains the render name in a renderid cookie, Dispatcher uses that render.
2.	If the request includes no renderid cookie, Dispatcher compares the render statistics:
1.	Dispatcher determines the cateogry of the request URI.
2.	Dispatcher determines which render has the lowest response score for that category, and selects that render.
3.	If no render is selected yet, use the first render in the list.
The score for a render's category is based on previous response times, as well as previous failed and successful connections that Dispatcher attempts. For each attempt, the score for the category of the requested URI is updated.


Identifying a Sticky Connection Folder stickyConnectionsFor
The /stickyConnectionsFor property defines one folder that contains sticky documents; this will be accessed using the URL. Dispatcher sends all requests, from a single user, that are in this folder to the same render instance. Sticky connections ensure that session data is present and consistent for all documents. This mechanism uses the renderid cookie.
The following example defines a sticky connection to the /products folder:
/stickyConnectionsFor "/products"
Code samples are intended for illustration purposes only.
When a page is composed of conent from several content nodes, include the /paths property that lists the paths to the content. For example, a page contains content from /content/image, /content/video, and /var/files/pdfs. The following configuration enables sticky connections for all content on the page:
/stickyConnections {
  /paths {
    "/content/image"
    "/content/video"
    "/var/files/pdfs"
  }
}
Handling Render Connection Errors
Configure Dispatcher behavior when the render server returns a 500 error, or is unavailable. 
Specifying a Health Check Page
Use the /health_check property to specify a URL that is checked when a 500 status code occurs. If this page also returns a 500 status code the instance is considered to be unavailable and a configurable time penalty (/unavailablePenalty) is applied to the render before retrying.
1
2
3
4
5	/health_check
  {
  # Page gets contacted when an instance returns a 500
  /url "/health_check.html"
  }
Code samples are intended for illustration purposes only.
Specifying the Page Retry Delay
The /retryDelay property sets the time (in seconds) that Dispatcher waits between rounds of connection attempts with the farm renders. For each round, the maximum number of times Dispatcher attempts a connection to a render is the number of renders in the farm.
Dispatcher uses a value of "1" if /retryDelay is not explicitly defined. The default value is appropriate in most cases.
1	/retryDelay "1"
Code samples are intended for illustration purposes only.
Configuring the Number of Retries
The /numberOfRetries property sets the maximum number of rounds of connection attempts that Dispatcher performs with the renders. If Dispatcher cannot successfully connect to a render after this number of retries, Dispatcher returns a failed response.
For each round, the maximum number of times Dispatcher attempts a connection to a render is the number of renders in the farm. Therefore, the maximum number of times that Dispatcher attempts a connection is (/numberOfRetries) x (the number of renders).
"5" is the default value used if not explicitly defined.
1	/numberOfRetries "5"
Using the Failover Mechanism
Enable the failover mechanism on your Dispatcher farm to resend requests to different renders when the original request fails. When failover is enabled, Dispatcher has the following behavior:
•	When a request to a render returns HTTP status 503 (UNAVAILABLE), Dispatcher sends the request to a different render.
•	When a request to a render returns HTTP status 50x (other than 503), Dispatcher sends a request for the page that is configured for the health_check property. 
o	If the health check returns 500 (INTERNAL_SERVER_ERROR), Dispatcher sends the original request to a different render.
o	If the healtch check returns HTTP status 200, Dispatcher returns the initial HTTP 500 error to the client. 
To enable failover, add the following line to the farm (or website): /failover "1" 
Preventing Denial of Service (DoS) Attacks
A denial of service (DoS) attack is an attempt to make a computer resource unavailable to its intended users. This is often done by overloading the resource; for example:
•	With a flood of requests from an external source.
•	With a request for more information than the system can successfully deliver.
For example, a JSON representation of the entire repository.
•	By requesting a content page with an unlimited number of URLs, The URL can include a handle, some selectors, an extension, and a suffix - any of which can be modified.
For example, .../en.html can also be requested as:
o	.../en.ExtensionDosAttack
o	.../en.SelectorDosAttack.html
o	.../en.html/SuffixDosAttack
All valid variations (e.g. return a 200 response and are configured to be cached) will be cached by the dispatcher, eventually leading to a full file system and no service for further requests.
Configuring Sling to prevent DoS
Sling is content-centric. This means that processing is focused on the content as each (HTTP) request is mapped onto content in the form of a JCR resource (a repository node):
•	The first target is the resource (JCR node) holding the content.
•	Secondly, the renderer, or script, is located from the resource properties in combination with certain parts of the request (e.g. selectors and/or the extension).
This approach makes Sling very powerful and very flexible, but as always it is the flexibility that needs to be carefully managed.
To help prevent DoS misuse you can:
1.	Incorporate controls at the application level; due to the number of variations possible a default configuration is not feasible.
In your application you should:
o	Control the selectors in your application, so that you only serve the explicit selectors needed and return 404 for all others.
o	Prevent the output of an unlimited number of content nodes.
2.	Check the configuration of the default renderers, which can be a problem area.
o	In particular the JSON renderer which can transverse the tree structure over multiple levels.
For example, the request:
    http://localhost:4502/.json
could dump the whole repository in a JSON representation. This would cause significant server problems. For this reason Sling sets a limit on the number of maximum results. To limit the depth of the JSON rendering you can set the value for:
    JSON Max results (json.maximumresults)
in the configuration for the Apache Sling GET Servlet. When this limit is exceeded the rendering will be collapsed. The default value for Sling within CQ is 200.
o	As a preventive measure disable the other default renderers (HTML, plain text, XML). Again by configuring the Apache Sling GET Servlet.
Configuring the Dispatcher to prevent DoS
At the dispatcher level, there are two methods of configuring to prevent DoS attacks:
•	Use the mod_rewrite module (for example, Apache 2.2) to perform URL validations (if the URL pattern rules are not too complex).
•	Prevent the dispatcher from caching URLs with spurious extensions by using filters.
For example, change the caching rules to limit caching to the expected mime types, such as:
o	.html
o	.jpg
o	.gif
o	.swf
o	.js
o	.doc
o	.pdf
o	.ppt
An example configuration file can be seen for restricting external access, this includes restrictions for mime types.
To safely enable full functionality on the publish instances, configure filters to prevent access to the following nodes:
•	/etc/ 
•	 /libs/ 
Then, configure filters to allow access to the following node paths:
•	/etc/designs/*
•	/etc/clientlibs/*
•	/etc/segmentation.segment.js
•	/libs/cq/personalization/components/clickstreamcloud/content/config.json
•	/libs/wcm/stats/tracker.js
•	/libs/cq/personalization/* (JS, CSS and JSON)
•	/libs/cq/security/userinfo.json (CQ user information)
•	/libs/cq/i18n/* (Internalization)
User Administration and Security
Authentication
Authentication is the process of identifying, and verifying, a user.
The process of authentication and login can be broken down as follows:
1.	Authentication information is extracted from the request. In Adobe Experience Manager (AEM), this is done by an authentication handler.
2.	The authentication information is then checked to determine whether it is sufficient and/or correct. In AEM, this is performed by the login modules.
3.	The appropriate response is initiated.
Adobe Experience Manager performs initial authentication using a standard HTML-login form in conjunction with the HTTP Header Authentication Handler. The HTML form must contain fields for the user name and password (the same field names must then be used by the HTTP Header Authentication Handler).

Authorization
Authorization determines whether a user is allowed to take action on specific areas within the system. For example, a user can be authorized to read or update a specific page.
Authorization is managed using a series of entities:
User
Users access a system using their user accounts. A user models either a human user or an external system connected to the system. The user account holds the details needed for accessing AEM; a key purpose of an account is to provide the information for the authentication and login processes - allowing a user to log in.
Groups
A group is a collection of users and/or other groups. A change in the permissions/privileges assigned to a group is automatically applied to all users in that group. All users are members of the Everyone group. In addition, users can belong to several other groups. (Even if the group Everyone is deleted, all users remain part of the group because of the indirect relationship between users/groups and authorization. See Privileges for more info.)
AEM Actions
AEM actions are performed on a resource. For example, a user can read, edit or delete a page, among other actions.
Permissions
A permission allows a user to perform an action on a given resource within the repository. Permissions are stored, and can be seen, at the resource level within the repository.
Privileges
Privileges allow access to functionality available within the application; for example, replication of a specific path, or the ability to update the page hierarchy (including creating new pages). Privileges are always granted or denied to principals rather than to users or groups. The link between users and groups and the authorization is indirect; there is always a principal associated with a user or group.
Resources
Resources define the functionality to be accessed.
Users and Groups in AEM
Users
Users will log in to AEM with their account. Each user account is unique and holds the basic account details, together with the privileges assigned.
Users are often members of Groups, which simplify the allocation of these permissions and/or privileges.
Groups
Groups are collections of users and/or other groups; these are all called Members of a group.
Their primary purpose is to simplify the maintenance process by reducing the number of entities to be updated, as a change made to a group is applied to all members of the group. Groups often reflect:
•	a role within the application; such as someone who is allowed to surf the content, or someone who is allowed to contribute content.
•	your own organization; you may want to extend the roles to differentiate between contributors from different departments when they are restricted to different branches in the content tree.
Therefore groups tend to remain stable, whereas users come and go more frequently.
With planning and a clean structure, the use of groups can reflect your structure, giving you a clear overview and an efficient mechanism for updates.

Permissions in AEM
Permissions define who is allowed to perform which actions on a resource. The permissions are the result of access control evaluations.
You can change the permissions granted/denied to a given user by selecting or clearing the checkboxes for the individual AEM actions. A check mark indicates that an action is allowed. No checkmark indicates that an action is denied.
Where the checkmark is located in the grid also indicates what permissions users have in what locations within AEM (that is, which paths).
Actions can be performed on a page (resource). For each page in the hierarchy, you can specify which action the user is allowed to take on that page. Permissions enable you to allow or deny an action.
Action 	Description 
Read	The user is allowed to read the page and any child pages.
Modify	The user can:
•	modify existing content on the page and on any child pages.
•	create new paragraphs on the page or on any child page.
At the JCR level, users can modify a resource by modifying its properties, locking, versioning, nt-modifications, and they have complete write permission on nodes defining a jcr:content child node, for example cq:Page, nt:file, cq:Asset.
Create	The user can:
•	create a new page or child page.
If modify is denied the subtrees below jcr:content are specifically excluded because the creation of jcr:content and its child nodes are considered a page modification. This only applies to nodes defining a jcr:content child node.
Delete	The user can:
•	delete existing paragraphs from the page or any child page.
•	delete a page or child page.
If modify is denied any subtrees below jcr:content are specifically excluded as removing jcr:content and its child nodes is considered a page modification.  This only applies to nodes defining a jcr:content child node.
Read ACL	The user can read the access control list of the page or child pages.
Edit ACL	The user can modify the access control list of the page or any child pages.
Replicate	The user can replicate content to another environment (for example, the Publish environment). The privilege is also applied to any child pages.


AEM WCM uses Access Control Lists (ACLs) to organize the permissions being applied to the various pages.
Access Control Lists are made up of the individual permissions and are used to determine the order in which these permissions are actually applied. The list is formed according to the hierarchy of the pages under consideration. This list is then scanned bottom-up until the first appropriate permission to apply to a page is found.

Permission States
Action 	Description 
Allow (Check mark)	AEM WCM allows the user to perform the action on this page or on any child pages.
Deny (No checkmark)	AEM WCM does not allow the user to perform the action on this page nor on any child pages.
The permissions are also applied to any child pages.

The following are recommendations about managing access control lists:
•	Do not assign permissions directly to users. Assign them only to groups.
This will simplify the maintenance, as the number of groups is much smaller than the number of users, and also less volatile.
•	If you want a group/user to be able only to modify pages, do not grant them create or deny rights. Only grant them modify and read rights.
•	Use Deny sparingly. As far as possible use only Allow.
Permissions
Permissions give users and groups access to AEM functionality on AEM pages.
You browse permissions by path by expanding/collapsing the nodes and you can track the permission inheritance up to the root node.
You allow or deny permissions by selecting or clearing the appropriate check boxes
Impersonating another User
With the Impersonate functionality a user can work on behalf of another user.
This means that a user account can specify other accounts that can operate with their account. In other words, if user-B is allowed to impersonate user-A, then user-B can take actions using the full account details of user-A.
Dispatcher.any file

# Each farm configures a set of load balanced renders (i.e. remote servers)
/farms
  {
  # First farm entry
  /website 
    {  
    # Request headers that should be forwarded to the remote server.
    /clientheaders
      {
      # Forward all request headers that are end-to-end. If you want
      # to forward a specific set of headers, you'll have to list
      # them here.
      "*"
      }
      
    # Hostname globbing for farm selection (virtual domain addressing)
    /virtualhosts
      {
      # Entries will be compared against the "Host" request header
      # and an optional request URL prefix.
      #
      # Examples:
      #
      #   www.company.com
      #   intranet.*
      #   myhost:8888/mysite
      "*"
      }
      
    # The load will be balanced among these render instances
    /renders
      {
      /rend01
        {
        # Hostname or IP of the render
        /hostname "127.0.0.1"
        # Port of the render
        /port "4503"
        # Connect timeout in milliseconds, 0 to wait indefinitely
        # /timeout "0"
        }
      }
      
    # The filter section defines the requests that should be handled by the dispatcher.
    # The globs will be compared against the request line, e.g. "GET /index.html HTTP/1.1".
    /filter
      {
      # Deny everything first and then allow specific entries
      /0001 { /type "deny"  /glob "*" }
        
      # Open consoles
#     /0011 { /type "allow" /glob "* /admin/*"  }  # allow servlet engine admin
#     /0012 { /type "allow" /glob "* /crx/*"    }  # allow content repository
#     /0013 { /type "allow" /glob "* /system/*" }  # allow OSGi console
        
      # Allow non-public content directories
#     /0021 { /type "allow" /glob "* /apps/*"   }  # allow apps access
#     /0022 { /type "allow" /glob "* /bin/*"    }
      /0023 { /type "allow" /glob "* /content*" }  # disable this rule to allow mapped content only
      
#     /0024 { /type "allow" /glob "* /libs/*"   }
#     /0025 { /type "deny"  /glob "* /libs/shindig/proxy*" } # if you enable /libs close access to proxy

#     /0026 { /type "allow" /glob "* /home/*"   }
#     /0027 { /type "allow" /glob "* /tmp/*"    }
#     /0028 { /type "allow" /glob "* /var/*"    }

      # Enable specific mime types in non-public content directories 
      /0041 { /type "allow" /glob "* *.css *"   }  # enable css
      /0042 { /type "allow" /glob "* *.gif *"   }  # enable gifs
      /0043 { /type "allow" /glob "* *.ico *"   }  # enable icos
      /0044 { /type "allow" /glob "* *.js *"    }  # enable javascript
      /0045 { /type "allow" /glob "* *.png *"   }  # enable png
      /0046 { /type "allow" /glob "* *.swf *"   }  # enable flash
      /0047 { /type "allow" /glob "* *.html *"   }  # enable flash

      # Enable features 
      /0061 { /type "allow" /glob "POST /content/[.]*.form.html" }  # allow POSTs to form selectors under content
      /0062 { /type "allow" /glob "* /libs/cq/personalization/*"  }  # enable personalization

      # Deny content grabbing
      /0081 { /type "deny"  /glob "GET *.infinity.json*" }
      /0082 { /type "deny"  /glob "GET *.tidy.json*"     }
      /0083 { /type "deny"  /glob "GET *.sysview.xml*"   }
      /0084 { /type "deny"  /glob "GET *.docview.json*"  }
      /0085 { /type "deny"  /glob "GET *.docview.xml*"  }
      
      /0086 { /type "deny"  /glob "GET *.*[0-9].json*" }
#     /0087 { /type "allow" /glob "GET *.1.json*" }          # allow one-level json requests

      # Deny query
      /0090 { /type "deny"  /glob "* *.query.json*" }
      }

    # The cache section regulates what responses will be cached and where.
    /cache
      {
      # The docroot must be equal to the document root of the webserver. The
      # dispatcher will store files relative to this directory and subsequent
      # requests may be "declined" by the dispatcher, allowing the webserver
      # to deliver them just like static files.
      /docroot "/opt/cq/dispatcher/publish"

      # Sets the level upto which files named ".stat" will be created in the 
      # document root of the webserver. When an activation request for some 
      # page is received, only files within the same subtree are affected 
      # by the invalidation.
      /statfileslevel "3"
      
      # Flag indicating whether to cache responses to requests that contain
      # authorization information.
      /allowAuthorized "1"
      
      # Flag indicating whether the dispatcher should serve stale content if
      # no remote server is available.
      #/serveStaleOnError "0"
      
      # The rules section defines what responses should be cached based on
      # the requested URL. Please note that only the following requests can
      # lead to cacheable responses:
      #
      # - HTTP method is GET
      # - URL has an extension
      # - Request has no query string
      # - Request has no "Authorization" header (unless allowAuthorized is 1)
      /rules
        {
        /0000
          {
          # the globbing pattern to be compared against the url
          # example: *             -> everything
          #        : /foo/bar.*    -> only the /foo/bar documents
          #        : /foo/bar/*    -> all pages below /foo/bar
          #        : /foo/bar[./]* -> all pages below and /foo/bar itself
          #        : *.html        -> all .html files
          /glob "*"
          /type "allow"
          }
        }
        
      # The invalidate section defines the pages that are "invalidated" after
      # any activation. Please note that the activated page itself and all 
      # related documents are flushed on an modification. For example: if the 
      # page /foo/bar is activated, all /foo/bar.* files are removed from the
      # cache.
      /invalidate
        {
        /0000
          {
          /glob "*"
          /type "deny"
          }
        /0001
          {
          # Consider all HTML files stale after an activation.
          /glob "*.html"
          /type "allow"
          }
        }

      # The allowedClients section restricts the client IP addresses that are
      # allowed to issue activation requests.
      /allowedClients
        {
        # Uncomment the following to restrict activation requests to originate
        # from "localhost" only.
        #
        #/0000
        #  {
        #  /glob "*"
        #  /type "deny"
        #  }
        #/0001
        #  {
        #  /glob "127.0.0.1"
        #  /type "allow"
        #  }
        }
      }
      
    # The statistics sections dictates how the load should be balanced among the
    # renders according to the media-type. 
    /statistics
      {
      /categories
        {
        /html
          {
          /glob "*.html"
          }
        /others
          {
          /glob "*"
          }
        }
      }
    }
  }



Resource Mapping
Resource mapping is used to define redirects, vanity URLs and virtual hosts for AEM.

For example, you can use these mappings to:
•	Prefix all requests with /content so that the internal structure is hidden from the visitors to your website.
•	Define a redirect so that all requests to the /content/en/gateway page of your website are redirected to http://gbiv.com/.

One possible HTTP mapping prefixes all requests to localhost:4503 with /content. A mapping like this could be used to hide the internal structure from the visitors to the website as it allows:
•	localhost:4503/content/geometrixx/en/products.html
•	to be accessed using:
•	localhost:4503/geometrixx/en/products.html
•	as the mapping will automatically add the prefix /content to /geometrixx/en/products.html




Vanity URLs do not support regex patterns.

Viewing Mapping Definitions
•	Configuration
Shows the current configuration (as defined for the Apache Sling Resource Resolver).
•	Configuration Test
This allows you to enter a URL or resource path. Click Resolve or Map to confirm how the system will transform the entry.
•	Resolver Map Entries
The list of entries used by the ResourceResolver.resolve methods to map URLs to Resources.
•	Mapping Map Entries
The list of entries used by the ResourceResolver.map methods to map Resource Paths to URLs.

For example, the:
Pattern ^[^/]+/[^/]+/welcome$
will trigger the:
Replacement /libs/cq/core/content/welcome.html.
to redirect a request:
http://localhost:4503/welcome
to:
http://localhost:4503/libs/cq/core/content/welcome.html


Creating Mapping Definitions in AEM
In a standard installation of AEM you can find the folder:
/etc/map/http
This is the structure used when defining mappings for the HTTP protocol. Other folders (sling:Folder) can be created under /etc/map for any other protocols that you want to map.
Configuring an Internal Redirect to /content
To create the mapping that prefixes any request to http://localhost:4503/ with /content:
1.	Using CRXDE navigate to /etc/map/http.
2.	Create a new node:
o	Type sling:Mapping
This node type is intended for such mappings, though its use is not mandatory.
o	Name localhost_any
3.	Click Save All.
4.	Add the following properties to this node:
o	Name sling:match 
	Type String 
	Value localhost.4503/
o	Name sling:internalRedirect 
	Type String 
	Value /content/
5.	Click Save All.
This will handle a request such as:
         localhost:4503/geometrixx/en/products.html
as if:
        localhost:4503/content/geometrixx/en/products.html
had been requested.

You can use /etc/map.publish to hold the configurations for the publish environment. These must then be replicated, and the new location (/etc/map.publish) configured for the Mapping Location of the Apache Sling Resource Resolver of the publish environment.
multidomain-cq-mappings-and-apache-configuration
It is quite common that a single CQ instance handles multiple sites. Usually, each page has a separate domain assigned and can have a few language versions. Having such a multi-domain installation requires some additional, nontrivial configuration. This post is intended to serve as a quick referecnce document wherein you can learn how to configure 3 language versions of the well-known Geometrixx site to work on 3 domains: geometrixx.com, geometrixx.de and geometrixx.fr.

First, let's configure CQ itself (with the Sling Mappings engine), create Apache rewrite rules and VirtualHosts, eliminate the cross-domain cache injection threat and finally we will perform refactoring of the Apache configuration to make it more concise.
Sling Mappings engine
According to dev.day.com, the best way to map a domain name to a web site is to use Sling Mappings. Mappings provide two useful features:

•	long links in page content are shortened to a friendly form,
•	short links are resolved to a full content path.



You can achieve short links resolution on the Apache level, using mod_rewrite. However, you cannot shorten links without esoteric modules like mod_subsitute. So, following Day's advice we will use Sling Mappings.  By default, mappings are placed in the JCR /etc/map/http directory. In our projects we usually use /etc/map/http on an author instance and /etc/map.publish/http on a publish instance (so one common package with mappings can be installed on both instances). You can change this path in the configuration of the JcrResourceResolverFactoryImpl OSGi component.
•	This is my suggestion of the /etc/map.publish/http:

01     jcr: primaryType: "sling:OrderedFolder",
02     geometrixx_com: {
03         sling:internalRedirect: ["/content/geometrixx/en.html"],
04         jcr:primaryType: "sling:Mapping",
05         sling:match: "geometrixx.com/$"
06     },
07     geometrixx.com: {
08         sling:internalRedirect: ["/content/geometrixx/en"],
09         jcr:primaryType: "sling:Mapping",
10         redirect: {
11             sling:internalRedirect: ["/content/geometrixx/en/$1","/$1"],
12             jcr:primaryType: "sling:Mapping",
13             sling:match: "(.+)$"
14         }
15     },
16    ….

After three dots in line 16 there are similar entries for .de and .fr domains: geometrixx_de with geometrixx.de and geometrixx_fr with geometrixx.fr. You can download a CQ package with the full version of the mappings.

Mapping geometrixx_com (lines 2-6) is responsible for redirecting to the root page. So, if the user enters geometrixx.com she or he will receive the page /content/geometrixx/en.html. The dollar sign at the end of sling:match (5) is a regexp control character meaning "end of the string", which results in the fact that this mapping will not be applicable if the user enters any path after the slash.

Mapping geometrixx.com (7-15) is more complex. It consists of the parent (7-15) and the child (10-14). The parent does not contain the sling:match property, so the node name (geometrixx.com) is used as a URL pattern. This entry is responsible for shortening long links to a shorter form with a domain name, e.g. /content/geometrixx/en/products will be shortened to geometrixx.com/products.html.

A child entry is responsible for URL resolution. In order to match this mapping, a URL has to begin with geometrixx.com (a domain inherited from the parent mapping) and after that it has to contains non-empty path string (regular expression (.+)$ at line 13). sling:internalRedirect at line 11 is a list containing two entries: /$1 and /content/geometrixx/en/$1. If the user enters geometrixx.com/etc/designs/geometrixx.css, the first entry will be used. If the user enters geometrixx.com/products.html, Sling will choose the second one and return /content/geometrixx/en/products.html.
You can play with mappings using the Apache Felix web console. Just click the Sling Resource Resolver link in the menu.


Apache mod_rewrite
After defining mappings (and probably adding an appropriate domain to the hosts file) we can enjoy our multidomain CQ installation with short links. There is only one problem: a dispatcher. If we use some standard dispatcher configuration, there will be one cache directory for all sites. If the user requests the page geometrixx.com/products.html, a dispatcher will create the file /products.html in the cache dir. Now, if some other user requests the page geometrixx.de/products.html, a dispatcher will find its cached English version and will serve it to the German user. In order to avoid such problems we should reflect the JCR directory structure in a dispatcher. The easiest way to expand shortened paths is to use the Apache rewrite engine. Basically, we will try to simulate the Sling resolving mechanism. The following rules will do the job:
00   RewriteEngine On
01   RewriteRule ^/$ /content/geometrixx/en.html [PT,L]
02   RewriteCond %{REQUEST_URI} !^/apps
03   RewriteCond %{REQUEST_URI} !^/bin
04   RewriteCond %{REQUEST_URI} !^/content
05   RewriteCond %{REQUEST_URI} !^/etc
06   RewriteCond %{REQUEST_URI} !^/home
07   RewriteCond %{REQUEST_URI} !^/libs
08   RewriteCond %{REQUEST_URI} !^/tmp
09   RewriteCond %{REQUEST_URI} !^/var
10   RewriteRule ^/(.*)$ /content/geometrixx/en/$1 [PT,L]
At the begining (1) we check if the entered URL contains an empty path (e.g. http://geometrixx.com/). If so, the user will be forwarded to the homepage. Otherwise, we check if the entered path is shortened (it does not begin with apps, content,  home, etc. - lines 2-8). If it is, the rewrite engine will add /content/geometrixx/en while creating the absolute path (9).


Apache VirtualHost
As you can see, this rule is valid only for the geometrixx.com domain, so we need similar rules for each domain and some mechanism for recognizing a current domain. Such a mechanism in Apache is called VirtualHost. A sample configuration file of the Apache2 VirtualHost looks as follows:
<VirtualHost *:80>
    ServerAdmin webmaster@localhost
    ServerName geometrixx.com

    DocumentRoot /opt/cq/dispatcher/publish
    <Directory /opt/cq/dispatcher/publish>
        Options FollowSymLinks
        AllowOverride None
    </Directory>

    <IfModule disp_apache2.c>
        SetHandler dispatcher-handler
    </IfModule>

[... above rewrite rules ...]

    LogLevel warn
    CustomLog ${APACHE_LOG_DIR}/access-geo-en.log combined
    ErrorLog ${APACHE_LOG_DIR}/error-geo-en.log
</VirtualHost>
All VirtualHosts can use a shared dispatcher directory. Create similar files for each domain.

Cross-domain injection threat
Because users are able to enter a full content path after a given domain name, e.g. geometrixx.com/content/geometrixx/en/products.html, they may as well get a page that belongs to some other domain, e.g. geometrixx.com/content/geometrixx/fr/products.html. In order to avoid such a situation, we need to check all requests for path beginning with /content and reject these which are not related to any campaign, DAM or a current domain:
RewriteCond %{REQUEST_URI} ^/content
RewriteCond %{REQUEST_URI} !^/content/campaigns
RewriteCond %{REQUEST_URI} !^/content/dam
RewriteRule !^/content/geometrixx/en - [R=404,L,NC]

Macros
Our rewrite configuration has become quite complicated and (what is worse) has to be included in each Apache VirtualHost configuration. Fortunately, we can avoid repetitions using the Apache macro module. Add the following expand-cq-paths file to your conf.d directory:
<Macro ExpandCqPaths $path>
        RewriteEngine On

        RewriteRule ^/$ $path.html [PT,L]

        RewriteCond %{REQUEST_URI} ^/content
        RewriteCond %{REQUEST_URI} !^/content/campaigns
        RewriteCond %{REQUEST_URI} !^/content/dam
        RewriteRule !^$path - [R=404,L,NC]

        RewriteCond %{REQUEST_URI} !^/apps
        RewriteCond %{REQUEST_URI} !^/content
        RewriteCond %{REQUEST_URI} !^/etc
        RewriteCond %{REQUEST_URI} !^/home
        RewriteCond %{REQUEST_URI} !^/libs
        RewriteCond %{REQUEST_URI} !^/tmp
        RewriteCond %{REQUEST_URI} !^/var
        RewriteRule ^/(.*)$ $path/$1 [PT,L]
</Macro>
After that you can include a macro in each VirtualHost with the Use directive:
Use ExpandCqPaths /content/geometrixx/en
Because the Macro module is an external Apache2 library, you might need to install it separately. On Debian you can install and enable it using two commands:
# apt-get install libapache2-mod-macro
# a2enmod macro
If you use any other Linux distribution or Windows, please find the appropriate version of the module and the installation instruction on the mod_macro homepage.
Dispatcher configuration
You can use the out-of-the-box dispatcher configuration. The only assumption is that its docroot is set to /opt/cq/dispatcher/publish. Apache and dispatcher configuration is available to download.
Summary
Now, you have configured a CQ installation with 3 domains, using Sling Mappings, Apache 2 mod_rewriteand VirtualHost mechanisms. We have also prevented cross-domain injection attacks and performed Apache 2 configuration refactoring using mod_macro. The configuration described above should be enough to prepare a custom multi-domain installation from scratch.



Question
How can I create custom scripts or error handlers that render different HTTP errors .
Answer, Resolution
The default error handler scripts are located under /libs/sling/servlet/errorhandler.
You can overlay default error handling by copying the script you would like to customize from /libs/sling/servlet/errorhandler to the same location under /apps (i.e. /apps/sling/servlet/errorhandler). Create this path if it does not exist (it doesn't by default).

How do we debug our application running in a remote (or local) CQ5 server?

Step 1: Add the Remote Debugging JVM Parameter
1.	To use remote debugging, you must start CQ5 with this JVM parameter:
-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n
You can add the parameter by doing the following;
1.	Start your server like this: crx-quickstart/bin/start -d --debug-port 8000. The -d parameter adds the jvm parameter to the CQ5 java process.
2.	Add it to your crx-quickstart/bin/start script CQ_JVM_OPTS environment variable (so your server always starts in debug mode).
3.	Include it as a parameter when starting CQ5 with java -jar directly. For example, java -Xmx512m -agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n -jar cq-author-4502.jar
Step 2: Start a remote debugging session
To start a remote debugging session from Eclipse, do the following:
1.	Open Eclipse.
2.	Choose Run > Debug Configurations.
3.	Right-click Remote Java Applications and select New.
4.	Select your CQ5 project under Project.
5.	Type in the port from the "address" configuration of the jvm parameter defined above. In the example, it is port 8000 (and the host name of the machine you are connecting to, most likely localhost)
6.	To start a debugging session, double-click your new configuration in the Debug Configurations screen after saving it.
AEM tool version difference
Major difference between CQ5.x and AEM6.x: AEM6.x implements OAK repository whereas older CQ5 uses CRX2. AEM6.x uses Microkernel , CQ5.x uses Persistence manager. Custom re-index is possible in AEM 6.x depends upon the queries . (Will cover more on this in later article) Slightly is introduced in AEM6.x whereas CQ5 uses JSP.

Read more at AEMCQ5Tutorials: Configure Data Store and Node Store in AEM 6 
AEM 6.0 (MAJOR RELEASE)
What's new	
New features/functionalities
Experience Manager Platform
Create projects wizard & project templates
Project dashboard & team management
Experience Manager Sites
Translation - Integrated machine translation capabilities with Microsoft Translator. Automatic content translation during language copy creation. Automatic delta-translation of content updates and management via launches.
Integration Adobe Search&Promote with Products managed in AEM
Social Communities
 UGC Tagging
UGC Localization - New machine-based translation service for User Generated Content with on the fly translations, inline presentation and persistence of the translations, and ability to share a common set of UGC across localized Web sites.
Publish Side Moderation- New ability to delegate moderation to publish side users, so that they can approve, deny, edit or delete user generated content in context of the pages where the content was posted
UGC Cloud Storage - New ability to store User Generated Content in the cloud via a new "Social Communities cloud datastore" service available natively in AEM.
Social Components Framework - New development and extensibility framework for the Community components, including a JSON social API endpoint and client-side/server-side rendering of component views powered by Handlebars and Backbone technologies, ensuring ease of integration and optimal performance
Review Component
Experience Manager Assets
Metadata bulk Editor 
Metadata Schema Editor
Saved Search Support
Asset Selector
Experience Manager Forms
AEM 6.1 (Minor RELEASE)
Experience Manager Platform
The platform of Adobe Experience Manager 6.1 build on top of updated versions of the OSGi-based framework (Apache Sling and Apache Felix) and the Java Content Repository: Apache Jackrabbit Oak 1.2.

The Quickstart uses the Eclipse Jetty 9.2.9 as servlet engine.
Security
6.1 includes a range a new and improved capabilities to maintain a secure deployment and run a secure web property. Most notable is a new Cross-Site Request Forgery (CSRF) protection, with that the server does extra checks on POST, PUT and DELETE HTTP requests from browser to avoid CSRF attacks.

Note: With previous releases, for deployments that leverage the Token/Cookie authentication, sticky session was required between multiple publish instances. AEM 6.1 no longer requires sticky session on the load balancer to keep a token/cookie based authentication. This is possible due to a new Crypto Token implementation.

Further, the 'nosamplecontent' server run mode was extended to also deploy a range of 'secure by default' best practices, that with previous releases had to be manually configured.

Repository
Since the introduction of Apache Jackrabbit Oak with AEM 6.0 in 2014, the successor of CRX2, Adobe and the community have improved and extended a wide range of aspects.
Note, Adobe has removed support for CRX2 with 6.1. The release update routine converts the existing CRX2 repository to Oak during the update (CRX2Oak).
Component Framework
In Version 6.0, Adobe introduced the HTML Template Language and Sling Models, as new way to develop components, in an time efficient and secure way. AEM version 6.1 delivers incremental improvements to the new approach.
New in the HTML Template Language (HTL) 1.1:
new <sly> element as alternative to data-sly-unwrap
URI manipulation options (e.g. ${'http://foo.com/test.html '@ scheme='https', extension='json'} outputs https://foo.com/test.json)
Allow java.util.Locale objects to be used in i18n locale option
data-sly-repeat (alternative to data-sly-list that repeats the whole element, instead of just the content)
improved performance (on par with JSP) and around 150 bug fixes since 6.0
the specification and implementation for Apache Sling of HTL are open source (since end of 2014)
User Interface
Experience Manager 6.1 includes the Classic UI (same as in AEM 6.0) and Touch-optimized UI. The Touch-optimized UI in 6.1 is substantially extended to efficiently cover every-day use cases of marketing and content management practitioners
Workflow
The focus for AEM 6.1 was to improve the throughput of workflow tasks that can be executed by the workflow engine, by optimizing various parts of the way workflow steps are run within AEM. Customers that update to 6.1 should see that workflows take less time to complete (in particular with lots of them running in parallel), and take less resources to run on the server.
Summary of improvements:
Introduction of transient workflows, that runs the workflow tasks in memory and don't persist them in the repository. This has to be enabled on the workflow level, and is useful for shot-lived workflow where no audit, or history is needed.
Internal changes, such as reducing JCR observation listeners, amount of Sling Jobs needed to run workflow tasks.
To enable Transient Workflow
In your AEM instance, navigate to /miscadmin. For example, http://<Server>:<Port>/miscadmin
In the navigation tree on the left, click/tap Tools > Workflow > Models > dam.
Click/Tap DAM Update Asset.
On the floating tools panel, switch to the Page tab, and then click Page Properties.
Select Transient Workflow to enable it, then click OK.
To optimize high ingestion loads, Adobe suggests switching the DAM Update and XMP Metadata Writeback workflow to a transient workflow. As the name implies, runtime data related to the intermediate worksteps in transient workflows are not persisted in the JCR when they run (the output renditions are persisted of course). It causes a 10% reduction in the workflow processing time and significantly reduces repository growth. No more CRUD workflows are required to purge. In addition, it reduces the number of TAR files to compact. If your business dictates persisting/archiving workflow runtime data for audit purposes, do not enable this feature.
if you intend to enable Transient Workflow, you should be aware of the following:
Transient workflows do not generate workflow events. As such, features and customers that depend on events should not enable Transient Workflow.
Transient workflows do not support workflow offloading, which depends on workflow events.
Transient workflows do not support legacy CQ workflow events. The reason is because the compatibility layer in CQEventDispatcher does not work.
•	Transient workflows do not support workflow email notification. The reason is because EmailNotificationService is based on CQEventDispatcher, which does not work with transient workflows.
•	Transient workflows do not support workflow statistics. The reason is because CQWorkflowStatisticsService is based on CQEventDispatcher, which does not work with transient workflows.
Extended Touch-optmized UI
•	Ability to select multiple pages and edit properties for the selected pages at once
•	Ability to drag content directly into the paragraph system from Content Finder - that auto-fills into the matching component (configurable per template)
•	For 'Create new page' it's now possible to define the page properties that needs to be filled and are shown after selecting the template.
•	Ability to configure the search forms available throughout the UI in the Dialog Editor. For the Content Finder each asset type with separate search fields
•	Saved Searches: Ability to save search parameters for quick recall later
•	Support for nested launches (ability to create sub-launches of existing launches)
•	Ability to select which template to use when creating a new launch.

Multi-site Management Add-on
Focus for 6.1 for MSM was to enhance the Touch-optimized UI. Highlights:
•	Ability to see Blueprint source of a Live Copy, reveal Blueprint and initiate rollout of Blueprint
•	Enhanced Page Properties - adding actions from the Blueprint Control Center.
o	On Blueprint, ability to see all Live Copies, modify rollout configurations, and initiate a rollout
o	On Live Copy, ability to see Blueprint source, Live Copy status, edit rollout configuration, and perform Live Copy operations: synchronize, reset, detach

AEM 6.2 (Minor RELEASE)

Experience Manager Platform
The platform of Adobe Experience Manager 6.2 build on top of updated versions of the OSGi-based framework (Apache Sling and Apache Felix) and the Java Content Repository: Apache Jackrabbit Oak 1.4.1.
The Quickstart uses the Eclipse Jetty 9.2.14 as servlet engine.
Security
Security features:
•	Added support for password history
•	Configurable authentication token expiration
•	Ongoing effort: Switched usage of the Sling loginAdministrative API to Service Users it various areas of the product.
SPLC (Secure Product Life Cycle) in Product Engineering
•	100% technical staff with advanced security training
•	Reviewed and approved security questionnaires for all new capabilities
•	New and improved static code analysis
•	Several external penetration tests (including BugCrowd)
Repository
Main repository enhancements are:
•	Support for MongoDB Enterprise 3.2
•	Cold standby enhancements to support a procedural failover for high availability in TarMK
•	Oak search enhancements like Faceted Search, Suggestions, Spellchecker and more
•	Performance, Scalability and Resilience in general
•	Revision Cleanup Support:
o	Offline revision cleanup is the recommended way of performing revision cleanup. Support for Online revision cleanup in AEM 6.2 is restricted (Support-Level 'R'). 

User Interface
AEM 6.2 implements the 2016 Adobe Marketing Cloud UI design (also known as Shell 3). Further - the user interface is in transition from Coral UI 2 to the Web Component based Coral 3 UI library.
The product navigation has moved from the side rail to an overlay and provides access to the product areas - and the tools.
The search experience was elevated to allow navigating within the product and search all areas of the product. Use the / key to open the search.

Content Distribution
Content Distribution - the next generation content replication capability - was 1st introduced in AEM 6.1. With AEM 6.2, additional supported use cases were added:
•	Package replication to support extra large activation volumes
•	Priority-Queuing configuration to allow split between urgent activations and backlog
•	Auto-unlocking stuck replication queues incl advanced notifications
Experience Manager Sites
Template Editor & Policies
Creating a template out of existing components has so far been a JCR based configuration. With AEM 6.2, we introduce an UI to compose and configure the templates visually. The Template Editor introduces a few new concepts that makes it easier to create a template in the 1st place, and allow components to be reused more often.
•	First, instead of using Sling includes in the components to nested them to a template, the nesting is stored in a new way - and while rendering the page merged with the content structure.
•	Second, with the introduction of the Policies it's possible to have component design configuration being reused.
•	Third, while technically not new, an easy way to manage the initial content that should appear when a new page is created with the template.
The Template Editor UI works very much like the Page Editor, with the difference that it starts with a blank canvas.


Oak TarMK Compaction
If we are using Tar files as the storage, it tends to grow in size and starts claiming disk space every time when data is created or updated as data in tar files are never overwritten rather it keeps adding new versions. To mitigate the same, AEM has garbage collection mechanism which is known as ‘Tar Compaction’ to remove the unused data and reclaim the disk space.
After the release of AEM 6 and introduction of TarMK, operation teams has faced rapid growth in the size of repository due to a know oak bug for which adobe has already provided a hotfix Oak-core 1.0.25. But after installing this hotfix also it is becoming difficult to maintain or pause the rapid growth of repository. So, adobe come up with two housekeeping activities online and offline tar compaction to control the size of aem repository. Adobe strongly suggest not to use online tar compaction as it takes very long time for compacting repository and affect the performance of site.

Steps to Run Online Tar Compaction in AEM:-
Running online tar compaction is not recommended by adobe, and from aem 6.2 it is triggered under restrictive use. Follow below steps to run online tar compaction:- Note:- In online compaction checkpoints are not removed, so we have to manually run script to clear the old checkpoints.


•	Download correct version of oakrun.jar (Refer faq below on how to find correct version of oakrun.jar). For Example AEM 6.0 (Oak 1.0.22), with AEM 6.1 (Oak 1.2.7), with AEM 6.1 SP1 (Oak 1.2.11)
•	Shutdown your AEM instance. 
•	Find old checkpoints and remove un-referenced checkpoints as shown below in offline tar compaction. 
•	Restart your AEM instance.
•	Go to System console config manager , search for Apache Jackrabbit oak Segment NodeStore Service . 
•	Make sure the PausedCompaction is set to false(unchecked) as well as CloneBinaries (If want to run compaction on binary also).
•	Go to the maintenance dashboard -> Daily Maintenance Window http://localhost:4502/libs/granite/operations/content/maintenance/window.html/mnt/overlay/granite/operations/config/maintenance/_granite_daily 

Click on Add Task —> select Revision Clean up from drop down and click OK. 
By Default it will pick a time around 2 am for running daily revision clean up. 

Hover on the window and click Play button to trigger Revision Clean up. Green Color– Revision clean up task is scheduled. Orange Color– Revision clean up task is currently running. Red Color– Revision clean up task is failed.


Steps to Run Offline Tar Compaction in AEM:- 

Steps to Run Offline Tar Compaction in AEM:- 
Make sure that you are using correct version of oakrun jar that matches you repository or aem repository version (Refer faq below on how to find correct version of oakrun.jar). 

Offline compaction scripts is basically divided into 5 parts:- 
•	Shutdown AEM Instance 
•	Find Old Checkpoints 
•	Remove Unreferenced Checkpoints 
•	Compact Oak 
•	Restart AEM Instance


Command for Windows Machine-

## Run compaction echo "Running compaction. This may take a while" java -jar oakrun.jar compact install-folder/crx-quickstart/repository/segmentstore

Increase Performance of offline tar compaction:- I have seen many teams are still using old scripts without -Dtar option, but you can increase the performance of offline tar compaction by using dtar option as suggested by adobe. After oak version 1.0.22, the oak-run tool introduces several features with an aim to increase the performance of the revision cleanup process and minimize the maintenance window as much as possible. Below are few commands that we can use:- -Dtar.memoryMapped:- It is highly recommended that you enable this feature in order to speed up tar compaction. You can set this as true or false. -Dupdate.limit:- Defines the threshold for the flush of a temporary transaction to disk. The default value is 5000000. -Dcompress-interval:- Number of compaction map entries to keep until compressing the current map. The default is 1000000. You should increase this value to an even higher number for faster throughput, if enough heap memory is available. -Dcompaction-progress-log:- The number of compacted nodes that will be logged. The default value is 1500000, which means that the first 1500000 compacted nodes will be logged during the operation. Use this in conjunction with the next parameter documented below. -Dlogback.configurationFile:- Use a configuration file for logging. Note:- Memory mapped file operations -Dtar.memoryMapped do not work correctly on Windows. As tar is meant for linux/unix.




HTML Template Language (HTL), formerly known as Sightly.
Following example shows on line 1 how to include an HTL file from a JSP file, and on line 2 how a JSP file can be included from an HTL file:

<cq:include script="template.html"/>
<sly data-sly-include="template.jsp"/>
Blocks and Expressions
<h1 data-sly-test="${properties.jcr:title}">
    ${properties.jcr:title}
</h1>
Two different kind of syntaxes can be distinguished:
•	Block Statements
To conditionally display the <h1> element, a data-sly-test HTML5 data attribute is used. HTL provides multiple such attributes, which allow to attach behavior to any HTML element, and all are prefixed with data-sly.
•	Expression Language
HTL expressions are delimited by characters ${ and }. At runtime, these expressions are evaluated and their value is injected into the outgoing HTML stream.
The two pages linked above provide the detailed list of features available for syntax.
The SLY Element
The SLY element has been introduced with AEM 6.1, or HTL 1.1. Prior to that, the data-sly-unwrap attribute had to be used instead.
A central concept of HTL is to offer the possibility of reusing existing HTML elements to define block statements, which avoids the need of inserting additional delimiters to define where the statement starts and ends. This unobtrusive annotation of the markup to transform a static HTML into a functioning dynamic template offers the benefit of not breaking the validity of the HTML code, and therefore to still properly display, even as static files.
However, sometimes there might not be an existing element at the exact location where a block statement has to be inserted. For such cases, it is possible to insert a special SLY element that will be automatically removed from the output, while executing the attached block statements and displaying its content accordingly.
So following example:
<sly data-sly-test="${properties.jcr:title && properties.jcr:description}">
    <h1>${properties.jcr:title}</h1>
    <p>${properties.jcr:description}</p>
</sly>
will output something like following HTML, but only if there are both, a jcr:title and a jcr:decription property defined, and if none of them are empty:
<h1>MY TITLE</h1>
<p>MY DESCRIPTION</p>
HTL Comments
<!--/* An HTL Comment */-->
<!-- An HTML Comment -->

Expression Language
The HTML Template Language uses an expression language to access the data structures that provide the dynamic elements of the HTML output. These expressions are delimited by characters ${ and }.
 To avoid malformed HTML, expressions can only be used in attribute values, in element content, or in comments.
<!-- ${component.path} -->
<h1 class="${component.name}">
    ${properties.jcr:title}
</h1>

Expressions can be escaped by prepended by a \ character, for instance \${test} will render ${test}.
Variables
Variables are containers that store data values or objects. The names of variables are called identifiers. 

The Global Objects page provides the list of all objects provided access to by HTL.

Property Access
There are two ways to access properties of variables, with a dot notation, or with a bracket notation:
${currentPage.title}
${currentPage['title']} or ${currentPage["title"]}
The simpler dot notation should be preferred for most cases, and the brackets notation should be used to access properties that contain invalid identifier characters, or to access properties dynamically.
The accessed properties can be functions, however passing arguments is not supported, so only functions that don't expect arguments can have accessed, like getters. This is a desired limitation, which is intended to reduce the amount of logic embedded into expressions. If needed, the data-sly-use statement can be used to pass parameters to the logic.

Accessing Members Dynamically
${properties[myVar]}

Block Statements
HTML Template Language (HTL) block statements are custom data attributes added directly to existing HTML. This allows easy and unobtrusive annotation of a prototype static HTML page, converting it to a functioning dynamic template without breaking the validity of the HTML code.
use
data-sly-use: 
Initialize a JavaScript object, where the source file is located in the same directory as the template. Note that the filename must be used:
<div data-sly-use.nav="navigation.js">${nav.foo}</div>


Initialize a Java class, where the source file is located in the same directory as the template. Note that the classname must be used, not the file name:
<div data-sly-use.nav="Navigation">${nav.foo}</div>


Initialize a Java class, where that class is installed as part of an OSGi bundle. Note that its fully-qualified class name must be used:

<div data-sly-use.nav="org.example.Navigation">${nav.foo}</div>

Parameters can be passed to the initialization using options. Generally, this feature should only be used by HTL code that is itself within a data-sly-template block:
<div data-sly-use.nav="${'navigation.js' @parentPage=currentPage}">${nav.foo}</div>

Initialize another HTL template that can then be called using data-sly-call:
<div data-sly-use.nav="navTemplate.html" data-sly-call="${nav.foo}"></div>

unwrap
data-sly-unwrap: Removes the host element from the generated markup while retaining its content. This allows the exclusion of elements that are required as part of HTL presentation logic but are not desired in the actual output.
For example, this
<p data-sly-use.nav="navigation.js">Hello World</p>
will produce
<p>Hello World</p>
Whereas this,
<p data-sly-use.nav="navigation.js" data-sly-unwrap>Hello World</p>
will produce
Hello World



text
data-sly-text: Replaces the content of its host element with the specified text.
For example, this
<p>${properties.jcr:description}</p>
is equivalent to
<p data-sly-text="${properties.jcr:description}">Lorem ipsum</p>




attribute
data-sly-attribute: Adds attributes to the host element.
For example, this
<div title="${properties.jcr:title}"></div>
is equivalent to
<div title="Lorem Ipsum" data-sly-attribute.title="${properties.jcr:title}"></div>

VVI: Attributes are resolved left to right, with the rightmost instance of an attribute (either literal or defined via data-sly-attribute) taking precedence over any instances of the same attribute (defined either literally or via data-sly-attribute) defined to its left.

Note that an attribute (either literal or set via data-sly-attribute) whose value evaluates to the empty string will be removed in the final markup. 
For example
<div class="${''}" data-sly-attribute.id="${''}"></div>
produces,
<div></div>

The one exception to this rule is that a literal attribute set to a literal empty string will be preserved.
FOR EXCEPTION
but,
<div class="" data-sly-attribute.id=""></div>
produces,
<div class=""></div>


To set multiple attributes, pass a map object hold key-value pairs corresponding to the attributes and their values.

element
data-sly-element: Replaces the element name of the host element.
For example,

<h1 data-sly-element="${titleLevel}">text</h1>
Replaces the h1 with the value of titleLevel.
To set other elements, XSS security must be turned off (@context='unsafe').
test

data-sly-test: Conditionally removes the host element and it's content. A value of false removes the element; a value of true retains the element

list
data-sly-list: Repeats the content of the host element for each enumerable property in the provided object.

Here is a simple loop:
<dl data-sly-list="${currentPage.listChildren}">
    <dt>index: ${itemList.index}</dt>
    <dd>value: ${item.title}</dd>
</dl>

The following default variables are available within the scope of the list:
item: The current item in the iteration.
itemList: Object holding the following properties:
index: zero-based counter (0..length-1).
count: one-based counter (1..length).
first: true if the current item is the first item.
middle: true if the current item is neither the first nor the last item.
last: true if the current item is the last item.
odd: true if index is odd.
even: true if index is even.


resource
data-sly-resource: Includes the result of rendering the indicated resource through the sling resolution and rendering process.
A simple resource includes:
<article data-sly-resource="path/to/resource"></article>

Options allow a number of additional variants:
Manipulating the path of the resource:
<article data-sly-resource="${ @ path='path/to/resource'}"></article>
<article data-sly-resource="${'resource' @ prependPath='my/path'}"></article>
<article data-sly-resource="${'my/path' @ appendPath='resource'}"></article>

Add (or replace) a selector: <article data-sly-resource="${'path/to/resource' @ selectors='selector'}"></article>

Add, replace or remove multiple selectors:
<article data-sly-resource="${'path/to/resource' @ selectors=['s1', 's2']}"></article>

Remove some selectors from the existing ones: 
<article data-sly-resource="${'path/to/resource' @ removeSelectors='selector1'}"></article>

Remove all selectors:
<article data-sly-resource="${'path/to/resource' @ removeSelectors}"></article>


Overrides the resource type of the resource: 
<article data-sly-resource="${'path/to/resource' @ resourceType='my/resource/type'}"></article>

Changes the WCM mode:
<article data-sly-resource="${'path/to/resource' @ wcmmode='disabled'}"></article>


include
data-sly-include: Replaces the content of the host element with the markup generated by the indicated HTML template file (HTL, JSP, ESP etc.) when it is processed by its corresponding template engine. The rendering context of the included file will not include the current HTL context (that of the including file);

Consequently, for inclusion of HTL files, the current data-sly-use would have to be repeated in the included file (In such a case it is usually better to use data-sly-template and data-sly-call)

template & call
data-sly-template: Defines a template. The host element and its content are not output by HTL
data-sly-call: Calls a template defined with data-sly-template. The content of the called template (optionally parameterized) replaces the content of the host element of the call.
Define a static template and then call it:
<template data-sly-template.one>blah</template>
<div data-sly-call="${one}"></div>

Define a dynamic template and then call it with parameters:
<template data-sly-template.two="${ @ title}"><h1>${title}</h1></template>
<div data-sly-call="${two @ title=properties.jcr:title}"></div>


Templates located in a different file, can be initialised with data-sly-use. Note that in this case data-sly-use and data-sly-call could also be placed on the same element:

<div data-sly-use.lib="templateLib.html">
    <div data-sly-call="${lib.one}"></div>
    <div data-sly-call="${lib.two @ title=properties.jcr:title}"></div>
</div>


HTL Global Objects
Enumerable Objects
These objects provide convenient access to commonly used information. Their content can be accessed with the dot notation, and they can be iterated-through using data-sly-list or data-sly-repeat.

properties	List of properties of the current Resource.
Backed by org.apache.sling.api.resource.ValueMap

pageProperties	List of page properties of the current Page.
Backed by org.apache.sling.api.resource.ValueMap

inheritedPageProperties	List of inherited page properties of the current Page.
Backed by org.apache.sling.api.resource.ValueMap



Java-backed Objects


Use-API
	Java Use-API	JavaScript Use-API
Pros	•	faster
•	can be inspected with a debugger
•	easy to unit-test	•	can be modified by front-end developers
•	is located within the component, keeping the view logic of a component close to it's corresponding template
Cons	•	cannot be modified by front-end developers	•	slower
•	no debugger (yet)
•	harder to unit-test



JavaScript Use-API
The HTML Template Language (HTL) JavaScript Use-API enables a HTL file to access helper code written in JavaScript. This allows all complex business logic to be encapsulated in the JavaScript code, while the HTL code deals only with direct markup production.

A Simple Example
We define a component, info, located at
/apps/my-example/components/info
It contains two files:
•	info.js: a JavaScript file that defines the use-class.
•	info.html: an HTL file that defines the component info. This code will use the functionality of info.js through the use-API.

Below, info component /apps/my-example/component/info/info.js

"use strict";
use(function () {
    var info = {};    
    info.title = granite.resource.properties["title"];
    info.description = granite.resource.properties["description"];    
    return info;
});


Imfo.html. /apps/my-example/component/info/info.html

<div data-sly-use.info="Info">
    <h1>${info.title}</h1>
    <p>${info.description}</p>
</div>


We also create a content node that uses the info component at
/content/my-example, with properties:
•	sling:resourceType = "my-example/component/info"
•	title = "My Example"
•	description = "This is some example content."


Dependencies
Let's imagine that we have a utility class 
use(['../utils/MyUtils.js'], function (utils){}

Extending

Java Use-API
The HTML Template Language (HTL) Java Use-API enables a HTL file to access helper methods in a custom Java class. This allows all complex business logic to be encapsulated in the Java code, while the HTL code deals only with direct markup production.

Adding a Use-Class
A use-class should only be used when something cannot be done in HTL alone.

Local vs Bundle Java Class
The Java use-class can be installed in two ways: local or bundle. This example uses a local install.
In a local install, the Java source file is placed alongside the HTL file, in the same repository folder. The source is automatically compiled on demand. No separate compilation or packaging step is required. 
In a bundle install, the Java class must be compiled and deployed within an OSGi bundle using the standard AEM bundle deployment mechanism (see Bundled Java Class).
A local Java use-class is recommended when the use-class is specific to the component in question.
A bundle Java use-class is recommended when the Java code implements a service that is accessed from multiple HTL components.

Java package is repository path
When a local install is used, the package name of the use-class must match that of the repository folder location, with any hyphens in the path replaced by underscores in the package name.

Extending WCMUse
While there are number of ways of incorporating a Java class with HTL (see Alternatives to WCMUse), the simplest is to extend the WCMUse class:

import com.adobe.cq.sightly.WCMUse;
  
public class Info extends WCMUse {
     
    ...
}


Initializing the class
When the use-class is extended from WCMUse, initializiation is performed by overriding the activate method:
public class Info extends WCMUse {
 @Override
    public void activate() throws Exception {
}}

Context
Typically, the activate method is used to precompute and store (in member variables) the values needed in your HTL code, based on the current context (the current request and resource, for example). 
The WCMUse class provides access to the same set of context objects as are available within an HTL file.


Getter methods
Once the use-class has initialized, the HTL file is run. During this stage HTL will typically pull in the state of various member variables of the use-class and render them for presentation. 
To provide access to these values from within the HTL file you must define custom getter methods in the use-class according to the following naming convention:
•	A method of the form getXyz will expose within the HTL file an object property called xyz.
data-sly-use attribute
The  data-sly-use attribute is used to initialize the use-class within your HTL code.

Local identifier
The identifier 'info' (after the dot in data-sly-use.info) is used within the HTL file to identify the class. The scope of this identifier is global within the file, after it has been declared. It is not limited to the element that contains the data-sly-use statement. 
<div data-sly-use.info="Info">
    <h1>${info.lowerCaseTitle}</h1>
    <p>${info.lowerCaseDescription}</p>
</div>

Getting properties
The identifier info is then used to access the object properties title and description that were exposed through the getter methods Info.getTitle and Info.getDescription.


Beyond The Basics

Passing parameters to a use-class.

Parameters can be passed to a use-class upon initialization. For example, we could do something like this:
<div data-sly-use.info="${'Info' @ text='Some text'}">
    <h1>${info.lowerCaseTitle}</h1>
    <p>${info.lowerCaseDescription}</p>
    <p>${info.upperCaseText}</p>
</div>
Here we are passing a parameter called text.

In use-class,  parameter is accessed through the WCMUse method , get("text", String.class);

Only Pass Parameters from data-sly-template
While the above example is technically correct, it actually does not make much sense to pass a value from HTL to initialize a use-class, when the value in question is available in the execution context of the HTL code (or, trivially, the value is static, as above).
The reason is that the use-class will always have access to the same execution context as the HTL code. This brings up an import point of best practice:
Note : Passing a parameter to a use-class should only be done when the use-class is used in a data-sly-template file which itself is called from another HTL file with parameters that need to be passed on.
	
create a separate data-sly-template file
takes a single parameter 
It then initializes the Java use-class  with the local name and passes it the value of the template parameter as the use-class parameter.
The body of the template gets the property , displays that value.

Bundled Java Class
With a bundle use-class the class must be compiled, packaged and deployed in AEM using the standard OSGi bundle deployment mechanism. In contrast with a local install, the use-class package declaration should be named normally, and, the data-sly-use statement must reference the fully qualified class name, as opposed to just the local class name.


Alternatives to WCMUse
The most common way to create a Java use-class is to extend WCMUse. However, there are a number of other options

Suppose you have the following data-sly-use statement:
<div data-sly-use.localName="UseClass">
1.	If there exists a local file UseClass.java in the same directory as the HTL file, try to compile and load that class.  Try to adapt the current Resource to UseClass. 
2.	interpret UseClass as a fully qualified class name and try to load it from the OSGi environment.  try to adapt the current Request to UseClass. 
3.	Within HTL, bind the newly adapted or created object to the name localName. 
4.	 If UseClass implements io.sightly.java.api.Use then call the init method, passing the current execution context
5.	If UseClass is a path to a HTL file containing a data-sly-template, prepare the template.
A few significant points about the above description:
•	Any class that is adaptable from Resource, adaptable from Request, or that has a zero-argument constructor can be a use-class. The class does not have to extend extend WCMUse or even implement Use.
•	However, if the use-class does implement Use, then its init method will automatically be called with the current context, allowing you to place initialization code there that depends on that context.
•	A use-class that extends WCMUse is just a special case of implementing Use. It provides the convenience context methods and its activate method is automatically called from Use.init.


Directly Implement Interface Use
While the most common way to create a use-class is to extend WCMUse, it is also possible to directly implement the io.sightly.java.api.Use interface itself.
The Use interface defines only one method:
public void init(javax.script.Bindings bindings)
The init method will be called on initialization of the class with a Bindings object that holds all the context objects and any parameters passed into the use-class.

public class MyComponent implements Use {
   ...
    @Override
    public void init(Bindings bindings) {
 
        // All standard objects/binding are available
        Resource resource = (Resource)bindings.get("resource");
        ValueMap properties = (ValueMap)bindings.get("properties"); 
        ...
 
        // Parameters passed to the use-class are also available
        String param1 = (String) bindings.get("param1");
    }
    ...
}

HTML Template Language (HTL) introduction part 1
•	Extension of the file is changed to .html, so in case a designer wants to look at the file he can just open it in his tools.
•	We have only markup in the file, no inclusion of a global.jsp, just markup.
•	When the expression inside data-sly-test evaluates to false the whole tag while be hidden in the markup.
Custom Java-classes
Java-class, option 1
We have a few options how you can write your custom class, the first option is that your Java-class is extending the “WCMUsePojo” class.
When extending this class you are able to call methods like “getResource()”, “getCurrentPage()”, “getPageManager()” etc.
public class MyComponent extends WCMUsePojo
{

    private String myTitle;

    @Override
    public void activate() {
}}

Java-class, option 2
If you don’t feel comfortable to extend a class, you can also implement the “Use” interface.
Via the init() method you can access all the bindings that are available. These are things like “currentPage”, “resource”, “request” etc:
public class MyComponent implements Use {

    private String myTitle;

    @Override
    public void init(Bindings bindings) {
        Page currentPage = (Page) bindings.get(WCMBindings.CURRENT_PAGE);

        myTitle = currentPage.getTitle() + "new";
    }

    public String getMyTitle() {
        return myTitle;
    }
}


you can access a service from the “WCMUsePojo” class: 

        MyService service = getSlingScriptHelper (). getService (MyService.class);


use the Java Use-API to implement your custom (complex) logic into your components :
<div data-sly-use.myComponent="${'com.myproject.MyComponent' @ param1='one', param2='two'}">
    ${myComponent.calculatedValue}
</div>

you have the following:
1)	the class ‘com.myproject.MyComponent’ is instantiated
2)	two parameters are passed to the object via expression options
3)	the identifier ‘myComponent’ is used to expose the resulting object
4)	the method getCalculatedValue() is called


Now let’s look at the implementation for this, you have 5(!) options:
1.	Class that implements the Use interface
2.	Class that extends WCMUsePojo class
3.	Class that is adaptable from Resource (resource.adaptTo(YourClass))
4.	Class that is adaptable from Request (request.adaptTo(YourClass))
5.	Sling Models
6.	Using server-side JavaScript with the HTML Template Language


Option 1: Class implementing the Use interface:
In this case you need to implement init(), and do the all the logic in there. Via the bindings-object you can access all the objects also available on the component.
public class MyComponent implements Use	 {
  
    

     public void init(Bindings bindings) {

// All standard objects are available as bindings

                  Resource resource = (Resource) bindings.get("resource");

// Parameters are also passed as bindings
        String param1 = (String) bindings.get("param1");
        String param2 = (String) bindings.get("param2");
value = resource.getPath() + param1 + param2;
public String getCalculatedValue() {
        return value;
    }

}}
Note: It would also have been possible to make the “value” member of the class public to access it directly from the HTL file, instead of creating a getCalculatedValue method.


Option 2: Class extending WCMUsePojo class:


public class MyComponent extends WCMUsePojo {

    private String value;

    @Override
    public void activate() {
       // Convenience methods allow to access the default bindings
       Resource resource = getResource();

       // Parameters are can be accessed via a get() method
       String param1 = get("param1", String.class);
       String param2 = get("param2", String.class);

       value = resource.getPath() + param1 + param2;
    }

    public String getCalculatedValue() {
        return value;
    }
}

This option is similar like the Use-interface, but has some more helper functionality that you can use. Methods like getResource(), getCurrentPage() etc are already there for you to use.


Option 5: Sling Models :

You can implement Options 3 and 4 with Apache Sling Models; this saves you from creating your own adapters. Here’s an example of what that would look like:
@Model(adaptables=Resource.class)
public class MyComponent {

    @Inject
    private Resource resource;

    @Inject
    private String param1;

    @Inject
    private String param2;
    
    private String value;
    
    @PostConstruct
    public void activate() {
        value = resource.getPath() + param1 + param2;
    }
    
    public String getCalculatedValue() {
        return value;
    }
}


Calling Client Libraries from HTL
Because HTL is meant to be a general language, without specific AEM features, there is no data-sly-clientlibs feature for instance.

data-sly-use.clientlib="/libs/granite/sightly/templates/clientlib.html"
This declares a “clientlib” object, which is implemented as a template.

data-sly-call="${clientlib.all @ categories='cq.jquery'}"
You can also call “clientlib.css” and “clientlib.js” if you only want to output the CSS or JS:
data-sly-call="${clientlib.js @ categories='clientlib1,clientlib2'}"
data-sly-call="${clientlib.css @ categories='clientlib1,clientlib2'}"
Internationalization within Sling (and CQ)
Within Sling, translations are stored within the repository as key/value pairs. Once defined, the developer is able to use the key/value pairs stored in the repository to populate strings used in a graphic interface such as a Web page.
CQ has additional tools for internationalization than those provided by Sling. 
internationalization within Sling
Locale may refer to a set of parameters that defines the user's language, region and any special variant preferences that the user wants to see in their user interface. Usually a locale identifier consists of at least a language identifier and a region identifier.

Locales within Java can be defined by three different properties: the language, the region and the variant. The primary defining property of a locale is a human language. Regions are used because each language can have several dialects and usage of the language varies greatly based on the region it is spoken and written. For that reason, a region code can be associated with a language. In that way, Canadian French may have its own definitions and translations and European French a different set. Additional information about the locale can be defined in the variant property. This property can contain information about a specific locale that is not covered by the other two properties.

Locales within Java can be defined by three different properties: the language, the region and the variant. The primary defining property of a locale is a human language. Regions are used because each language can have several dialects and usage of the language varies greatly based on the region it is spoken and written. For that reason, a region code can be associated with a language. In that way, Canadian French may have its own definitions and translations and European French a different set. Additional information about the locale can be defined in the variant property. This property can contain information about a specific locale that is not covered by the other two properties.
Key/value pairs
technical they are translation segments. Translation implies taking a word or phrase and finding the best match in another language. Translation segment is what you get after someone has done the translation for a specific use and the results are saved in a look-up table.
The value of translation segment has a very specific meaning. When the phrase, OK, is used on a button the translation segment in another locale for that phrase is not necessarily a direct translation of the word, OK, but what the OK button is called in the target locale.
Translation segment is very context driven. Because of that it can contain style information or substitutions indicated for data set at run time. It can even be a pattern for how information, such as a date or number, is rendered in a locale.
Within Sling, key/value pairs are organized by locale. If a site supports two languages, matching key/value pairs should exist for both. The locales CQ defines key/value pairs for can be seen at /libs/wcm/core/i18n.

Those keen of eye may notice that the locale code, en, is not there. In Java, if the value of a key is requested for a locale and that key does not exist, an exception is thrown. Not so in Sling. If a key is not defined in a locale Sling does not throw an exception. Instead, the key itself is returned. The keys for the key/value pairs in /libs/wcm/core/i18n are the translations in English. Since the locale for English does not exist the key is returned when the value of a key for the locale, en, is requested.
Translations in the repository
As can be seen for the CQ translations at /libs/wcm/core/i18n, the key/value pairs are stored by locale. The locale node must use the mixin, mix:language, and have the property, jcr:language, defined with a locale. In addition, the locale node may have the property, sling:basename. The sling:basename property is either a String or String array of names that can be used a labels or tags to filter translations with. The name of the locale node is not significant and can be anything.
Name the locale node to match the locale within jcr:language or name of the language. For example, name a locale node for English either English or en. The primaryType of the locale node is not significant for translations.
Within the locale node are key/value child nodes, each one containing the information for a single key/value pair. These child nodes must either have the primaryType of sling:MessageEntry or they must have sling:Message as a mixin. The key/value node must contain a property, sling:message, that is the value for the key. If the property, sling:key, exists then that value is used as the key. If the sling:key property does not exist then the name of the node is used as the key. Following the Be Nice Rule, name the key/value node the name of the key. If you do that, the sling:key property is redundant.
i18n implementation using Sightly
1) Create a i18n node of type sling:Folder as below
2) Create a language node of type sling:Folder under i18n of mixin type mix:language and add a property called jcr:language and assign value of lang code  
3) Create a message node of type sling:MessageEntry and a property called sling:key which will used to pull the value of the variable and also add a property called sling:message which will specify the value of the key as below
As soon as you create this structure you can look in CQ5-Translator and you should have similar translations created :
b. Normal way to implement i18n in Sightly : 
We can implement i18n directly by using the below syntax :
${'key' @ i18n}
${'key' @ i18n, source='user', hint='Translation Hint'}
${'key' @ i18n, locale='en', hint='Translation Hint'}
<template data-sly-template.i18="${@ key}">
 ${key @ i18n}
</template>

<div data-sly-call="${i18 @ key='key-name'}"></div>



Using internationalization within JSP

When the <sling:defineObjects /> tag is used within a JSP page, the slingRequest value is created. The slingRequest implements the SlingHttpServletRequest interface and has a couple of very useful methods for internationalization: getLocale(), getLocales(), getResourceBundle(Locale), and getResourceBundle(String, Locale).
The getLocale() method gets the default Locale of the request. The getLocales() method gets all of the methods for a request. Typically the value for these come from the browser.
The method, getResourceBundle(Locale), gets a ResourceBundle instance that has all of the found key/value pairs for the locale. The method, getResourceBundle(String, Locale), gets a ResourceBundle with all of the key/value pairs for a base name and a locale. The ResourceBundle interface has a method, getString(String), in which the argument is the key and the value of the key is returned. If the ResourceBundle does not have that key, the value returned is the key itself. One thing to keep in mind is that a ResourceBundle is not the same thing as an OSGi bundle. They are two different concepts using the same name.
<%= slingRequest
.getResourceBundle(slingRequest.getLocale())
.getString(“hello_world”) %>

Internationalization support in Sling consists of four methods in the SlingHttpServletRequest interface:
•	getLocale() -- Returns the primary Locale for the current request. This method is inherited from the javax.servlet.ServletRequest interface.
•	getLocales() -- Returns the Locale instances for the current request. This method is inherited from the javax.servlet.ServletRequest interface.
•	getResourceBundle(Locale) -- Returns a ResourceBundle for the given Locale. This method is specific to Sling.
•	getResourceBundle(String, Locale) -- Returns a ResourceBundle of a given base name for the given Locale. This method is specific to Sling.
These methods have a default implementation in the org.apache.sling.core bundle and an extended and extensible implementation in the org.apache.sling.i18n bundle.


Two different types of storage formats are supported for the individual dictionaries
sling:MessageEntry based
The (direct) child nodes of the mix:language node must have the jcr:primaryType set to sling:MessageEntry and must contain two special properties naming the key string and the message:
•	sling:key -- The sling:key property is a string property being the key for which the node contains the message(s). This property is optional. If it is not set the key is determined by the resource name of the parent sling:messageEntry.
•	sling:message -- The sling:message property represents the resource for the key.
It is only required that the message nodes are located below mix:language nodes. Such structures may also be scattered in the repository to allow storing message resources next to where they are most likely used, such as request scripts.

JSON-file based
Since Version 2.4.2 the i18n bundle supports dictionaries in JSON-format (SLING-4543). Since loading such dictionaries is much faster than loading the ones based on sling:MessageEntrys this format should be used preferably. This format is assumed if the mix:language resource name is ending with the extension .json. The parser will take any "key":"value" pair in the JSON file, including those in nested objects or arrays. Normally, a dictionary will be just a single json object = hash map though.
   /libs/languages
           +-- english.json (nt:file, mix:language)
           |    +-- jcr:language = en
           |    +-- jcr:content (nt:resource)
           |         + jcr:data (containing the actual JSON file)
           +-- deutsch.json (nt:file, mix:language)
                +-- jcr:language = de
                +-- jcr:content (nt:resource)
                    + jcr:data (containing the actual JSON file


the message for the same key in /apps overwrites the one in /libs (if both are for the same locale and base name). Within those categories the order is non-deterministic, so if there is more than one entry for the same key in /apps/... (for the same locale and base name), any of those entries may be used.
The locale hierarchy is ordered like this:
1.	<Language> <Country> <Variant>
2.	<Language> <Country>
3.	<Language>
4.	<Default Locale>, usually en
So for the locale de-DE-MAC the fallback order would be
1.	de-DE-MAC
2.	de-DE
3.	de
4.	en


Localized strings can be stored in several dictionaries in the repository. AEM system dictionaries are located below the /libs node. You can create dictionaries for your components below the /apps node. The AEM internationalization framework combines the dictionaries and makes them available in Sling as a single ResourceBundle object. When components are rendered, they retrieve translated strings from the resource bundle. The combined dictionaries are also deployed on the web server in JSON format to provide translated strings to Javascript code in web pages. 


AEM provides a console for managing the various translations of texts used in component UI. This console is available at http://<hostname>:<port-number>/libs/cq/i18n/translator.html;

Internationalizing Strings in Java and JSP Code
The com.day.cq.i18n Java package enables you to display localized strings in your UI. The I18n class provides the get method that retrieves localized strings from the AEM dictionary. The only required parameter of the get method is the string literal in the English language. English is the default langauge for the UI. The following example localizes the word Search:
i18n.get("Search"); 
Identifying the string in the English language differs from typical internationalization frameworks where an ID identifies a string and is used to reference the string at runtime. Using the English string literal provides the following benefits:
•	Code is easy to understand.
•	The string in the default language is always available.
Determining the User's Language
There are two ways to determine the language that the user prefers:
•	For authenticated users, determine the language from the preferences in the user account.
•	The locale of the requested page.
The language property of the user account is the preferred method because it is more reliable. However, the user must be logged in to use this method.
Creating the I18n Java object
The I18n class provides two constructors. How you determine the user's preferred language determines the constructor to use.
To present the string in the language that is specified in the user account, use the following contstructor (after importing com.day.cq.i18n.I18n):
I18n i18n = new I18n(slingRequest);
The constructor uses the SlingHTTPRequest to retrieve the user's language setting.


To use the page locale to determine the language, you first need to obtain the ResourceBundle for the language of the requested page:
Locale pageLang = currentPage.getLanguage(false);
ResourceBundle resourceBundle = slingRequest.getResourceBundle(pageLang);
I18n i18n = new I18n(resourceBundle); 

Internationalizing a String
Use the get method of the I18n object to internationalize a string. The only required parameter of the get method is the string to internationalize. The string corresponds with a string in a Translator dictionary. The get method looks up the string in the dictionary and returns the translation for the current language.
The first argument of the get method must comply with the following rules:
•	The value must be a string literal. A variable of type String is not acceptable.
•	The string literal must be expresse on a single line.
•	The string is case-sensitive.
i18n.get("Enter a search keyword");
Including Variables in Localized Sentences
Include variables in the localized string to build contextual meaning into a sentence. For example, after logging into a web application, the home page displays the message "Welcome back Administrator. You have 2 messages in your inbox." The page context determines the user name and the number of messages.
In the dictionary, the variables are represented in strings as bracketed indexes. Specify the values of the variables as arguments of the get method. The arguments are placed following the translation hint, and the indexes correspond with the order of the arguments:
i18n.get("Welcome back {0}. You have {1} messages.", "user name, number of messages", user.getDisplayName(), numItems);

The internationalized string and the translation hint must exactly match the string and comment in the dictionary. You can omit the localization hint by providing a null value as the second argument.
Using the Static Get Method
The I18N class defines a static get method that is useful when you need to localize a small number of strings. In addition to the parameters of an object's get method, the static method requires the SlingHttpRequest object or the ResourceBundle that you are using, according to how you are determining the user's preferred language:
•	Use the user's language preference: Provide the SlingHttpRequest as the first parameter.
I18n.get(slingHttpRequest, "Welcome back {}. You have {} messages.", "user name, number of messages", user.getDisplayName(), numItems); 
•	Use the page language: Provide the ResourceBundle as the first parameter.
I18n.get(resourceBundle,"Welcome back {}. You have {} messages.", "user name, number of messages", user.getDisplayName(), numItems); 
Internationalizing Strings in Javascript Code
The Javascript API enables you to localize strings on the client. As with Java and JSP code, the Javascript API enables you to identify strings to localize, priovide localization hints, and include variables in the localized strings.
The granite.utils client library folder provides the Javascript API. To use the API, include this client library folder on your page. Localization functions use the Granite.I18n namespace.
Before you present localized strings, you need to set the locale using the Granite.I18n.setLocale function. The function requires the language code of the locale as an argument:
Granite.I18n.setLocale("fr");
To present a localized string, use the Granite.I18n.get function:
Granite.I18n.get("string to localize");
The following example internationalizes the string "Welcome back":
Granite.I18n.setLocale("fr");
Granite.I18n.get("string to localize", [variables], "localization hint");

The function parameters are different than the Java I18n.get method:
•	The first parameter is the string literal to localize.
•	The second parameter is an array of values to inject into the string literal.
•	The third parameter is the localization hint.
The following example uses Javascript to localize the "Welcome back Administrator. You have 2 messages in your inbox." sentence:
Granite.I18n.setLocale("fr");
Granite.I18n.get("Welcome back {0}. You have {1} new messages in your inbox.", [username, numMsg], "user name, number of messages");

Internationalizing Strings from JCR Nodes
UI strings are often based on JCR node properties. For example, the jcr:title property of a page is typically used as the content of the h1 element in the page code. The I18n class provides the getVar method for localizing these strings.
The following example JSP script retrieves the jcr:title property from the repository and displays the localized string on the page:
<% title = properties.get("jcr:title", String.class);%>
<h1><%=i18n.getVar(title) %></h1>

Specifying Translation Hints for JCR Nodes
Similar to translation hints in the Java API, you can provide translation hints to distinguish duplicate strings in the dictionary. Provide the translation hint as a property of the node that contains the internationalized property. The name of the hint property is comprised of the name of the internationalized property name with the _commentI18n suffix:
${prop}_commentI18n
For example, a cq:page node includes the jcr:title property which is being localized. The hint is provided as the value of the property named jcr:title_commentI18n.


Real Time Business challenges
Change main page after AEM instance start
Author project.html starting page to Welcome.html page

go to http://localhost:4502/crx/explorer/browser/index.jsp

Next go to /libs/cq/core/config.author/com.day.cq.commons.servlets.RootMappingServ
Right click on the property rootmapping.target and select EDIT.

Now change the value of rootmapping.target to welcome.html from project.html.

Configuring Adobe Experience Manager 6 to use Apache Directory Service
Required Skills	LDAP,AEM
Tested On	Adobe Experience Manager 6, 6.1

You can configure Adobe Experience Manager (AEM) 6 to  synchronize user account information from a third-party LDAP service. By configuring AEM to use a third-party LDAP service, you can authenticate LDAP users when logging into AEM.
	
Prerequisites
install AEM 6 or 6.1
Install ApacheDS
Install Apache Directory
1.	Download the latest ApacheDS from http://directory.apache.org.
2.	Run the installer for your operating system, follow the installation instructions on the download page, and proceed with the default installation settings.
3.	Download Apache Directory Studio from the same URL and install it. 

Create a new user in ApacheDS
use Apache Directory Studio to add LDAP user data.
Adding a user to ApacheDS 
1.	Start Apache Directory Studio.
2.	Click LDAP> New Connection and enter the following values:
     
•	Connection Name: ldap
•	Host: localhost
•	Port: 10389
•	Encryption: no encryption
•	Authenticaion method: simple authentication
•	User DN: uid=admin,ou=system
•	Password: secret


3.	Click Finish.
4.	Under Root, create an entity dc=example,dc=com.
5.	From dc=example,dc=com, select New, New Entity.
6.	Select Create entity from scratch. 
7.	From the left pane, select person and uidObject. 
8.	Specify the following LDAP attributes.
 
  
9.	Add any other LDAP attributes you want and click Finish.  




Configure AEM with ApacheDS

To configure AEM 6 to use LDAP, configure these OSGi configuration settings:
•	Apache Jackrabbit Oak LDAP Identity Provider -  defines how users are retrieved from the LDAP server
•	Apache Jackrabbit Default Sync Handler - defines how the Indetity Provider users and groups will be synchronized
•	Apache Jackrabbit External Login Module - defines which Identity Provider and Sync Handler 

Apache Jackrabbit Oak LDAP Identity Provider
Open the Felix Web Console (http://localhost:4502/system/console/configMgr) and search for the Apache Jackrabbit Oak LDAP Identity Provider config and click on the plus ‘+’ button. Add the following values (based on the LDAP settings created in this article).
•	LDAP Provider Name - name of the provider. You can specify ldap. 
•	LDAP Server Hostname - the name of the provider. Localhost is used in this example. 
•	LDAP Server Port - the port of the LDAP server. 10389 is used in this article. 
•	Bind DN - DN used for user authentication. uid=admin,ou=system is used.
•	Bind Pwd - the corresponding DN password. The value secret is used. 
•	User base DN - the base DN for user searches. In this example, dc=example,dc=example is specified. (the values entered specified using Apache Directory Studio). 
•	User Id attribute - name of the user attribute. Specify uid (this was specified in Apache Directory Studio).


 
 When done entering these values, ensure that you click Save.
 Group attributes are not used in this example. However, you can add group attributes is required.


Apache Jackrabbit Oak Default Sync Handler
In the Felix Web console, search for the Apache Jackrabbit Oak Default Sync Handler config and click on the plus ‘+’ button. Specify the Sync Handle Name and User Property Mapping as shown in the illustration and Click Save.
In this example, profile/nt:primaryType="nt:unstructured" and profile/givenName=cn values are used for User Property Mapping values. 
 
Apache Jackrabbit Oak External Login Module
In the Felix Web console, search for the Apache Jackrabbit Oak External Login Module config and click on the plus ‘+’ button. Enter the Identity Provider Name and Sync Handler Name which created before and Click Save.
The following illustration shows this configuration. 

 
Synchronize ApacheDS users 

Although you've configured AEM for use with ApacheDS, you'll not yet be able to log in to AEM as an LDAP user. You'll need to first log in as administrator, import the LDAP users, and grant them appropriate permissions.
Note: Before performing the steps in this section, log in to Adobe CQ as the LDAP user. The log in attempt will result in an error; however, the LDAP user is imported into Adobe CQ.
1. Log into AEM as an administrator.
2. Go to jmx console (http://localhost:4502/system/console/jmx). Search for External Identity Synchronization Management and click on the row.
3. Click on syncAllExternalUsers() to sync all the users manually.
4. Click the Invoke button. 
5.  Go to the Users view at http://localhost:4502/useradmin. You will see the LDAP users.
6. Click the Permissions tab and give the user appropriate permissions. For this walkthrough, grant all permissions to the user.
7. Log out of AEMdobe CQ.
8. Log into AEM as bella (and the password specified using ApacheDS) to validate the AEM LDAP integration. Now you are logged in as an LDAP user. 
Configuring Logging
When workgin with AEM and LDAP, it is always better to configure LDAP related logging.
1.	Open Config Manager (http://localhost:4502/system/console/configMgr) in the Felix console
2.	Search for Apache Sling Logging Logger Configuration. Add new logger.
3.	Aadd `org.apache.jackrabbit.oak.spi.security.authentication.external`, `org.apache.jackrabbit.oak.security.authentication.ldap`.
4.	Click Save.

Create an Adobe Experience Manager OSGi bundle that contains an OakLogin module. 


Create a class “ CustomExternalLoginModuleFactory” extends AbstractLoginModule class , implements LoginModuleFactory interface. LoginModuleFactory interface provides,
Static fields JAAS_RANKING, JAAS_CONTROL_FLAG, JAAS_REALM_NAME PARAM_IDP_NAME SYNC_HANDLER_NAME
PARAM_IDP_NAME SYNC_HANDLER_NAME provided by AbstractLoginModule


AbstractLoginModule –
AbstractLoginModule provides the means for the common authentication tasks within the Repository.

Provides methods,
@Override
1. public void initialize (Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options)
Initialize this LoginModule and sets the following fields for later usage: 
•	PrincipalProvider for user-Principal resolution.
•	LoginModuleConfig.PARAM_ADMIN_ID option is evaluated
•	LoginModuleConfig.PARAM_ANONYMOUS_ID option is evaluated
Implementations are called via doInit(CallbackHandler, Session, Map) to implement additional initialization

Parameters:
subject - the Subject to be authenticated. 
callbackHandler - a CallbackHandler for communicating with the end user (prompting for usernames and passwords, for example). 
sharedState - state shared with other configured LoginModules.
options - options specified in the login Configuration for this particular LoginModule.

Merge options with osgiconfiguration option
Creates a new configuration parameters instance by merging all params sequentially. I.e. property define in subsequent arguments overwrite the ones before.
options = ConfigurationParameters.of(osgiConfig, options);

create instance of whiteboard pattern
Whiteboard whiteboard = getWhiteboard();

get the configuration value

# idpName
String idpName = options.getConfigValue(PARAM_IDP_NAME, "");
        

Create an instance of ExternalIdentityProviderManager service

The external identity provider management. The default manager is registered as OSGi service and can also be retrieved via SecurityProvider.getConfiguration(Class)

ExternalIdentityProviderManager idpMgr = WhiteboardUtils.getService(whiteboard, ExternalIdentityProviderManager.class);

Get the provider name by passing idpName into argument of  getProvidermethod() from idpMgr
String syncHandlerName = options.getConfigValue(PARAM_SYNC_HANDLER_NAME, "");

        
#syncHandlerName
String syncHandlerName = options.getConfigValue(PARAM_SYNC_HANDLER_NAME, "");
        
SyncManager syncMgr = WhiteboardUtils.getService(whiteboard, SyncManager.class);

syncHandler = syncMgr.getSyncHandler(syncHandlerName);
            

2. public boolean login()
              throws LoginException

Method to authenticate a Subject (phase 1).
The login is devided into 3 Phases:
1) User-ID resolution
In a first step it is tried to resolve a User-ID for further validation. As for JCR the identification is marked with the Credentials interface, credentials are accessed in this phase.
If no User-ID can be found, anonymous access is granted with the ID of the anonymous user (as defined in the security configuration). Anonymous access can be switched off removing the configuration entry. 
This implementation uses two helper-methods, which allow for customization: 
•	getCredentials()
and 
•	getUserID(Credentials)

2) User-Principal resolution 
In a second step it is tested, if the resolved User-ID belongs to a User known to the system, i.e. if the PrincipalProvider has a principal for the given ID and the principal can be found via PrincipalProvider.findPrincipals(String).
The provider implemenation can be set by the configuration option with the name principal_provider.class. If the option is missing, the system default prinvipal provider will be used.


3) Verification
There are four cases, how the User-ID can be verfied: The login is anonymous, preauthenticated or the login is the result of an impersonation request (see Session.impersonate(Credentials) or of a login to the Repository (Repository.login(Credentials)). The concrete implementation of the LoginModule is responsible for all four cases: 
•	isAnonymous(Credentials)
•	isPreAuthenticated(Credentials)
•	authenticate(Principal, Credentials)
•	impersonate(Principal, Credentials)

3. public boolean commit() throws LoginException
    Method to commit the authentication process (phase 2). 
This method is called if the LoginContext's overall authentication succeeded (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules succeeded). 
If this LoginModule's own authentication attempt succeeded (checked by retrieving the private state saved by the login method), then this method associates relevant Principals and Credentials with the Subject located in the LoginModule. If this LoginModule's own authentication attempted failed, then this method removes/destroys any state that was originally saved. 
The login is considers as succeeded if the credentials field is set. If there is no principal set the login is considered as ignored. 
The implementation stores the principal associated to the UserID and all the Groups it is member of with the Subject and in addition adds an instance of (#link SimpleCredentials} to the Subject's public credentials. 

4.  public boolean abort() throws LoginException
  Method to abort the authentication process (phase 2). 
This method is called if the LoginContext's overall authentication failed. (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules did not succeed). 
If this LoginModule's own authentication attempt succeeded (checked by retrieving the private state saved by the login method), then this method cleans up any state that was originally saved. 

5.  Create  Custom External Login Module SyncUser Method

    private void syncUser(@Nonnull ExternalUser user) throws SyncException
   Root root = getRoot();
//Root - A Root instance serves as a container for a Tree. It is obtained from a ContentSession, which governs accessibility and visibility of the Tree and its sub trees.
UserManager userManager = getUserManager();
// SyncContext- SyncContext is used as scope for sync operations. Implementations are free to associate any resources with the sync context. The sync context must not be accessed concurrently and must be closed after use.
SyncContext context = null;

// SyncHandler is used to sync users and groups from an ExternalIdentityProvider. The synchronization performed within the scope of a SyncContext which is acquired during the createContext(ExternalIdentityProvider, org.apache.jackrabbit.api.security.user.UserManager, javax.jcr.ValueFactory) call. The exact configuration is managed by the sync handler instance. The system may contain several sync handler implementations with different configurations. those are managed by the SyncManager. //
context=syncHandler.createContext(idp,UserManager, ValueFactory);
// ValueFactory --The ValueFactory object provides methods for the creation Value objects that can then be used to set properties.
// ValueFactoryImpl -- class ValueFactoryImpl extends Object implements ValueFactory

// Constructor : ValueFactoryImpl(Root root, NamePathMapper namePathMapper)
   
    Root- 
    NamePathMapper- The NamePathMapper interface combines NameMapper and
     PathMapper.
    
ValueFactory = new ValueFactoryImpl(root, NamePathMapper.Default)


// call the constructor  into created sync context
 context.sync(user);
// Atomically persists all changes made to the tree attached to this root.        
    Root.commit()



6.  Create custom validation for synced user same as syncUserMethod

private void validateUser(@Nonnull String id) throws SyncException

7. Custom External Login Module CreateAuthInfo Method

private AuthInfo createAuthInfo(@Nonnull String userId, @Nonnull Set<? extends Principal> principals)



Upgrade/Migration
Upgrading to AEM6 on TarMK

The major change that AEM6 has, is at its repository level. Till CQ 5.6 version TarPM was used as a persistence manager but with AEM 6 TarPM is not supported any more by CQ. AEM 6 now comes with the MicroKernels which act as persistence managers in AEM 6.
For now AEM 6 support TarMK and MongoMK Microkernal.
Hence, upgrading to AEM 6 from CQ5.6 has three options:
	Tar MK
	Mongo MK
	CRX 2 and hence not upgrading to new Oak based repository.(Since AEM 6.1 removes support for CRX2 as well)
The basic thumb rule is that when your requirement is performance then go for TarMK as TarMk is designed for performance and if requirement is such that you need to accommodate a growing amount of work in a capable manner then go for MongoMK as it is mainly designed for scalability.
Migration to AEM 6 consists of two steps:
-- Inplace Upgrade in which we will put the aem6 jar file in place of the CQ 5.6 jar in AEM directory and then run the jar. This will upgrade the CQ to AEM 6, but repository will remain to be in CRX 2.
-- Then migrating the repository from CRX 2 to OAK.

Before starting with the inplace upgrade please follow the below maintenance tasks:
•	Make a backup of the instance that we wanted to migrate. 
•	Disable replication.
•	Stop all running workflow instances.
•	Stop all workflow launchers.
•	Remove all the custom bundles.
•	Stop CQ
•	Disable any custom authentication mechanisms such as LDAP.
•	Start CQ.
•	Run a consistency check.
•	Run a datastore garbage collect.
•	Stop instance.


Once done with the above steps, start with the inplace upgrade and you will have a CQ 5.6 upgraded to AEM6 but with the CRX2 as the repository.
Once done with the above step now we have to migrate the AEM 6 repository from CRX2 to OAK.
Below are the steps to migrate the CRX2 to OAK on MongoMK:
•	Remove com.day.crx.sling.server bundle from CQ5.6 and shut down the instance.
•	Have the AEM 6 jar into a new folder.(AEM6Upgrade)
•	Open the folder in which you have CQ 5.6 and put crx2Oak.jar file into that.
•	Run this command “java -jar crx2oak.jar [CQ 5.6 repository]
•	In our case it will be as: java -jar crx2oak-1.0.42.jar crx-quickstart\repository Oak-repository
•	Once done we will have the migrated data into the Oak-repository folder
•	Create a new folder backup and put the copy of the “datastore” from CQ5.6.1 repository to the backup folder, Also take a copy of segmentStore folder from newly created Oak-repository\segmentstore and put it under backupfolder as well.
•	Now go to the AEM6 folder where you have the AEM6 jar available.
•	Under AEM6 Folder create a new folder crx-quickstart/install
•	Create two CFG file under install folder as:
1)org.apache.jackrabbit.oak.plugins.blob.datastore.FileDataStore.cfg Edit the above file as below: path=./crx-uickstart/repository/datastore minRecordLength=4096
2)org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreService.cfg
Edit the above file as below:
#Store binaries in custom BlobStore e.g. FileDataStore
customBlobStore=true
•	Run the quickstart jar and stop it again after it has started.
•	Go to \crx-quickstart\repository of AEM 6 and delete all the content.
•	Copy the datastore and segmentstore from the backup folder and put it under \crx-quickstart\repository of AEM 6 
Now you can start AEM 6 and test the upgraded instance.
Tuning Search index configurations in AEM
Use case- excluding certain legal content from their search page.
For achieving that, overriding the default indexing required.
Steps that can be used to achieve the same:
•	Assuming that the default AEM installation is used having one CRX workspace (“crx.default”), workspace.xml needs to be modified. This file can be found under the following path :
crx-quickstart/workspaces/crx.default/workspace.xml.
 
•	Indexing_config.xml configuration: 
The configurations in workspace.xml allow you to tune the behavior of the search index, however they don’t let you modify what content is being indexed. To configure this, we need to look at the indexing_config.xml file which allows us to specify indexing rules.
In CQ versions <= 5.4 the default configuration file indexing_config.xml can be found under crx-quickstart/server/runtime/0/_crx/WEB-INF/classes. In CQ 5.5, the default configuration file is embedded in the repository bundle deployed in the OSGi container. 
•	To add a custom indexing configuration: 
Copy the default search index configuration file indexing_config.xml under crx-quickstart/repository/workspaces/crx.default/indexing_config.xml.
o	For CQ5.4 and older versions you can find this file under crx-quickstart/server/runtime/0/_crx/WEB-INF/classes/indexing_config.xml.
o	For CQ5.5, we copied the default indexing_config.xml file below for your convenience.
Now we can set a path for our custom indexing_config.xml in the SearchIndex element of workspace.xml. Open crx-quickstart/workspaces/crx.default/workspace.xml in a text editor and add an indexingConfiguration parameter as shown below:
 
https://wiki.apache.org/jackrabbit/IndexingConfiguration

Adobe CQ 5 Architecture and Project Management
Concept and Planning
• How to structure website content
• Infrastructure
• Performance
• Differing targets on author and publish
environments
• Setting target response times

• Organizing your Project
• Project Phases
• Estimating Time and Effort
• Technical Specification and Design
Reference Architecture
Checklists
Project Management and Team Roles
Risk Management
Requirement Specification
Communication and Reporting

Release Planning
Project Sign-off and Acceptance
Awareness of Objectives
Overview of potential tools
Task Breakdown
Project Documentation

Adobe CQ Q&A
CQ
	You are making configuration changes through Felix Console where will the changes will get saved?         Answer: CQ_HOME/crx-quickstart/Launchpad/config*
	OSGi configuration settings take over precedence on start-up? Answer: Repository nodes with type sling:OsgiConfig under /apps/*/config.
	How do you disable the "Target" context menu item on components in AEM 6.0? Answer: Set the property "cq:disable Targeting" to true on the cq:editConfig node.
	What are three causes if Dispatcher stopped updating cache files in the cache directory on the Webserver? 
A.	The request to the page in question contain query string parameters. 
      B.    The request to the page in question has authorization headers and dispatcher.any does 
             not contain \allowAuthorized. 
     C. Dispatcher Flush agent is disabled on publish instance.
	In a typical author, publish and dispatcher setup, where is the dispatcher flush configured? Answer: In the publish instance.
	Which property is deprecated while resolving a template (T) that can be used as a template for page (P)? Answer: allowedPaths property of T
	Assume there are multiple publish instances (publ,pub2 and pub3) serving requests for an online shopping site. The end user is allowed to provide reviews and comments for each product and about their shopping experience. The Dispatcher module is in place to load balance the requests to publish instances and there is only one author instance, named author, where content editors create the pages. When a user, named User A, provides comments and the request being served by publish Instance publ, in which three ways are these comments replicated to pub2 and pub3? (Choose three.) 
A. Configure the dispatcher flush for the author pointing to a webserver uri on which the Dispatcheris deployed and configured. 
B. Configure replication agents for the author pointing to publ, pub2 and pub3. 
D. Configure a static agent for the author.
	Which template allowed Paths expression would allow a page to be created with the path/ content / main / page1/ page2? Answer: /content/main/[^/]+(/,*)?
	You are logged in as userA and you are impersonating userB. How are your activities logged in the access.log? Answer: The logged userld is "userB" 
	Which Maven plugin allows direct installation of the bundle into AEM? Answer: maven-sling-plugin
	You have written an OSGi service with the class name com.acme.myapp.EmailUpdate, You only we this service to run on the publish instance. Which two configurations would run the service on the publish instance only?

apps/myapps/config. publish/ com.acme.myapp.EmailUpdate.config node of primary type nt:file
apps/myapps/config. publish/ com.acme.myapp.EmailUpdate node of primary type sling:OsgiConfig 
	The same OSGI configuration parameter is present under /libs/*/config.. AND /apps/*/config..and modified in both locations as well as via felix Console. During runtime, what is the reload order?  Answer: felix , /apps/*/config, /libs/*/config
	How do you delete a property inside a Node object? Answer: node.setProperty("propertyName",null);
	When configuring a custom log file on a production publish instance, which two statements are true?

A. Web Console url http://<aemhost>:<port>/system/console/slinglog provides information about Sling Logging.
C. Create a run mode based on Apache Sling Logging Logger configuration for publish run mode as org.apache.sling.commons.log.LogManager.factory.config-<identlfier>.
	Which three best practice statements are true regarding permissions and privileges A. Access rights should not be assigned on a user-by-user basis.  C. After installation, update the passwords for the default users to prevent security breaches. D. Use a test installation to ensure correct relationships between Users and Groups.
	An author and publish instance has a shared data store with a very large number of assets. Which type of replication is recommended to avoid duplication of data? Answer: Binary less replication.
	In a typical Maven project, you will have a content module that contains a file src/main/content/META-INF/vault/ filter.xml which defines the filters for the AEM package built by Maven. Answer: <filter root=7etc/designs/myproject7>
	Which two URLs will show the server logs? (Choose two.)

A. http://{server}/system/console/status-slinglogs
B. http://{server}/bin/crxde/logs

	You are creating a new OSGi configuration in the repository. When are the configuration changes applied?

Answer : Changes are applied as soon as the node is updated by restarting the service.
	Which log file in <cq-installation-dir>/crx-quickstrat/logs should you look at to see logging messages indicating events during startup?
Answer: stdout.log
	You create an nt:unstructured node inside the apps in CRXDE Lite and then you create a folder inside the apps and click save. What is the expected behavior? The folder and nt:unstructured node, none of them will get saved.
	What is the difference between extending a component and component overlay?
Overlay is to override default component functionality. Extending is to extend the component functionality through the use of Resource Hierarchy and super types
	Which has the highest preference during Sling Servlet registration?
sling.servlet.paths
	While modifying an OSGi bundle configuration from the Felix Web Console, when are configuration changes applied? Answer: Immediately as it takes precedence at runtime.
	Which is the correct way to get the ValueMap of a resource? Answer resource.adaptTo(ValueMap.class)
	Which option do you need to add to the Java-based crx-quickstart command to specify that you will be using an LDAP authentication?
Answer: Djava.security.auth.login.config=crx-quickstart/server/etc/ldap_login.conf
	How do you create a configuration for an OSGi bundle within CRX that is specific to only the author instance? Answer: Use the CRX browser to create a folder in /apps/myproject called "config.author" and then create a new node and select "sling:OsgiConfig" as the node type\
	During a workflow step a comment is added requiring an update of a paragraph on a Web page. Where does the workflow author make the change? Answer: In the content page within the workflow step.
	Which method of the ResourceResolver Interface uses resources mapping to retrieve property values? Answer: resolve()
	You are working with two components: Component A and Component B. Component B has a slightly different behavior than component A. What is the best way to reuse the default script of component A in component B? Answer: Set a property in component B called sling:resourceSuperType with the path to component A and omit the default script in component B?
	What does an Item represent in a JCR repository hierarchical content model diagram?
Answer: A Node or a Property
	You are creating a repository-based OSGi configuration. Which name should the factory configuration node have? Answer: Append "-" to the name, where identifier can be any unique name.
	How are the resources called that are passed through a workflow? Answer: Payload.
	You want to prompt a workflow user for information during the processing of a workflow step. Where is the content that the workflow user entered stored? Answer: As part of the page.
	What is the main purpose of the CQ HTML client library property that is called categories? Answer: To uniquely name a group of client libraries to be included in templates or components and to reference dependencies to other client libraries.
	Which tab in the Apache Felix Web Console displays the list of all the users that are logged in to the repository? Answer: CRX Login Tokens tab.
	A developer has customized page component in his project /apps/myproject/components/mypagecomponent from /libs/foundation/components/page. He wants to add a new tab in the dialog with two textfields, what he will do ? Answer: Copy dialog and cq:dialog from foundation page component and paste it into /apps/myproject/components/mypagecomponent and modify the same.
	You are making configuration changes through Felix Console where will the changes will get saved? Answer: CQ_HOME/crx-quickstart/Launchpad/config*
	You want to use service sendEmail() which is a function in Email service Class . Which statement is true? Answer: Use @Reference annotation to use services of Email service class
	Where will you find the impersonation details ? Answer: In audit logs
	What is use of setHandler in httpd.conf file <ifModule apache_2.c> setHandler dispatcher-handler </ifmodule> ? Answer:  It will handle all the requests to the server.
	/servlet/Mysearch is the servlet path you have defined for a custom sling servlet, than where will you register the path to use this as a service?
Answer: In “Execution Paths” in Apache Sling Resolver/Error Handler
	You want to create images for DAM with different sizes, what is needed to be done to extend the normal functionality? Answer: Extend AbstractImageServlet.
	Which property of cq:EditConfig helps in displaying some text at component’s place when no visual is there? Answer : cq:emptyText
	Where should we use Closed User Groups ? Answer: On publish server to define a group of users to access some content or DAM asset.
	How to achieve custom Workflow creation ? Answer :  Use Workflow process interface.
	How to get multiple representations with different content ? Answer: URL with Query parameter and suffix.
	What does #base=source mean in js.txt? Answer: All are in source folder. To show folder/path
where all are stored
	What is the correct way to use clientlibs with Sightly? B. <meta data-sly-call="${clientLib.all @ categories-,your.clientlib,}M data-sly- unwrap></meta>
	What is the difference between extending a component and component overlay? Answer: Overlay is to override default component functionality. Extending is to extend the component functionality through the use of Resource Hierarchy and super types.
	Which three statements about configuring a development environment for a new AEM project called "customer bank", that contains both custom OSGi services and AEM components is true? (Choose three). A. http://<aemhost>:<aemport>/system/console/depfinderls used to find the dependencies  B. The repository for AEM dependency jar files can be either http://repo.adobe.com/nexus/content/groups/public/ or the local Apache Archiva with all required dependencies  C. Create a Maven project with archtypemultimodule-content-package-archetype from the repository http:// repo.adobe.com/nexus/content/groups/public/
	You are creating a new OSGi configuration in the repository. When are the configuration changes applied? Answer: Changes are applied as soon as the node is updated by restarting the service
	You want to restrict the size of a custom log file and enable log file rotation. Which Apache Sling configuration has to be changed in the AEM Web Console?  Answer: Apache Sling Logging Writer Configuration
	The default installation location for AEM 6.0 in an Application Server is ${user.dfr}/crx- quickstart. Which method is used to change this location? Answer: Configure the sling.home parameter in the WEB-INF/web.xml file of the AEM WAR file before deployment. 
	What is the optimal way to check-out content from the JCR repository to the local file system? Answer: Use VLT export command. 
	You add "sling.run.modes=publish/f in sling.properties and start the instance using the command "java -jar . Answer: Publish 
	What does the vlt command 'resolve' do? Answer: Removes the conflict-related artifact files. 
	Configuring a custom log file on a production publish instance, which two statements are true? (Choose two). A. Web Console url http://<aemhost>:<port>/system/console/slinglog provides information about Sling Logging.  Create a run mode based on Apache Sling Logging Logger configuration for publish run mode as org.apache.sling.commons.log.LogManager.factory.config-<identlfier>. 
	Which command would you enter in your CQ Component script to get the template path of an AEM page in publisH instance? Answer: Properties-get("cq:temp|ate"/-);
	Which should be configured to create a custom log file with a different log level? Apache Sling Logging Logger Configuration
	Which is a valid out-of-the-box sling run mode?  Answer: nosamplecontent
	When installing Internet Information Services, which Application Development Feature needs to be enabled to work with the AEM Dispatcher? Answer: ISAPI Extensions
	Which OSGI bundle should be disabled to restrict web-based log viewing? Answer : Adobe CRXDE Support (com.day.crx.crxde-support)
	Which three statements about replicate permissions on a resource are true?  A. The replication rights are evaluated /bottom-up in the node tree. B. The allow replication rights has higher precedence than deny replication rights. C. To grant replication rights to a user on any resource, user has to have read permissions for/etc/replication, / bin
	Which property should be used to find the repository where the configuration changes made in the Web Console are saved? Answer. Persistent Identity (PID)
	What is the purpose of @configurationFactory ? Answer: To create new service factories , to manage and maintain many OSGi service instances.
	Which attribute of @Component makes the service configurable ? Answer: Metadata 
	[1.2,2) – whats the bundle version here ? Answer: 1.2 to 2, 1.2 excluded and 2 included
	Your system keeps crashing and is very slow. You see the below line in error logs. cacheManager: ResizeAll , What are the probable reasons for this crash ? Answer: Instances of unclosed
JcrSession
	Which log can be used to timings of the requests to an instance? Answer: Request log
	What run mode will be set for PROD environment ? Answer: Nosamplecontent
	How to start aem instance in debug mode with a specific port. Choose option with parameters such as java –Xdebug socket=”specific port no.” –jar aem-author-4502.jar
	Behavior of @SlingServlet (2 options)
Path always takes precedence even if other options like resourceType and selector are present
When both path and the resource type properties are absent , the servlet is ignored.
	Which service property does an Event Subscriber need to subscribe to an Event Handler in the OSGi Event Admin service? Answer: event.topic
	Which statement about the docroot paramter in the cache section of the CQ Dispatcher configuration file is true? Answer: It can be any path inside the filesystem that can be modified by the Web server.
	Which flag should you set when you configure the mod_rewrite rules of the Apache Web server when you are including the CQ Dispatcher module? Answer: ‘PT’ flag to send the original request through to processing pipeline for the Dispatcher to respond.
	Use of Transport user on the transport tab in reverse replication agent? Answer: Username to connect to the publish instance. Generally the admin credentials.
	How to disable prevent broken hyperlinks to external domains ? Answer: Use the Disable link checking option on the link checker transformer service
	There is a clientlibs on apps folder but access to “/apps” is blocked from dispatcher. User creates a clientlibs on “/etc” folder. What is the best way to enable the access to the client libs on “/apps” Answer: Add embed property on the “/etc” client lib and include the “/apps” client lib
	Vault filter.xml has the following settings
<filter root="/apps/myapp" />
<type = “merge”/>

What is the significance of merge? Answer: The content in package that is new / not present on aem repository is added. Content on aem repository but not on package doesn’t get changed. Content common between package and repository is updated with that from the package.
	Maven main POM uses (3 options)
o	Centralized version dependency management
o	 Transient dependency management
o	Helps creating unified jar for all sub projects
	how does a dialog inherit the properties from another dialog?  Answer: cq:include
	default log level of root log : Info
	Name of the resource upon which workflow is running : Payload
	Read the properties defined on design dialog: Current Style
	Default objects in aem , coming from foundation global.jsp(3 options) Current Node, current Design , current Node
	Query search is taking longer time. Debug is necessary. Hence the suggestion is to debug the search service. Answer: Write a log writer service to get the debug logs of the sling search service
	Developer used 3 types of runmodes author, foo, bar. How to identify the activities of the instances that run only on the foo runmode ? Answer: Create sling:folder node named config.foo and inside the folder configure the logging service.
	Annotation used to declare a service factory : @component(configurationFactory = true)
	Which one is used to maintain repository content in a tool like Subversion? Answer: Vlt
	http://somedomain/abc.html?v=10. To cache this page, what should be done ? 
Use /ignoreUrlParams
	A set of pages follow template A. You add a new component in that template and then refresh those pages again. You don’t see the component there. What is the reason? Answer? The changes on templates only starts reflecting on new pages using the template.
	An application uses SAML authentication with AEM and for this purpose the AEM granite SAML authentication handler has been configured with the saml url. But on sign in, 403 forbidden. Possible reasons? Referrer filter may have to be configured
	How to change the CRX token expiration time ? Answer: jackrabbit oak Token configuration
	How to configure MYSQL data source in aem ? Answer: Day commons JDBC connections pool
	Parent component has 4 tabs. A component overlays it and additionally, a node with property sling:hideChildren set to 2 tab names. What is the significance of this? The child nodes and the properties get removed/ignored on the new component
	Configure OSGi services via content nodes. Options were of which 3 needs to be chosen: b. Can be maintained and deployed with code c.  Will be of type sling:osgi d.  Can be differentiated using runmode.
	There is an external dependency that you have included in your pom.xml file. But when you install the bundle in felix console, bundle is not active. To include the classes from the external dependency, which one of the below will you use? Answer: Include-Resource 
	Creating a repository-based OSGi config. What name should factory config have.
Ans: append -<identifier> to the name 
	How do you represent content in json format Ans: change extension to .json
	You want to create a custom logo component extending behavior of OOB logo component. How will you define that? Answer: slingResourceSuperType: foundations/component/logo
	You have created some nested components? Then which listeners are compulsory to be linked with nested component? Answer:  aftermove, aftercopy
	Where will you find the impersonation details ? Answer: In audit logs
	/servlet/Mysearch is the servlet path you have defined for a custom sling servlet, than where will you register the path to use this as a service? Answer: In execution paths in Apache Sling Resolver/Error Handler
	What is the use of DAY CQ ROOT MAPPING? Answer: to define the path to be open from root
	Which three statements about replicate permissions on a resource are true? (Choose three).
A. The replication rights are evaluated /bottom-up in the node tree. 
B. The allow replication rights has higher precedence than deny replication rights. 
C. To grant replication rights to a user on any resource, user has to have read permissions for/etc/replication, / bin
	Disable web-based log viewing for all users, which bundle needs to be stopped?
Ans: Day CRXDE Support bundle
	Exports from a JCR repo to the local file system. Ans: VLT export , VLT import - local to repo
	How to read the template from the page on Publish server? Answer: currentPage.getProperties().get("cq:template", "")
	Where should we use Closed User Groups? Answer: Ans: On publish server to define a group of users to access some content or DAM asset.
	sightly JSP include. Answer: <div data-sly-include="include.jsp " />
	Web console config change Answer: reflect immediately
	Meaning of #base = myfolder  in js.txt
Ans: to show the folder or path where all the js files are stored.
	Under apps/projectfolder, Create nt:unstructured node + new folder + save. what will happened?
Ans: we can't create an nt:unstructured node as a child of nt:folder node.
"Could not save changes. Received 409 (Conflict) for saving changes in workspace crx.default. No child node definition for testntfolder found in node /apps/metro/components.
	Parsys component best ways to override parsys component
. create parsys from scratch
. copy libs/foundation/parsys and put apps/foundation/parsys & ovrrride jsp
. copy jsp and override
. copy entire comp inside apps/myapp/components/parsys and resourcesupertype to libs/foundation/parsys
	How do you disable the "Target" context menu item on components in AEM 6.0?  Answer: Set the property "cq:disable Targeting" to true on the cq:editConfig node
	Rotate log files and maximum size log files api , Ans: Apache Sling Logging Configuration
	ACL permissions stored under which path? Ans: Resource-based ACLs are stored per resource/node in a special child rep:policy node.
	How to Install OSGI in AEM Answer: osgi-sling-maven
	How to Schedule a purge job for completed workflow instances? Ans: Work Flow Purge Schedule
	How to Debug a particular class in cq. Ans: add that class apckage in apache Logging Logger COnfigurarion in Debug or error
	How to run CQ workflow Maintenance and reporting operatrion using JMX. Ans: system/console/jmx/com.adobe.granite.workflow.
	How to redirect CQ data Store to specific Disk? Ans: cex-quickstart/repository/repository.xml
	Which is WRONG –currentResource
	whenu create component @componnet param configfactory=true what does it do
Ans: creating configuration
	if dispatcher is not optimally configured, what causes it may be - ans: extra load on publisher copied textimage from libs to apps. made changes renamed to mytextimage. When will overlay happen – Answer: by redering different jsp, by creating dialog
	automatic logout(token expiry) 12 hours. how to set it to 14 hours. Ans: Apache Jackrabbit Oak Token Configuration
	Which is the correct way to login when there is user mapping n service? Ans: Slingrepository.loginService(String subServiceName, String workspace)
	Ignoreurlparams - use it to enable caching on a given configuration.
	What is use of parent pom? Ans (Centralized management of dependency)
	Saml authentication 403 error. Why? (Scenerio based question) - Ans: referral filter
	How to view debug logs? Answer-  start aem in debug mode




Aem 6.2 Business challenges:
Templates : 
             Home page ,  connected services
 Design of Home page:
   

Head : Renders the head markup of a sightly page , data-sly-test="${wcmmode.edit || wcmmode.preview || wcmmode.disabled} ,  data-sly-call="${clientLib.css @ categories='mygenesis.all'}

Body :  header , footer , content 

           Header:     component incudes global header , data-sly-resource="${'globalheader' @ resourceType='/apps/components/components/configuration/globalheader/blocklogo'}"


Canvas login drag and drop , search box include
                

               Content: blank parsys


          Login , home page tiles , banner component (1 text field and two configurable image) banner button (3 text and one image) banner header( 3 text and 1 link) , social media icon

                 Footer: <sly data-sly-resource="${'globalFooter' @ resourceType='/apps/components/components/configuration/globalfooter'}" data-sly-unwrap></sly>
</div>
Globalfooter : footer-top-links  with head text and mutifileds with text and link



<sly 


data-sly-resource="${'footerBottom' @ resourceType='/apps/components/components/configuration/footerBottom'}" data-sly-unwrap></sly>

footer-bottom : Footerbottom: copyright text , privacy policy , Privacy Policy URL, Terms of Use Text, Terms of Use  URL,  Connected Services Text, Connected Services URL


            

  


 Design of Connected service page


Page after the login authentication,


Head , body 

Head;

Body: <header data-sly-include="header.html"></header>
	
	<div id="page-body" data-sly-include="content.html"></div>

	<footer data-sly-include="footer.html"></footer>

data-sly-call="${clientLib.js @ categories='mygenesis.connectedServices'}"></sly>





Body includes,
banner-container: image head description
tab-navigation contain container inside body :  remote action, Safeguard Alerts , Subscription, Connected Services Help


remote action container consist of vehicle-info <span>2017 Genesis G80 3.8L</span>
                <span>VIN: KMHGN4JB5HU161113</span>

And multiple manage-settings-link , Start Engine, Stop Engine , Lock Doors, Unlock Doors, Lights, Car Finder , Destination Search	(Easily find and send destinations to your Genesis)

Vehicle Status : Request History and refresh

Safeguard Alerts 
Geo Fence Alert , Carfew Alert Speed Alert Valet Alert






section-banner-appstores component

includes 1 bg image , 1 text , 2 icons for apple store , google play store  and its link

Knowledge Center help which includes,  multiple tables with 1 image ,  two links and paragraph




Services for login,


Hitting login service  /vsUser/v1.0/LOGIN ,

Thorugh servlet ConnectedCarServlet   getAccessToken(String userName, String password)


By creating http connection

HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Content-Type", "application/json");            
            conn.setRequestProperty("COMPANY", this.company);
            conn.setRequestProperty("SENDER", this.sender);
            conn.setRequestProperty("RECEIVER", this.receiver);
            conn.setRequestProperty("IFID", this.ifid);
            conn.setRequestProperty("Authorization", this.authorization);
            conn.setRequestProperty("SESSIONID", "S5");
            conn.setRequestProperty("BRANDID", "G");
            


access_token  OwnerProfileInfo       String encrypted_token = cryptoSupport.protect(token);


Gets the Access Token for the logged in User


Reads all the json object
getEnrollmentDetails(String access_token, String userid, String vin) {
        JSONObject enrollmentDetails_json = null;
        HttpResponse response = null;
        String param = "/vsEnrollment/v1.0/EMAIL/"+userid;
        try {
        	//EncryptionService encryptionService = new EncryptionService();
        	//String decrypted_token = encryptionService.decrypt(access_token);
        	String decrypted_token = cryptoSupport.unprotect(access_token);
        	log.info("decrypted_token=----"+decrypted_token);
        
            HttpClient httpclient = HttpClientBuilder.create().build();
            HttpGet httpGet = new HttpGet(this.restURL+param);
            log.info("url--- "+this.restURL+param);
            httpGet.addHeader("COMPANY", this.company);
            httpGet.addHeader("SENDER", this.sender);
            httpGet.addHeader("RECEIVER", this.receiver);
            httpGet.addHeader("IFID", "OP_IENR001");
            httpGet.addHeader("Authorization", this.authorization);
            httpGet.addHeader("ACCESS_TOKEN", decrypted_token);
           // httpGet.addHeader("Content-Type", "application/json");
            httpGet.addHeader("SESSIONID", "S5");
            httpGet.addHeader("USERNAME", userid);
            httpGet.addHeader("X_CUID", "TLAHS6H6");
            httpGet.addHeader("IMPERSONATEDUSERCUID","TLAHS6H6");
            httpGet.addHeader("FROM","CWP");
            httpGet.addHeader("VIN", vin);            

            response = httpclient.execute(httpGet);




for remote action 

@SlingServlet(
        methods = {"GET"},
        paths = {"/bin/common/remoteAction"},
        metatype = true,
        extensions = {"json"},
        label = "Connected Car Servlet"
)
@Properties({
        @Property(name="service.pid", value="com.mygenesis.components.core.servlets", propertyPrivate=false),
        @Property(name = "service.description", value = "Connects to Covisint REST API", propertyPrivate=false),
        @Property(name="service.vendor",value="Wipro Technologies", propertyPrivate=false),
        @Property(name = "label", value = "connectRestAPI")
})

public class RemoteActionServlet extends SlingSafeMethodsServlet {

    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	private static final Logger log = LoggerFactory.getLogger(RemoteActionServlet.class);

    @Reference
    ConnectedCarServices carServices;
    
    @Reference
    protected ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) {
        try {
            // Fetch the request parameters from the request
            log.info("== Inside doGet Method == ");
            //String userId = request.getParameter("user");
            
            String service = request.getParameter("service");
            log.info("Service from query Param ==> " + service);
            
            String vin = request.getParameter("vin");
            log.info("VIN from query Param ==> " + vin);
            
            String username = request.getParameter("username");
            log.info("UserName from query Param ==> " + username);
            
            String token = request.getParameter("token");
            log.info("Token from query Param ==> " + token);
            
            String pin = request.getParameter("pin");
            log.info("PIN from query Param ==> " + pin);
            
            //changes for remote start ends here
              
            response.setContentType("text/html");
            response.setHeader("Cache-Control", "no-cache");
            //response.getWriter().write(pin_response);
            
            String pin_response = carServices.validatePIN(pin,vin,username,token);
            //String pin_response = "Z:Success"; 
            log.info("Validate Pin --"+ pin_response);
            
            if(pin_response.equals("Z:Success") && service.equals("light")){
            	
            	//call flashLight code
                String flash_response = carServices.flashLights(pin,vin,username,token);
                log.info("Flash Response --"+ flash_response);
                response.getWriter().write("Light Response = " + flash_response);
            }else if(pin_response.equals("Z:Success") && service.equals("horn")){
            	
            	//call honkhorn code
            	String flashhorn_response = carServices.lightsandhorns(pin,vin,username,token);
                log.info("Flash and Horn response --"+ flashhorn_response);
                response.getWriter().write("Horn Response = " + flashhorn_response);
            }else if(pin_response.equals("Z:Success") && service.equals("remotelock")){
            	
            	//call remotelock code
            	String remotelock_response = carServices.remotelock(pin,vin,username,token);
                log.info("Remote Lock response --"+ remotelock_response);
                response.getWriter().write("Remote Lock Response = " + remotelock_response);
            }else if(pin_response.equals("Z:Success") && service.equals("remoteunlock")){
            	
            	//call remoteunlock code
            	String remoteunlock_response = carServices.remoteunlock(pin,vin,username,token);
                log.info("Remote Unlock response --"+ remoteunlock_response);
                response.getWriter().write("Remote Unlock Response = " + remoteunlock_response);
            }else if(pin_response.equals("Z:Success") && service.equals("ignitionstart")){
            	
            	//call remoteunlock code
            	
            	//changes for remote start 
                int igniOnDuration=Integer.parseInt(request.getParameter("igniOnDuration"));
                log.info("Start engine from query Param ==> " + igniOnDuration);
                
                //int airCtrl=Integer.parseInt(request.getParameter("airCtrl"));
                int airCtrl= 0;
                log.info("airCtrl from query Param ==> " + airCtrl);
                           
                String airTempvalue=request.getParameter("airTempvalue");
                log.info("temp from query Param ==> " + airTempvalue);
                
                Boolean defrost=Boolean.parseBoolean(request.getParameter("defrost"));
                log.info("defrost from query Param ==> " + defrost);
                
                //int heating1=Integer.parseInt(request.getParameter("heating1"));
                int heating1= 0;
                log.info("heated feature from query Param ==> " + heating1);
            	
                String remoteStartresp=carServices.ignitionStart(pin, vin, username, token, igniOnDuration, airCtrl, airTempvalue, defrost, heating1);
                log.info("Ignition Start Response = " + remoteStartresp);
                response.getWriter().write("Ignition Start Response = " + remoteStartresp);
            }else if(pin_response.equals("Z:Success") && service.equals("ignitionstop")){
            	
            	//call remote unlock code
            	String remoteunlock_response = carServices.ignitionStop(pin, vin, username, token, 10, 0, "72", true, 0);
                log.info("Remote Unlock response --"+ remoteunlock_response);
                response.getWriter().write("Remote Unlock Response = " + remoteunlock_response);
            }        
            else if(pin_response.equals("Z:Failure")){
            	response.getWriter().write("PIN Validatioin = " + pin_response);
            }

           
            
            
            
        }
        catch (Exception e){
        	log.info("Servlet Exception " + e.getMessage());
        }
        /*catch (JSONException je) {
            log.info("Servlet Exception " + je.getMessage());
        } catch (IOException io) {
            log.info("Servlet Exception " + io.getMessage());
        }*/
    }
    
    
  
}






Services for remote action 


@SlingServlet(
        methods = {"GET"},
        paths = {"/bin/common/remoteAction"},
        metatype = true,
        extensions = {"json"},
        label = "Connected Car Servlet"
)
@Properties({
        @Property(name="service.pid", value="com.mygenesis.components.core.servlets", propertyPrivate=false),
        @Property(name = "service.description", value = "Connects to Covisint REST API", propertyPrivate=false),
        @Property(name="service.vendor",value="Wipro Technologies", propertyPrivate=false),
        @Property(name = "label", value = "connectRestAPI")
})

public class RemoteActionServlet extends SlingSafeMethodsServlet {

    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	private static final Logger log = LoggerFactory.getLogger(RemoteActionServlet.class);

    @Reference
    ConnectedCarServices carServices;
    
    @Reference
    protected ResourceResolverFactory resourceResolverFactory;

    @Override
    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) {
        try {
            // Fetch the request parameters from the request
            log.info("== Inside doGet Method == ");
            //String userId = request.getParameter("user");
            
            String service = request.getParameter("service");
            log.info("Service from query Param ==> " + service);
            
            String vin = request.getParameter("vin");
            log.info("VIN from query Param ==> " + vin);
            
            String username = request.getParameter("username");
            log.info("UserName from query Param ==> " + username);
            
            String token = request.getParameter("token");
            log.info("Token from query Param ==> " + token);
            
            String pin = request.getParameter("pin");
            log.info("PIN from query Param ==> " + pin);
            
            //changes for remote start ends here
              
            response.setContentType("text/html");
            response.setHeader("Cache-Control", "no-cache");
            //response.getWriter().write(pin_response);
            
            String pin_response = carServices.validatePIN(pin,vin,username,token);
            //String pin_response = "Z:Success"; 
            log.info("Validate Pin --"+ pin_response);
            
            if(pin_response.equals("Z:Success") && service.equals("light")){
            	
            	//call flashLight code
                String flash_response = carServices.flashLights(pin,vin,username,token);
                log.info("Flash Response --"+ flash_response);
                response.getWriter().write("Light Response = " + flash_response);
            }else if(pin_response.equals("Z:Success") && service.equals("horn")){
            	
            	//call honkhorn code
            	String flashhorn_response = carServices.lightsandhorns(pin,vin,username,token);
                log.info("Flash and Horn response --"+ flashhorn_response);
                response.getWriter().write("Horn Response = " + flashhorn_response);
            }else if(pin_response.equals("Z:Success") && service.equals("remotelock")){
            	
            	//call remotelock code
            	String remotelock_response = carServices.remotelock(pin,vin,username,token);
                log.info("Remote Lock response --"+ remotelock_response);
                response.getWriter().write("Remote Lock Response = " + remotelock_response);
            }else if(pin_response.equals("Z:Success") && service.equals("remoteunlock")){
            	
            	//call remoteunlock code
            	String remoteunlock_response = carServices.remoteunlock(pin,vin,username,token);
                log.info("Remote Unlock response --"+ remoteunlock_response);
                response.getWriter().write("Remote Unlock Response = " + remoteunlock_response);
            }else if(pin_response.equals("Z:Success") && service.equals("ignitionstart")){
            	
            	//call remoteunlock code
            	
            	//changes for remote start 
                int igniOnDuration=Integer.parseInt(request.getParameter("igniOnDuration"));
                log.info("Start engine from query Param ==> " + igniOnDuration);
                
                //int airCtrl=Integer.parseInt(request.getParameter("airCtrl"));
                int airCtrl= 0;
                log.info("airCtrl from query Param ==> " + airCtrl);
                           
                String airTempvalue=request.getParameter("airTempvalue");
                log.info("temp from query Param ==> " + airTempvalue);
                
                Boolean defrost=Boolean.parseBoolean(request.getParameter("defrost"));
                log.info("defrost from query Param ==> " + defrost);
                
                //int heating1=Integer.parseInt(request.getParameter("heating1"));
                int heating1= 0;
                log.info("heated feature from query Param ==> " + heating1);
            	
                String remoteStartresp=carServices.ignitionStart(pin, vin, username, token, igniOnDuration, airCtrl, airTempvalue, defrost, heating1);
                log.info("Ignition Start Response = " + remoteStartresp);
                response.getWriter().write("Ignition Start Response = " + remoteStartresp);
            }else if(pin_response.equals("Z:Success") && service.equals("ignitionstop")){
            	
            	//call remote unlock code
            	String remoteunlock_response = carServices.ignitionStop(pin, vin, username, token, 10, 0, "72", true, 0);
                log.info("Remote Unlock response --"+ remoteunlock_response);
                response.getWriter().write("Remote Unlock Response = " + remoteunlock_response);
            }        
            else if(pin_response.equals("Z:Failure")){
            	response.getWriter().write("PIN Validatioin = " + pin_response);
            }

           
            
            
            
        }
        catch (Exception e){
        	log.info("Servlet Exception " + e.getMessage());
        }
        /*catch (JSONException je) {
            log.info("Servlet Exception " + je.getMessage());
        } catch (IOException io) {
            log.info("Servlet Exception " + io.getMessage());
        }*/
    }
    
    
  
}
Getting user id , vin  from session storage

	data: {"username":username,"password":password},
				success: function (data) {
					alert("data--"+data);
					var response = data;

					sessionStorage.setItem("token",JSON.stringify(response.Token));
					sessionStorage.setItem("ownerinfo",JSON.stringify(response.OwnerInfo));
					sessionStorage.setItem("vehicleInfo",JSON.stringify(response.VehicleInfo));


var tokenInfo=$.parseJSON(sessionStorage.getItem("token"))
					var id=$.parseJSON(sessionStorage.getItem("ownerinfo")) ;
					var vi=$.parseJSON(sessionStorage.getItem("vehicleInfo"));

					var token = tokenInfo.access_token;
					var username = id.OwnerProfileInfo[0].Login;
					var vin = vi.vehicleDetails.vin;

					console.info(token);
					console.info(vi.vehicleDetails.vin);
					console.info(id.OwnerProfileInfo[0].Login);





SafeGuard alert:


Servlet:
package com.mygenesis.components.core.servlets;

import org.apache.felix.scr.annotations.Properties;
import org.apache.felix.scr.annotations.Property;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.sling.SlingServlet;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.commons.json.JSONArray;
import org.apache.sling.commons.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.mygenesis.components.core.services.SafeGuardAlertServices;
import com.mygenesis.components.core.services.ServiceConstants;

@SlingServlet(
        methods = {"GET"},
        paths = {"/bin/common/alertAction"},
        metatype = true,
        extensions = {"json"},
        label = "Safe Guard Alert Servlet"
)
@Properties({
        @Property(name="service.pid", value="com.mygenesis.components.core.servlets", propertyPrivate=false),
        @Property(name = "service.description", value = "Connects to Covisint REST API", propertyPrivate=false),
        @Property(name="service.vendor",value="Wipro Technologies", propertyPrivate=false),
        @Property(name = "label", value = "connectRestAPI")
})

public class AlertActionServlet extends SlingSafeMethodsServlet
{
	
	private static final long serialVersionUID = 1L;

	private static final Logger log = LoggerFactory.getLogger(AlertActionServlet.class);
	
	 @Reference
	    SafeGuardAlertServices safeguardalertservices;
	 
	 @Reference
	    protected ResourceResolverFactory resourceResolverFactory;
	 
	   @Override
	    protected void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) {
	        try {
	            // Fetch the request parameters from the request
	            log.info("== Inside doGet Method == ");
	            //String userId = request.getParameter("user");
	            
	            String service = request.getParameter("service");
	            log.info("Service from query Param ==> " + service);
	            
	            String vin = request.getParameter("vin");
	            log.info("VIN from query Param ==> " + vin);
	            
	            String username = request.getParameter("username");
	            log.info("UserName from query Param ==> " + username);
	            
	            String token = request.getParameter("token");
	            log.info("Token from query Param ==> " + token);
	            
	            
	            //Call Get Valet alert code
	            if(service.equals("getValetAlert"))
	            {
	                 
	 			String get_Valet_alert = safeguardalertservices.getValetAlert(vin,username,token);  	            
	            
	 				log.info("Valetalert --"+ get_Valet_alert);
	 				response.getWriter().write(get_Valet_alert);
	            
	            /*if(get_Valet_alert.equals(ServiceConstants.COVISINT_SUCCESS))
	            {
	            	log.info("Valetalert --"+ get_Valet_alert);
  	            response.getWriter().write(get_Valet_alert);
	            }
	            else if(get_Valet_alert.equals(ServiceConstants.COVISINT_FAILURE))
		            {
	            	log.info("Valetalert --"+ get_Valet_alert);
	  	            response.getWriter().write(get_Valet_alert);
		            }*/
	            	 
	            }
	        
	            
	          //Call Set Curfew alert code
	            if(service.equals("setCurfewAlert"))
	            {
	            	String curfewAlertsProfilesStr = request.getParameter("curfewAlertsProfilesStr");
	                 log.info("SetCurfewAlert--"+curfewAlertsProfilesStr);
	                                
					String set_Curfew_alert = safeguardalertservices.setCurfewAlert(vin, username, token, curfewAlertsProfilesStr);  	            
	            
	 				log.info("setCurfewalert --"+ set_Curfew_alert);
	 				response.getWriter().write("setCurfewalert= " + set_Curfew_alert);
	            
	            }
	            
	          //Call Get Curfew alert code
	            if(service.equals("getCurfewAlert"))
	            {
					String get_Curfew_alert = safeguardalertservices.getCurfewAlert(vin, username, token);  	            
	            
	 				log.info("getCurfewalert --"+ get_Curfew_alert);
	 				response.getWriter().write(get_Curfew_alert);
	            
	            }
	            
	          //Call Delete Curfew alert code
	            if(service.equals("deleteCurfewAlert"))
	            {	
	            	String curfewID = request.getParameter("curfewID");
	 				String startTime = request.getParameter("startTime");
					String endTime = request.getParameter("endTime");
					String startDay = request.getParameter("startDay");
					String endDay = request.getParameter("endDay");
					String delete_Curfew_alert = safeguardalertservices.deleteCurfewAlert(vin, username, token, startTime, endTime, startDay, endDay, curfewID);  	            
	            
	 				log.info("DeleteCurfewalert --"+ delete_Curfew_alert);
	 				response.getWriter().write("deleteCurfewalert= " + delete_Curfew_alert);
	            
	            }
	            
	          //Call Set Valet alert code
	            if(service.equals("setValetAlert"))
	            {
	                   	
	              	 double distance=Double.parseDouble(request.getParameter("distance"));
	                log.info("Distance set in Miles ==> " + distance);
	                 
	 				String set_Valet_alert = safeguardalertservices.setValetAlert(vin,username,token,distance);  	            
	            
	 				log.info("Valetalert --"+ set_Valet_alert);
	 				response.getWriter().write("setValetalert= " + set_Valet_alert);
	            
	            if(set_Valet_alert.equals(ServiceConstants.COVISINT_SUCCESS))
	            {
	            	log.info("Valetalert --"+ set_Valet_alert);
  	            response.getWriter().write(set_Valet_alert);
	            }
	            else if(set_Valet_alert.equals(ServiceConstants.COVISINT_FAILURE))
		            {
	            	log.info("Valetalert --"+ set_Valet_alert);
	  	            response.getWriter().write(set_Valet_alert);
		            }
	            	 
	            }
	        
	            
	            //Call Get Speed alert code
   	            
	            if(service.equals("getSpeedAlert"))
	            {
	                 
	 			String get_Speed_alert = safeguardalertservices.getSpeedAlert(vin,username,token);  	            
	            
	 				log.info("GetSpeedalert --"+ get_Speed_alert);
	 				
	 				//if (get_Speed_alert!=null){
	 				response.getWriter().write(get_Speed_alert);
	 				//}
	            } 
	            
	        
	            
	            
	            
	      //Call Set Speed alert code
            
				if(service.equals("setSpeedtAlert") )
	            {
	            	 int speedLimit=Integer.parseInt(request.getParameter("speedLimit"));
	                 log.info("Speed limit from query Param ==> " + speedLimit);
	                 
	 				String set_Speed_alert = safeguardalertservices.setSpeedAlert(vin,username,token,speedLimit);  	            
	            
	 				log.info("SetSpeedalert --"+ set_Speed_alert);
	 				response.getWriter().write("setSpeedalert= " + set_Speed_alert);
	 				
	 				
	            
	            if(set_Speed_alert.equals(ServiceConstants.COVISINT_SUCCESS))
	            {
	            	log.info("SetSpeedalert --"+ set_Speed_alert);
  	            response.getWriter().write("setSpeedalert= " + set_Speed_alert);
	            }
	            else if(set_Speed_alert.equals(ServiceConstants.COVISINT_FAILURE))
		            {
	            	log.info("SetSpeedalert --"+ set_Speed_alert);
	  	            response.getWriter().write("setSpeedtAlert= " + set_Speed_alert);
		            }
	            	 
	            }
				
				
				//Call Get geofence alert code
   	            
	            if(service.equals("getGeoFenceAlert"))
	            {
	             
	            JSONArray get_geofence_alert = safeguardalertservices.getGeoFence(vin, username, token);  	            
	            
	 				log.info("get GeoFencealert --"+ get_geofence_alert);
	 				if (get_geofence_alert!=null){
		 				
		 				response.getWriter().write("{\"geoFenceProfiles\":"+get_geofence_alert.toString()+"}");
		            }  else{
		            	
		            	response.getWriter().write("null");
		            }
	               
	            }
	            
	            
	            //call  Get geofence alert code on "DELETE"
	            
	            
	            if(service.equals("setGeoFenceAlert_delete"))
	             {
	            	
	            	log.info("SetGeofenceAlert on DELETE -- gettting param from query parameter");      	
	             	  //  Fetch the request parameters from the request
	                
	                 String deleteGFAprofileStr = request.getParameter("deleteGFAprofileStr");
	                 log.info("SetGeofenceAlert on delete param -- deleteGFAprofileStr"+deleteGFAprofileStr);
	                                
	            	
	            	 
	            	//String geofenceProfilesString=request.getParameter("geofenceProfilesArray");
	            	
	            	//JSONObject geofenceProfilesObj= new JSONObject(geofenceProfilesString);
	            	
	            	//JSONArray jsonArray =  (JSONArray)geofenceProfilesString;
	            	
	            	//log.info("geofenceProfilesArray--delete call --"+ geofenceProfilesObj);
	            	
	 			   String set_GeoFence_alert = safeguardalertservices.setGeoFence_delete(vin,username,token, deleteGFAprofileStr ) ; 	            
	            
	 			  response.getWriter().write(set_GeoFence_alert);
	            } 
	            
	            

				//Call Set geofence alert code
	            
	            if(service.equals("setGeoFenceAlert"))
	            {
	            	 log.info("SetGeofenceAlert -- gettting param from query parameter");      	
	             	  //  Fetch the request parameters from the request
	                
	                 String type = request.getParameter("type");
	                 log.info("SetGeofenceAlert -- type"+type);
	                 
	                 String shape = request.getParameter("shape");
	                 log.info("SetGeofenceAlert -- shape"+shape);
	                 
	                 String distance  = request.getParameter("distance");
	                 log.info("SetGeofenceAlert -- distance"+distance);
	                 
	                 double geo_lat  = Double.parseDouble(request.getParameter("geo_lat"));
	                 log.info("SetGeofenceAlert -- geo_lat"+geo_lat);
	                 
	                 double geo_lng  = Double.parseDouble(request.getParameter("geo_lng"));
	                  log.info("SetGeofenceAlert -- geo_lng"+geo_lng);
	                  
	                  
	                  double georec_brlng  = Double.parseDouble(request.getParameter("georec_brlng"));
	                  log.info("SetGeofenceAlert -- georec_brlng"+georec_brlng);
	                  
	                  double georec_brlat  = Double.parseDouble(request.getParameter("georec_brlat"));
	                  log.info("SetGeofenceAlert -- georec_brlat"+georec_brlat);
	                  
	                  double georec_tllng  = Double.parseDouble(request.getParameter("georec_tllng"));
	                  log.info("SetGeofenceAlert -- georec_tllng"+georec_tllng);
	                  
	                  double georec_tllat  = Double.parseDouble(request.getParameter("georec_tllat"));
	                  log.info("SetGeofenceAlert -- georec_tllat"+georec_tllat);
	                  
	                 Boolean alert  = Boolean.parseBoolean(request.getParameter("alertStatus"));
	                 
	                 String alertStatus=null;
	                 if (alert==true){
	                     alertStatus="1";
	                     }
	                   else{
	                   	 alertStatus="0";
	                   }
	                 
	                   String geo_name  = request.getParameter("geo_name");
	                   log.info("SetGeofenceAlert -- geo_name"+geo_name);
	                   
	                   String geo_address  = request.getParameter("geo_address");
	                   log.info("SetGeofenceAlert -- geo_address"+geo_address);
	                
	 				  String set_geofence_alert = safeguardalertservices.setGeoFence(vin,username,token,distance,type,shape,geo_lat, geo_lng,georec_brlng,georec_brlat,georec_tllng,georec_tllat,alertStatus, geo_name,geo_address);  	            
	                
	 				
	 				
	 				log.info("SetGeofenceAlert --"+ set_geofence_alert);
	 				
	 				
	 				response.getWriter().write(set_geofence_alert);
	 				
	 			
	            	 
	            }
	            
	        }
	        catch (Exception e){
	        	log.error("Servlet Exception " + e.getMessage());
	        }
	
	        }
	   }




Safeguard impl


package com.mygenesis.components.core.services;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Dictionary;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Properties;
import org.apache.felix.scr.annotations.Property;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.Service;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.util.EntityUtils;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.apache.sling.commons.json.JSONArray;
import org.apache.sling.commons.json.JSONObject;
import org.apache.sling.commons.json.JSONTokener;
import org.apache.sling.commons.osgi.PropertiesUtil;
import org.osgi.service.component.ComponentContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.adobe.granite.crypto.CryptoSupport;

@Component(label = "Covisint Integration Service", description = "Configuration for Covisint Service", metatype = true, immediate = true)
@Service({SafeGuardAlertServices.class})
@Properties({
		@Property(name = ServiceConstants.COVISINT_COMPANY, description = "Covisint Company", value = { ServiceConstants.COVISINT_COMPANY_VALUE }),
		@Property(name = ServiceConstants.COVISINT_REST_URL, description = "Covisint REST API URL", value = { ServiceConstants.COVISINT_REST_URL_VALUE }),
		@Property(name = ServiceConstants.COVISINT_SENDER, description = "Covisint Sender", value = { ServiceConstants.COVISINT_SENDER_VALUE }),
		@Property(name = ServiceConstants.COVISINT_RECEIVER, description = "Covisint Receiver", value = { ServiceConstants.COVISINT_RECEIVER_VALUE }),
		@Property(name = ServiceConstants.COVISINT_IFID, description = "Covisint IFID", value = { ServiceConstants.COVISINT_IFID_VALUE }),
		@Property(
                name = ServiceConstants.COVISINT_AUTHORIZATION,
                description = "Covisint Basic Auth",
                value = { ServiceConstants.COVISINT_AUTHORIZATION_VALUE }
        ),
})


public class SafeGuardAlertServicesImpl implements SafeGuardAlertServices {

	private static final Logger log = LoggerFactory.getLogger(SafeGuardAlertServicesImpl.class);

	@Reference
	protected ResourceResolverFactory resourceResolverFactory;

	@Reference
	private CryptoSupport cryptoSupport;

	protected ResourceResolver adminResourceResolver;

	private String company;
	private String sender;
	private String receiver;
	private String ifid;
	private String authorization;
	protected String restURL;
	public String user_token;

	private String result;

	// EncryptionService encryptionService = new EncryptionService();

	/**
	 * Activate the component and process config properties.
	 *
	 * @param context
	 *            Component context
	 */
	@Activate
	public void activate(ComponentContext context) {
		Dictionary<?, ?> props = context.getProperties();

		this.company = PropertiesUtil.toString(
				props.get(ServiceConstants.COVISINT_COMPANY), "");
		this.sender = PropertiesUtil.toString(
				props.get(ServiceConstants.COVISINT_SENDER), "");
		this.receiver = PropertiesUtil.toString(
				props.get(ServiceConstants.COVISINT_RECEIVER), "");
		this.ifid = PropertiesUtil.toString(
				props.get(ServiceConstants.COVISINT_IFID), "");
		this.authorization = PropertiesUtil.toString(
				props.get(ServiceConstants.COVISINT_AUTHORIZATION), "");
		this.restURL = PropertiesUtil.toString(
				props.get(ServiceConstants.COVISINT_REST_URL), "");
	}

	/*
	 * (non-Javadoc)
	 * @ Get Valet alert implementation
	 */
	@Override
	public String getValetAlert(String vin, String username,String token) {
			JSONObject json = null;
			HttpResponse response = null;
			String param="/vsAlert/v1.0/VALET";
			String result = null;

				try {
					log.info("In Valetalert method");

					String decrypted_token = cryptoSupport.unprotect(token);
					log.info("decrypted_token=----" + decrypted_token);
					
					HttpClient httpclient = HttpClientBuilder.create().build();
					HttpGet httpGet = new HttpGet(this.restURL + param);

					log.info("URL - " + this.restURL + param);
					httpGet.addHeader(ServiceConstants.COVISINT_COMPANY, this.company);
					httpGet.addHeader(ServiceConstants.COVISINT_SENDER, this.sender);
					httpGet.addHeader(ServiceConstants.COVISINT_IFID, "OP_IALT001");
					httpGet.addHeader(ServiceConstants.COVISINT_RECEIVER,ServiceConstants.COVISINT_RECEIVER_VALUE);
					httpGet.addHeader(ServiceConstants.COVISINT_ACCESSTOKEN,decrypted_token);
					httpGet.addHeader(ServiceConstants.COVISINT_SESSIONID,ServiceConstants.COVISINT_SESSIONID_VALUE);
					httpGet.addHeader(ServiceConstants.COVISINT_USERNAME,username);
					httpGet.addHeader(ServiceConstants.COVISINT_VIN,vin);
					httpGet.addHeader(ServiceConstants.COVISINT_REGISTRATION_ID,ServiceConstants.COVISINT_REGISTRATION_ID_VALUE);
					httpGet.addHeader(ServiceConstants.COVISINT_GEN,ServiceConstants.COVISINT_GEN_VALUE);
					httpGet.addHeader(ServiceConstants.COVISINT_FROM,ServiceConstants.COVISINT_FROM_VALUE);
					httpGet.addHeader(ServiceConstants.COVISINT_AUTHORIZATION,ServiceConstants.COVISINT_AUTHORIZATION_VALUE);
					httpGet.addHeader(ServiceConstants.COVISINT_TO,ServiceConstants.COVISINT_TO_VALUE);
					httpGet.addHeader(ServiceConstants.COVISINT_USER_ID,username);
					httpGet.addHeader(ServiceConstants.COVISINT_VERSION,ServiceConstants.COVISINT_VERSION_VALUE);
					httpGet.addHeader(ServiceConstants.COVISINT_CACHE_CONTROL,ServiceConstants.COVISINT_CACHE_CONTROL_VALUE);
					
					response = httpclient.execute(httpGet);
					log.info("Response is => " + response.toString());

					// verify response is HTTP OK
					final int statusCode = response.getStatusLine().getStatusCode();
					if (statusCode != HttpStatus.SC_OK) {
						log.info("Response Code is " + statusCode);
					}

					String getResult = EntityUtils.toString(response.getEntity());
					json = (JSONObject) new JSONTokener(getResult).nextValue();
					log.info("Json Object => " + json.get("RESPONSE_STRING"));
					log.info("Result =>" + getResult);
					JSONObject response_string = json.getJSONObject("RESPONSE_STRING");
					if(response_string!=null){
						result = response_string.get("valetList").toString();
					}

				} catch (Exception e) {
					log.error(e.getMessage());
				}
				
			// TODO Auto-generated method stub
		return result;
	}

	/*
	 * (non-Javadoc)
	 * Set Valet alert implementation
	 */

	
	
	 /**
     * Reads all the json object
     * @param rd
     * @return
     * @throws IOException
     */
    private static String readAll(Reader rd) throws IOException {
        StringBuilder sb = new StringBuilder();
        int cp;
        while ((cp = rd.read()) != -1) {
            sb.append((char) cp);
        }
        return sb.toString();
    }

	@Override
	public String setValetAlert(String vin, String username, String token, double distance) {
		
		try {
			Map<String, Object> params = new LinkedHashMap<String, Object>();
            
			JSONObject json = null;
			HttpResponse response = null;
			
			
			log.info("In Valetalert method");
			String param="/vsAlert/v1.0/VALET";
			
			JSONObject userParam=new JSONObject();
			JSONObject distancevalue = new JSONObject();
			distancevalue.put("value",distance);
			distancevalue.put("unit","MILES");
        	userParam.put("distance",distancevalue);
		
        	URL url = new URL(this.restURL + param);
			log.info("URL :- " + url);
			
			String decrypted_token = cryptoSupport.unprotect(token);
			log.info("decrypted_token=----" + decrypted_token);

			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod(ServiceConstants.COVISINT_POST);
			conn.setRequestProperty(ServiceConstants.COVISINT_COMPANY,this.company);
			conn.setRequestProperty(ServiceConstants.COVISINT_SENDER,this.sender);
			conn.setRequestProperty(ServiceConstants.COVISINT_RECEIVER,ServiceConstants.COVISINT_RECEIVER_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_IFID,"OP_OALT001");
			conn.setRequestProperty(ServiceConstants.COVISINT_ACCESSTOKEN,decrypted_token);
			conn.setRequestProperty(ServiceConstants.COVISINT_SESSIONID,ServiceConstants.COVISINT_SESSIONID_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_USERNAME,username);
			conn.setRequestProperty(ServiceConstants.COVISINT_VIN,vin);
			conn.setRequestProperty(ServiceConstants.COVISINT_REGISTRATION_ID,ServiceConstants.COVISINT_REGISTRATION_ID_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_GEN,ServiceConstants.COVISINT_GEN_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_FROM,ServiceConstants.COVISINT_FROM_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_TO,ServiceConstants.COVISINT_TO_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_USER_ID,username);
			conn.setRequestProperty(ServiceConstants.COVISINT_VERSION,ServiceConstants.COVISINT_VERSION_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_CACHE_CONTROL,ServiceConstants.COVISINT_CACHE_CONTROL_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_AUTHORIZATION,ServiceConstants.COVISINT_AUTHORIZATION_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_CONTENTTYPE,ServiceConstants.COVISINT_CONTENT_TYPE_VALUE);
			
			conn.setDoOutput(true);
			 conn.getOutputStream().write(userParam.toString().getBytes());
			 
			 log.info(userParam.toString());
	            int responseCode = conn.getResponseCode();
	            Reader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8"));
	            
	            if (responseCode != HttpStatus.SC_OK) {
	                log.info("Response Code is " + responseCode);
	            }
	            
	            String jsonText = readAll(in);
	            json = new JSONObject(jsonText);
	            
	            log.info("setValetAlert Object => " + json.get("RESPONSE_STRING"));
	            log.info("setValetAlert Result =>"+ json);
	             result = json.get("E_IFRESULT").toString();


		} catch (Exception e) {
			log.error(e.getMessage());
		}
        	
		
		// TODO Auto-generated method stub
		return result;
	}

	@Override
	public String getSpeedAlert(String vin, String username,String token) {
		
		JSONObject json = null;
		HttpResponse response = null;
		String param="/vsAlert/v1.0/SPEED";
		String result = null;

		try {

			log.info("In Getspeedalert method");

		
			String decrypted_token = cryptoSupport.unprotect(token);
			log.info("decrypted_token=----" + decrypted_token);
			
			HttpClient httpclient = HttpClientBuilder.create().build();
			HttpGet httpGet = new HttpGet(this.restURL + param);

			log.info("URL - " + this.restURL + param);
			httpGet.addHeader(ServiceConstants.COVISINT_COMPANY, this.company);
			httpGet.addHeader(ServiceConstants.COVISINT_SENDER, this.sender);
			httpGet.addHeader(ServiceConstants.COVISINT_IFID, "OP_IAL004");
			httpGet.addHeader(ServiceConstants.COVISINT_RECEIVER,ServiceConstants.COVISINT_RECEIVER_VALUE);
			httpGet.addHeader(ServiceConstants.COVISINT_ACCESSTOKEN,decrypted_token);
			httpGet.addHeader(ServiceConstants.COVISINT_SESSIONID,ServiceConstants.COVISINT_SESSIONID_VALUE);
			httpGet.addHeader(ServiceConstants.COVISINT_USERNAME, username);
			httpGet.addHeader(ServiceConstants.COVISINT_VIN, vin);
			httpGet.addHeader(ServiceConstants.COVISINT_FROM,ServiceConstants.COVISINT_FROM_VALUE);
			httpGet.addHeader(ServiceConstants.COVISINT_AUTHORIZATION,ServiceConstants.COVISINT_AUTHORIZATION_VALUE);
			httpGet.addHeader(ServiceConstants.COVISINT_TO,ServiceConstants.COVISINT_TO_VALUE);
			httpGet.addHeader(ServiceConstants.COVISINT_CACHE_CONTROL,ServiceConstants.COVISINT_CACHE_CONTROL_VALUE);
			response = httpclient.execute(httpGet);
			

			log.info("Response is => " + response.toString());

			// verify response is HTTP OK
			final int statusCode = response.getStatusLine().getStatusCode();
			if (statusCode != HttpStatus.SC_OK) {
				log.info("Response Code is " + statusCode);
			}

			String getResult = EntityUtils.toString(response.getEntity());
			json = (JSONObject) new JSONTokener(getResult).nextValue();
			log.info("Json Object => " + json.get("RESPONSE_STRING"));
			log.info("Result =>" + getResult);
			
			JSONObject response_string = json.getJSONObject("RESPONSE_STRING");
			if(response_string!=null){
				result = response_string.get("speedLimit").toString();
			}
			
			log.info("result---"+result);
			
		} catch (Exception e) {
			log.error(e.getMessage());
		}
		
		return result;
	}
	
	public String setSpeedAlert(String vin, String username, String token,int speedLimit)
	{
		try {
			
				log.info("In Set Speed alert method");
				String param="/vsAlert/v1.0/SPEED";
				
				URL url = new URL(this.restURL + param);
				log.info("URL :- " + url);
				
				String decrypted_token = cryptoSupport.unprotect(token);
				log.info("decrypted_token=----" + decrypted_token);

				HttpURLConnection conn = (HttpURLConnection) url.openConnection();
				conn.setRequestMethod(ServiceConstants.COVISINT_POST);
				conn.setRequestProperty(ServiceConstants.COVISINT_COMPANY,this.company);
				conn.setRequestProperty(ServiceConstants.COVISINT_SENDER,this.sender);
				conn.setRequestProperty(ServiceConstants.COVISINT_RECEIVER,ServiceConstants.COVISINT_RECEIVER_VALUE);
				conn.setRequestProperty(ServiceConstants.COVISINT_IFID,"OP_OALT001");
				conn.setRequestProperty(ServiceConstants.COVISINT_ACCESSTOKEN,decrypted_token);
				conn.setRequestProperty(ServiceConstants.COVISINT_SESSIONID,ServiceConstants.COVISINT_SESSIONID_VALUE);
				conn.setRequestProperty(ServiceConstants.COVISINT_USERNAME,username);
				conn.setRequestProperty(ServiceConstants.COVISINT_VIN,vin);
				conn.setRequestProperty(ServiceConstants.COVISINT_FROM,ServiceConstants.COVISINT_FROM_VALUE);
				conn.setRequestProperty(ServiceConstants.COVISINT_TO,ServiceConstants.COVISINT_TO_VALUE);
				//conn.setRequestProperty(ServiceConstants.COVISINT_CACHE_CONTROL,ServiceConstants.COVISINT_CACHE_CONTROL_VALUE);
				conn.setRequestProperty(ServiceConstants.COVISINT_CACHE_CONTROL,ServiceConstants.COVISINT_CACHE_CONTROL_VALUE);
				conn.setRequestProperty(ServiceConstants.COVISINT_CONTENTTYPE,ServiceConstants.COVISINT_CONTENT_TYPE_VALUE);
				conn.setRequestProperty("Authorization","Basic UkVTVFVzZXI6UkVTVFVzZXI=");
				
				log.info(ServiceConstants.COVISINT_COMPANY + " = "+ conn.getRequestProperty(ServiceConstants.COVISINT_COMPANY));
				log.info(ServiceConstants.COVISINT_SENDER + " = "+ conn.getRequestProperty(ServiceConstants.COVISINT_SENDER));
				log.info(ServiceConstants.COVISINT_RECEIVER + " = "+ conn.getRequestProperty(ServiceConstants.COVISINT_RECEIVER));
				log.info(ServiceConstants.COVISINT_IFID + " = "+ conn.getRequestProperty(ServiceConstants.COVISINT_IFID));
				log.info(ServiceConstants.COVISINT_ACCESSTOKEN + " = "+ conn.getRequestProperty(ServiceConstants.COVISINT_ACCESSTOKEN));
				log.info(ServiceConstants.COVISINT_USERNAME + " = "+ conn.getRequestProperty(ServiceConstants.COVISINT_USERNAME));
				log.info(ServiceConstants.COVISINT_FROM + " = "+ conn.getRequestProperty(ServiceConstants.COVISINT_FROM));
				log.info(ServiceConstants.COVISINT_TO + " = "+ conn.getRequestProperty(ServiceConstants.COVISINT_TO));
				log.info(ServiceConstants.COVISINT_CACHE_CONTROL + " = "+ conn.getRequestProperty(ServiceConstants.COVISINT_CACHE_CONTROL));
				//log.info(ServiceConstants.COVISINT_AUTHORIZATION + " = "+ conn.getRequestProperty(ServiceConstants.COVISINT_AUTHORIZATION));
				
				
				JSONObject userParam=new JSONObject();
				userParam.put("speedLimit",speedLimit);
				userParam.put("speedUnit","MPH");
				
				 conn.setDoOutput(true);
				 conn.getOutputStream().write(userParam.toString().getBytes());
				 log.info(userParam.toString());
				 
		            int responseCode = conn.getResponseCode();
		            Reader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8"));
		            
		            if (responseCode != HttpStatus.SC_OK) {
		                log.info("Response Code is " + responseCode);
		            }
		            
		            String jsonText = readAll(in);
		            JSONObject json = new JSONObject(jsonText);
		            
		            log.info("setSpeedAlert Object => " + json.get("RESPONSE_STRING"));
		            log.info("setSpeedAlert Result =>"+ json);
		            result = json.get("E_IFRESULT").toString();


			} catch (Exception e) {
				log.error(e.getMessage());
			}
			
		// TODO Auto-generated method stub
		return result;
	}
	


/**
 * GET Geofence data
 * @param 
 * @return 
 */
@Override
public JSONArray getGeoFence(String vin,String username,String token){
	
	JSONObject json = null;
	HttpResponse response = null;
    String param = "/vsAlert/v1.0/GEOFENCE";
    JSONArray result=null;
    
    try {
    	log.info("In  Get Geofence  method -------");
    	  	
    	
    	String decrypted_token = cryptoSupport.unprotect(token);
    	log.info("decrypted_token=----"+decrypted_token);
    	
    	HttpClient httpclient = HttpClientBuilder.create().build();
		HttpGet httpGet = new HttpGet(this.restURL + param);
		
    	log.info("GET Geofence URL - "+this.restURL+param);
    
         httpGet.addHeader(ServiceConstants.COVISINT_CONTENTTYPE, ServiceConstants.COVISINT_CONTENT_TYPE_VALUE);            
         httpGet.addHeader(ServiceConstants.COVISINT_COMPANY, this.company);
         httpGet.addHeader(ServiceConstants.COVISINT_SENDER, this.sender);
         httpGet.addHeader(ServiceConstants.COVISINT_RECEIVER, this.receiver);
         httpGet.addHeader(ServiceConstants.COVISINT_IFID, "OP_OAL003");
         httpGet.addHeader(ServiceConstants.COVISINT_AUTHORIZATION, this.authorization);
         httpGet.addHeader(ServiceConstants.COVISINT_SESSIONID,ServiceConstants.COVISINT_SESSIONID_VALUE);
         httpGet.addHeader(ServiceConstants.COVISINT_ACCESSTOKEN, decrypted_token);
         httpGet.addHeader(ServiceConstants.COVISINT_USERNAME, username);
         httpGet.addHeader(ServiceConstants.COVISINT_VIN, vin);
       // httpGet.addHeader(ServiceConstants.COVISINT_APPCLOUD_VIN,ServiceConstants.COVISINT_APPCLOUD_VIN_VALUE);
         httpGet.addHeader(ServiceConstants.COVISINT_REGISTRATION_ID,ServiceConstants.COVISINT_REGISTRATION_ID_VALUE);
        //httpGet.addHeader(ServiceConstants.COVISINT_BLUE_LINK_SERVICE_PIN, pin);
         httpGet.addHeader(ServiceConstants.COVISINT_FROM,ServiceConstants.COVISINT_FROM_VALUE);
         httpGet.addHeader(ServiceConstants.COVISINT_GEN,ServiceConstants.COVISINT_GEN_VALUE);
         httpGet.addHeader(ServiceConstants.COVISINT_TO,ServiceConstants.COVISINT_TO_VALUE);
         
         response = httpclient.execute(httpGet);
		 log.info("Response is => " + response.toString());
        
		// verify response is HTTP OK
		final int statusCode = response.getStatusLine().getStatusCode();
		if (statusCode != HttpStatus.SC_OK) {
			log.info("Response Code is " + statusCode);
		}
        
		String getResult = EntityUtils.toString(response.getEntity());
		json = (JSONObject) new JSONTokener(getResult).nextValue();
		log.info("get geofence Json Object => " + json.get("RESPONSE_STRING"));
		log.info("get geofence Result =>" + getResult);
		
		JSONObject response_string = json.getJSONObject("RESPONSE_STRING");
		
		
		if(response_string!=null){
			
			log.info("getGeofence response_string result++---"+response_string.get("geoFenceProfiles"));
			if(!response_string.get("geoFenceProfiles").equals(null)){
				log.info("In if condition");
				result = (JSONArray) response_string.get("geoFenceProfiles");
				
				log.info("getGeofence result++---"+result);
			}	
		}
		
		log.info("getGeofence result---"+result);
		
	} catch (Exception e) {
		log.error(e.getMessage());
	}
	
	return result;
	
}//Get Geofence ends



/**
 * POST Geofence params 
 * @param 
 * @return 
 */
@Override
public String setGeoFence(String vin,String username,String token, String distance,String type, String shape,double geo_lat, double geo_lng,double georec_brlng,double georec_brlat,double georec_tllng, double georec_tllat, String alertStatus, String geo_name,String geo_address){
	
    String param = "/vsAlert/v1.0/GEOFENCE";
    String result=null;
   // String geoFenceId=null;
    
    try {
    	

    	log.info(" ++++ calling get Geofence method inside setGeofence++++ ");
    	
    	JSONArray get_geofence=this.getGeoFence(vin, username, token);
    	int geoId = 0;
    	
    	
    	
    	// putting the value as json object
        JSONObject geoData= new JSONObject();
        JSONArray geoDataArray=new JSONArray();
        
    	if(get_geofence != null){
    		
    		int length =get_geofence.length();
        	log.info(" ++++ Array length get Geofence method inside setGeofence++++ "+length);
    		
    		for(geoId = 1; geoId < get_geofence.length(); geoId++ ){
    			JSONObject jsonObject = get_geofence.getJSONObject(geoId);
    			jsonObject.put("geoFenceId", ""+geoId);
    			geoDataArray.put(jsonObject);
    		}
    	}
    	
    	++geoId;
    	
    	log.info("In  set Geofence  method -------");
    	
         geoData.put("type",type);
         geoData.put("shape",shape);
         
         
         JSONObject cc=new JSONObject();
         if(shape.equals("CIRCLE")){
         
         cc.put("lat",geo_lat);
         cc.put("lon",geo_lng);
         cc.put("alt","");
         cc.put("system","WGS84");
         
         
         geoData.put("coordinatesCenter",cc);
         
         }
         
         
         else { 
        	 //coordinates for rectangle
        	 
        	 //cctl= cordinate for top left  coordinatesTopLeft
        	 JSONObject cctl=new JSONObject();
        	 cctl.put("lat",georec_tllat);
        	 cctl.put("lon",georec_tllng);
        	 cctl.put("alt","");
        	 cctl.put("system","WGS84");
               	 
        	 //ccbr= cordinate for bottom right  coordinatesBottomRight
        	 JSONObject ccbr=new JSONObject();
        	 ccbr.put("lat",georec_brlat);
        	 ccbr.put("lon",georec_brlng);
        	 ccbr.put("alt","");
        	 ccbr.put("system","WGS84");
        	        	 
        	 geoData.put("coordinatesTopLeft",cctl);
        	 geoData.put("coordinatesBottomRight",ccbr);
        	 
        	
         }
         
         
         
         log.info("geoFenceProfiles data coordinatesCenter "+ geoData);
         JSONObject rad=new JSONObject();
         rad.put("distance",distance);
         rad.put("unit","MILES");
         geoData.put("radius",rad);
         geoData.put("configId","null");
         geoData.put("alertStatus",alertStatus);
    	 geoData.put("geoFenceId",""+geoId);
         geoData.put("geoFenceName",geo_name);
         geoData.put("geoFenceAddress",geo_address);
         geoDataArray.put(geoData);

         JSONObject jsonData= new JSONObject();
         
         jsonData.put("geoFenceProfiles",geoDataArray);
         log.info("geoFenceProfiles data  "+ jsonData);
    	
    	
    	String decrypted_token = cryptoSupport.unprotect(token);
    	log.info("decrypted_token=----"+decrypted_token);
    	
    	URL url = new URL(this.restURL+param);
    	log.info(" SET Geofence URL - "+this.restURL+param);
    	
    	 HttpURLConnection conn = (HttpURLConnection) url.openConnection();
         conn.setRequestMethod(ServiceConstants.COVISINT_POST);
         conn.setRequestProperty(ServiceConstants.COVISINT_CONTENTTYPE, ServiceConstants.COVISINT_CONTENT_TYPE_VALUE);            
         conn.setRequestProperty(ServiceConstants.COVISINT_COMPANY, this.company);
         conn.setRequestProperty(ServiceConstants.COVISINT_SENDER, this.sender);
         conn.setRequestProperty(ServiceConstants.COVISINT_RECEIVER, this.receiver);
         conn.setRequestProperty(ServiceConstants.COVISINT_IFID, "OP_OAL003");
         conn.setRequestProperty(ServiceConstants.COVISINT_AUTHORIZATION, this.authorization);
         conn.setRequestProperty(ServiceConstants.COVISINT_SESSIONID,ServiceConstants.COVISINT_SESSIONID_VALUE);
         conn.setRequestProperty(ServiceConstants.COVISINT_ACCESSTOKEN, decrypted_token);
         conn.setRequestProperty(ServiceConstants.COVISINT_USERNAME, username);
         conn.setRequestProperty(ServiceConstants.COVISINT_VIN, vin);
       // conn.setRequestProperty(ServiceConstants.COVISINT_APPCLOUD_VIN,ServiceConstants.COVISINT_APPCLOUD_VIN_VALUE);
         conn.setRequestProperty(ServiceConstants.COVISINT_REGISTRATION_ID,ServiceConstants.COVISINT_REGISTRATION_ID_VALUE);
        //conn.setRequestProperty(ServiceConstants.COVISINT_BLUE_LINK_SERVICE_PIN, pin);
         conn.setRequestProperty(ServiceConstants.COVISINT_FROM,ServiceConstants.COVISINT_FROM_VALUE);
         conn.setRequestProperty(ServiceConstants.COVISINT_GEN,ServiceConstants.COVISINT_GEN_VALUE);
         conn.setRequestProperty(ServiceConstants.COVISINT_TO,ServiceConstants.COVISINT_TO_VALUE);
         conn.setDoOutput(true);
         conn.getOutputStream().write(jsonData.toString().getBytes());
         log.info(jsonData.toString());
         int responseCode = conn.getResponseCode();
         Reader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8"));
        
         if (responseCode != HttpStatus.SC_OK) {
            log.info("Response Code is " + responseCode);
         }
        
         String jsonText = readAll(in);
         JSONObject json = new JSONObject(jsonText);
        
         log.info("Set Geofence alert Object => " + json.get("RESPONSE_STRING"));
         log.info(" Set Geofence alert Result =>"+ json);
          result = json.get("E_IFRESULT").toString();
                              
        }catch(Exception e){
	     log.error(e.getMessage());
        }
	    return result;
	
     }//Set Geofence ends


@Override
public String getCurfewAlert(String vin, String username,String token) {
	
	JSONObject json = null;
	HttpResponse response = null;
	String param="/vsAlert/v1.0/CURFEW";
	String result = null;

	try {

		log.info("In getCurfewAlert method");

	
		String decrypted_token = cryptoSupport.unprotect(token);
		log.info("decrypted_token=----" + decrypted_token);
		
		HttpClient httpclient = HttpClientBuilder.create().build();
		HttpGet httpGet = new HttpGet(this.restURL + param);

		log.info("URL - " + this.restURL + param);
		httpGet.addHeader(ServiceConstants.COVISINT_COMPANY, this.company);
		httpGet.addHeader(ServiceConstants.COVISINT_SENDER, this.sender);
		httpGet.addHeader(ServiceConstants.COVISINT_IFID, "OP_IAL004");
		httpGet.addHeader(ServiceConstants.COVISINT_RECEIVER,ServiceConstants.COVISINT_RECEIVER_VALUE);
		httpGet.addHeader(ServiceConstants.COVISINT_ACCESSTOKEN,decrypted_token);
		httpGet.addHeader(ServiceConstants.COVISINT_SESSIONID,ServiceConstants.COVISINT_SESSIONID_VALUE);
		httpGet.addHeader(ServiceConstants.COVISINT_USERNAME, username);
		httpGet.addHeader(ServiceConstants.COVISINT_VIN, vin);
		httpGet.addHeader(ServiceConstants.COVISINT_FROM,ServiceConstants.COVISINT_FROM_VALUE);
		httpGet.addHeader(ServiceConstants.COVISINT_GEN,ServiceConstants.COVISINT_GEN_VALUE);
		httpGet.addHeader(ServiceConstants.COVISINT_AUTHORIZATION,ServiceConstants.COVISINT_AUTHORIZATION_VALUE);
		httpGet.addHeader(ServiceConstants.COVISINT_TO,ServiceConstants.COVISINT_TO_VALUE);
		httpGet.addHeader(ServiceConstants.COVISINT_CACHE_CONTROL,ServiceConstants.COVISINT_CACHE_CONTROL_VALUE);
		response = httpclient.execute(httpGet);
		

		log.info("Response is => " + response.toString());

		// verify response is HTTP OK
		final int statusCode = response.getStatusLine().getStatusCode();
		if (statusCode != HttpStatus.SC_OK) {
			log.info("Response Code is " + statusCode);
		}

		String getResult = EntityUtils.toString(response.getEntity());
		json = (JSONObject) new JSONTokener(getResult).nextValue();
		log.info("Json Object => " + json.get("RESPONSE_STRING"));
		log.info("Result =>" + getResult);
		
		JSONObject response_string = json.getJSONObject("RESPONSE_STRING");
		if(response_string!=null){
			result = response_string.get("curfewList").toString();
		}
		
		log.info("result---"+result);
		
	} catch (Exception e) {
		log.error(e.getMessage());
	}
	
	return result;
}

public String setCurfewAlert(String vin, String username, String token,String curfewAlertsProfilesStr)
{
	try {
		
			log.info("In setCurfewAlert method");
			String param="/vsAlert/v1.0/CURFEW";
			
			URL url = new URL(this.restURL + param);
			log.info("URL :- " + url);
			
			String decrypted_token = cryptoSupport.unprotect(token);
			log.info("decrypted_token=----" + decrypted_token);
			
			JSONObject curfewAlertsProfilesjsonObj= new JSONObject(curfewAlertsProfilesStr);
	         
	        log.info("Json for setCurfew Alert--"+ curfewAlertsProfilesjsonObj);
	   
			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod(ServiceConstants.COVISINT_POST);
			conn.setRequestProperty(ServiceConstants.COVISINT_COMPANY,this.company);
			conn.setRequestProperty(ServiceConstants.COVISINT_SENDER,this.sender);
			conn.setRequestProperty(ServiceConstants.COVISINT_RECEIVER,ServiceConstants.COVISINT_RECEIVER_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_IFID,"OP_OALT001");
			conn.setRequestProperty(ServiceConstants.COVISINT_ACCESSTOKEN,decrypted_token);
			conn.setRequestProperty(ServiceConstants.COVISINT_SESSIONID,ServiceConstants.COVISINT_SESSIONID_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_USERNAME,username);
			conn.setRequestProperty(ServiceConstants.COVISINT_VIN,vin);
			conn.setRequestProperty(ServiceConstants.COVISINT_FROM,ServiceConstants.COVISINT_FROM_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_TO,ServiceConstants.COVISINT_TO_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_CACHE_CONTROL,ServiceConstants.COVISINT_CACHE_CONTROL_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_CONTENTTYPE,ServiceConstants.COVISINT_CONTENT_TYPE_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_AUTHORIZATION,ServiceConstants.COVISINT_AUTHORIZATION_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_GEN, ServiceConstants.COVISINT_GEN_VALUE);
			
			//JSONObject userParam=new JSONObject();
			//JSONArray curfewList = new JSONArray();
			//JSONObject curfewData = new JSONObject();
			//curfewData.put("curfewID", "18");
			//curfewData.put("startTime", startTime);
			//curfewData.put("endTime", endTime);
			//curfewData.put("startDay", startDay);
			//curfewData.put("endDay", endDay);
			
			//curfewList.put(curfewData);
			//userParam.put("curfewList", curfewList);
			
			 conn.setDoOutput(true);
			 conn.getOutputStream().write(curfewAlertsProfilesjsonObj.toString().getBytes());
			 log.info("after output stream----->"+curfewAlertsProfilesjsonObj.toString());

	            int responseCode = conn.getResponseCode();
	            Reader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8"));
	            
	            if (responseCode != HttpStatus.SC_OK) {
	                log.info("Response Code is " + responseCode);
	            }
	            
	            String jsonText = readAll(in);
	            JSONObject json = new JSONObject(jsonText);
	            
	            log.info("setCurfewAlert Object => " + json.get("RESPONSE_STRING"));
	            log.info("setCurfewAlert Result =>"+ json);
	            result = json.get("E_IFRESULT").toString();


		} catch (Exception e) {
			log.error(e.getMessage());
		}
		
	// TODO Auto-generated method stub
	return result;
}

public String deleteCurfewAlert(String vin, String username, String token,String startTime,String endTime,String startDay,String endDay,String curfewID)
{
	try {
		
			log.info("In setCurfewAlert method");
			String param="/vsAlert/v1.0/CURFEW";
			
			URL url = new URL(this.restURL + param);
			log.info("URL :- " + url);
			
			String decrypted_token = cryptoSupport.unprotect(token);
			log.info("decrypted_token=----" + decrypted_token);

			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod(ServiceConstants.COVISINT_POST);
			conn.setRequestProperty(ServiceConstants.COVISINT_COMPANY,this.company);
			conn.setRequestProperty(ServiceConstants.COVISINT_SENDER,this.sender);
			conn.setRequestProperty(ServiceConstants.COVISINT_RECEIVER,ServiceConstants.COVISINT_RECEIVER_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_IFID,"OP_OALT002");
			conn.setRequestProperty(ServiceConstants.COVISINT_ACCESSTOKEN,decrypted_token);
			conn.setRequestProperty(ServiceConstants.COVISINT_SESSIONID,ServiceConstants.COVISINT_SESSIONID_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_USERNAME,username);
			conn.setRequestProperty(ServiceConstants.COVISINT_VIN,vin);
			conn.setRequestProperty(ServiceConstants.COVISINT_FROM,ServiceConstants.COVISINT_FROM_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_TO,ServiceConstants.COVISINT_TO_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_CACHE_CONTROL,ServiceConstants.COVISINT_CACHE_CONTROL_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_CONTENTTYPE,ServiceConstants.COVISINT_CONTENT_TYPE_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_AUTHORIZATION,ServiceConstants.COVISINT_AUTHORIZATION_VALUE);
			conn.setRequestProperty(ServiceConstants.COVISINT_GEN, ServiceConstants.COVISINT_GEN_VALUE);
			
			JSONObject userParam=new JSONObject();
			JSONArray curfewList = new JSONArray();
			JSONObject curfewData = new JSONObject();
			curfewData.put("curfewID", curfewID);
			curfewData.put("startTime", startTime);
			curfewData.put("endTime", endTime);
			curfewData.put("startDay", startDay);
			curfewData.put("endDay", endDay);
			
			curfewList.put(curfewData);
			userParam.put("curfewList", curfewList);
			userParam.put("actionType","DISABLE");
			
			 conn.setDoOutput(true);
			 conn.getOutputStream().write(userParam.toString().getBytes());
			 log.info(userParam.toString());
			 
	            int responseCode = conn.getResponseCode();
	            Reader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8"));
	            
	            if (responseCode != HttpStatus.SC_OK) {
	                log.info("Response Code is " + responseCode);
	            }
	            
	            String jsonText = readAll(in);
	            JSONObject json = new JSONObject(jsonText);
	            
	            log.info("setCurfewAlert Object => " + json.get("RESPONSE_STRING"));
	            log.info("setCurfewAlert Result =>"+ json);
	            result = json.get("E_IFRESULT").toString();


		} catch (Exception e) {
			log.error(e.getMessage());
		}
		
	// TODO Auto-generated method stub
	return result;
}


/**
 * POST Geofence params on "Delete"
 * @param 
 * @return 
 */
@Override
public String setGeoFence_delete(String vin,String username,String token, String deleteGFAprofileStr){
	
    String param = "/vsAlert/v1.0/GEOFENCE";
    String result=null;
   
    
    try {
    	

    	log.info(" ++++ After delete setGeofence ++++ ");
    	
    	 JSONObject deleteGFAjsonObj= new JSONObject(deleteGFAprofileStr);
         
        log.info("geoFenceProfiles data inside set for  delete call ### "+ deleteGFAjsonObj);
    	
    	
    	String decrypted_token = cryptoSupport.unprotect(token);
    	log.info("decrypted_token=----"+decrypted_token);
    	
    	URL url = new URL(this.restURL+param);
    	log.info(" SET Geofence URL - "+this.restURL+param);
    	
    	 HttpURLConnection conn = (HttpURLConnection) url.openConnection();
         conn.setRequestMethod(ServiceConstants.COVISINT_POST);
         conn.setRequestProperty(ServiceConstants.COVISINT_CONTENTTYPE, ServiceConstants.COVISINT_CONTENT_TYPE_VALUE);            
         conn.setRequestProperty(ServiceConstants.COVISINT_COMPANY, this.company);
         conn.setRequestProperty(ServiceConstants.COVISINT_SENDER, this.sender);
         conn.setRequestProperty(ServiceConstants.COVISINT_RECEIVER, this.receiver);
         conn.setRequestProperty(ServiceConstants.COVISINT_IFID, "OP_OAL003");
         conn.setRequestProperty(ServiceConstants.COVISINT_AUTHORIZATION, this.authorization);
         conn.setRequestProperty(ServiceConstants.COVISINT_SESSIONID,ServiceConstants.COVISINT_SESSIONID_VALUE);
         conn.setRequestProperty(ServiceConstants.COVISINT_ACCESSTOKEN, decrypted_token);
         conn.setRequestProperty(ServiceConstants.COVISINT_USERNAME, username);
         conn.setRequestProperty(ServiceConstants.COVISINT_VIN, vin);
       // conn.setRequestProperty(ServiceConstants.COVISINT_APPCLOUD_VIN,ServiceConstants.COVISINT_APPCLOUD_VIN_VALUE);
         conn.setRequestProperty(ServiceConstants.COVISINT_REGISTRATION_ID,ServiceConstants.COVISINT_REGISTRATION_ID_VALUE);
        //conn.setRequestProperty(ServiceConstants.COVISINT_BLUE_LINK_SERVICE_PIN, pin);
         conn.setRequestProperty(ServiceConstants.COVISINT_FROM,ServiceConstants.COVISINT_FROM_VALUE);
         conn.setRequestProperty(ServiceConstants.COVISINT_GEN,ServiceConstants.COVISINT_GEN_VALUE);
         conn.setRequestProperty(ServiceConstants.COVISINT_TO,ServiceConstants.COVISINT_TO_VALUE);
         conn.setDoOutput(true);
         conn.getOutputStream().write(deleteGFAjsonObj.toString().getBytes());
         log.info("processing deleteGFAprofileStr "+deleteGFAjsonObj.toString());
         int responseCode = conn.getResponseCode();
         Reader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8"));
        
         if (responseCode != HttpStatus.SC_OK) {
            log.info("Response Code is " + responseCode);
         }
        
         String jsonText = readAll(in);
         JSONObject json = new JSONObject(jsonText);
        
         log.info("On delete Set Geofence alert Object => " + json.get("RESPONSE_STRING"));
         log.info("on delete Set Geofence alert Result =>"+ json);
          result = json.get("E_IFRESULT").toString();
                              
        }catch(Exception e){
	     log.error(e.getMessage());
        }
	    return result;
	
     }//Set Geofence on delete ends

}


Safeguard alert component

<div data-sly-test="${wcmmode.edit}" data-sly-unwrap>Please configure SafeguardAlerts component </div> 
<div  id="safeguard-alerts" data-anchor="safeguard-alerts" class="tab-section">
        <div class="container">
          <h3>${properties.title}</h3>
         <div class="row">
            <div class="cs-alert-column">
              <img src="${properties.tab1image}" alt="${properties.tab1alttext}" />
              <h4>${properties.tab1heading}</h4>
              <div class="alert-info" id="manage-geofence-alerts" style="display:none;">
                <div id="geofence-alerts-summary" >
                <span class="alert-title">No Active Alerts</span>
                </div>
                <a class="manage-alerts" href="#" data-toggle="modal" data-target="#modal-geofence">Manage Alerts</a>
              </div>
              <div class="alert-info" id="set-geofence-alerts">
                <span class="alert-title" style="display:block;margin-bottom: 100px;">No Active Alerts</span>
                <a class="manage-alerts" href="#" data-toggle="modal" data-target="#modal-geofence">Set Alert</a>
              </div>
            </div>
            <div class="cs-alert-column">
              <img src="${properties.tab2image}" alt="${properties.tab2alttext}" />
              <h4>${properties.tab2heading}</h4>
              <div class="alert-info" id="manage-curfew-alerts" style="display:none;">
                <span class="alert-title">Weekly on Weekdays</span>
                <p>8:45 PM - 5:00 AM</p>
				<a class="manage-alerts" href="#" data-toggle="modal" data-target="#modal_curfewalert">Manage Alerts</a>
              </div>
              <div class="alert-info" id="set-curfew-alerts">
                <span class="alert-title"style="display:block;margin-bottom: 100px;">No Active Alerts</span>
                <a class="manage-alerts set-cerew-alert" href="#" data-toggle="modal" data-target="#modal_curfewalert">Set Alert</a>
              </div>
            </div>
            <div class="cs-alert-column">
              <img src="${properties.tab3image}" alt="${properties.tab3alttext}" />
              <h4>${properties.tab3heading}</h4>
              <div class="alert-info" id="manage-speed-alerts" style="display:none;">
                <span class="alert-title" id="speedalert"></span>
                <a class="manage-alerts" href="#" data-toggle="modal" data-target="#set-speed-alert">Manage Alerts</a>
              </div>
              <div class="alert-info" id="set-speed-alerts">
                <span class="alert-title" style="display:block;margin-bottom: 100px;">No Active Alerts</span>
                <a class="manage-alerts" href="#" data-toggle="modal" data-target="#speed-alert">Set Alert</a>
              </div>
            </div>
            <div class="cs-alert-column">
              <img src="${properties.tab4image}" alt="${properties.tab4alttext}" />
              <h4>${properties.tab4heading}</h4>
              <div class="alert-info" id="manage-valet-alerts" style="display:none;">
                <span class="alert-title" id="setvaletalert"></span>
                <a class="manage-alerts" href="#" data-toggle="modal" data-target="#set-valet-alert">Manage Alerts</a>
              </div>
              
              <div class="alert-info" id="set-valet-alerts">
                <span class="alert-title" style="display:block;margin-bottom: 100px;">No Active Alerts</span>
                <a class="manage-alerts" href="#" data-toggle="modal" data-target="#valet-alert">Set Alert</a>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <script type="text/javascript">
      
      $(document).ready(function() {
      
       var tokenInfo=$.parseJSON(sessionStorage.getItem("token"));
		   var id=$.parseJSON(sessionStorage.getItem("ownerinfo"));
		   var vi=$.parseJSON(sessionStorage.getItem("vehicleInfo"));

	       var token = tokenInfo.access_token;
		   var username = id.OwnerProfileInfo[0].Login;
		   var vin = vi.vehicleDetails.vin;

			console.log("Token = "+token);
			console.log("VIN = "+ vin);
			console.log("UserName = "+ username);
			//console.log("Service = "+ service);
			if(token!=null){
      
      				//calling speed alert service
      				$.ajax({
								type: "GET",
								url: '/bin/common/alertAction',
								data: {"vin":vin,"username":username,"token":token,"service":"getSpeedAlert"},
								success: function (data) {
								
									if(data == 'null'){
                                 
										$("#set-speed-alerts").show();
										$("#manage-speed-alerts").hide();
									
									}else{
										var msg = "Speed Alert Set at "+ data +" mph";
										$("#speedalert").html(msg);
										$("#speed-set").html(msg);
										//$("#vehicle-speed").html(msg);
										
										$("#set-speed-alerts").hide();
										$("#manage-speed-alerts").show();

									}
				             	}
				                //$("#response").append(JSON.stringify(data));
				        });

				        // calling valet alert
				        $.ajax({
								type: "GET",
								url: '/bin/common/alertAction',
								data: {"vin":vin,"username":username,"token":token,"service":"getValetAlert"},
								success: function (data) {

									if(data == 'null'){

										$("#set-valet-alerts").show();
										$("#manage-valet-alerts").hide();

									}else{

                                    var limit = $.parseJSON(data);
									var distance = limit[0].distance.value;
                                      console.log(distance);
										var msg = "Valet Alert Set at "+ distance +" miles";
										$("#setvaletalert").html(msg);
										$("#valet-set").html(msg);

										$("#set-valet-alerts").hide();
										$("#manage-valet-alerts").show();

									}
				             	}
				                //$("#response").append(JSON.stringify(data));
				        });


				         // calling geofence alert
				         $.ajax({
								type: "GET",
								url: '/bin/common/alertAction',
								data: {"vin":vin,"username":username,"token":token,"service":"getGeoFenceAlert"},
								success: function (data) {

									if(data == 'null'){

										$("#set-geofence-alerts").show();
										$("#manage-geofence-alerts").hide();

									}else{
										//var msg = "geofence Alert Set at "+ data +" ";
										//$("#setgeofencealert").html(msg);

										$("#set-geofence-alerts").hide();
										$("#manage-geofence-alerts").show(); 

									}
				             	}
				                //$("#response").append(JSON.stringify(data));
				        });

				        // calling Curfew alert
				        $.ajax({
								type: "GET",
								url: '/bin/common/alertAction',
								data: {"vin":vin,"username":username,"token":token,"service":"getCurfewAlert"},
								success: function (data) {
									if(data == 'null'){
                                    $("#set-curfew-alerts").show();
										$("#manage-curfew-alerts").hide();

									} else{
										var msg = "Curfew Alert Set at "+ data +" ";
										//$("#setCurfewAlert").html(msg);
										console.log(data);
                                        var response = JSON.parse(data);
                                        console.log(response[0].STARTDAYOFWEEK);
                                        var StartDay;
                                        switch(response[0].STARTDAYOFWEEK) {
                                            case 1:
												StartDay = 'Monday';
                                                break;
                                            case 2:
                                                StartDay = 'Tuesday'
                                                break;
                                            case 3:
                                                StartDay = 'Wednesday'
                                                break;
                                            case 4:
                                                StartDay = 'Thursday'
                                                break;
                                            case 5:
                                                StartDay = 'Friday'
                                                break;
                                            case 6:
                                                StartDay = 'Saturday'
                                                break;
                                            case 0:
                                                StartDay = 'Sunday'
                                                break;
                                        }
                                        var EndDay;
                                        if(response[0].STARTDAYOFWEEK == response[0].ENDDAYOFWEEK) {
											$('#manage-curfew-alerts .alert-title').html('Weekly On ' + StartDay);
                                        }
                                        else {

                                            switch(response[0].ENDDAYOFWEEK) {
                                                case 1:
                                                    EndDay = 'Monday';
                                                    break;
                                                case 2:
                                                    EndDay = 'Tuesday';
                                                    break;
                                                case 3:
                                                    EndDay = 'Wednesday';
                                                    break;
                                                case 4:
                                                    EndDay = 'Thursday';
                                                    break;
                                                case 5:
                                                    EndDay = 'Friday';
                                                    break;
                                                case 6:
                                                    EndDay = 'Saturday';
                                                    break;
                                                case 0:
                                                    EndDay = 'Sunday';
                                                    break;
                                            }
                                            $('#manage-curfew-alerts .alert-title').html('Weekly On ' + StartDay + ' - ' + EndDay);
                                        }
                                        var StartTime = response[0].STARTTIME;
                                        var Starttimearray = StartTime.match(/.{1,2}/g);
                                        var finalStartTime = "";
                                        var EndTime = response[0].ENDTIME;
                                        var Endtimearray = EndTime.match(/.{1,2}/g);
                                        var finalEndTime = "";
                                        if(Starttimearray[0] > 12) {
											finalStartTime = parseInt(Starttimearray[0]);
                                            finalStartTime = finalStartTime - 12;
											finalStartTime = finalStartTime + ":" + Starttimearray[1] + " PM";
                                        }
                                        else {
											finalStartTime = parseInt(Starttimearray[0]);
                                            finalStartTime = finalStartTime + ":" + Starttimearray[1] + " AM";
                                        }
                                        if(Endtimearray[0] > 12) {
											finalEndTime = parseInt(Endtimearray[0]);
                                            finalEndTime = finalEndTime - 12;
											finalEndTime = finalEndTime + ":" + Endtimearray[1] + " PM";
                                        }
                                        else {
											finalEndTime = parseInt(Endtimearray[0]);
                                            finalEndTime = finalEndTime + ":" + Endtimearray[1] + " AM";
                                        }
                                        $('#manage-curfew-alerts.alert-info p').html(finalStartTime + ' - ' + finalEndTime);
                                        $("#set-curfew-alerts").hide();
										$("#manage-curfew-alerts").show();
									}
				             	}
				                //$("#response").append(JSON.stringify(data));
				        });


			  }
		});

      </script>




SAFEGAUED COMP  STRUCTURE IN CRXDE

-cq/gui/components/authoring/dialog
--granite/ui/components/foundation/container(CONTENT)
---granite/ui/components/foundation/layouts/tabs(LAYOUT)
---items (unstructured)
----granite/ui/components/foundation/section(tabs)
-----granite/ui/components/foundation/layouts/fixedcolumns(layout)
-----items(unstructured)
------ granite/ui/components/foundation/container(coulmn)
-------items(unstructured)
-------- granite/ui/components/foundation/form/fieldset(fieldset)










https://blog.thecodecampus.de/angular-2-google-analytics-google-tag-manager/

https://unyscape.com/how-to-implement-google-analytics-in-an-angular2-app/

https://bubinga.co/google-analytics-pageview-angular-2/
https://helpx.adobe.com/dtm/kb/How_to_use_DTM_for_Single_Page_Apps.html
https://bubinga.co/google-analytics-pageview-angular-2/

https://mrpanot.wordpress.com/2016/07/15/track-google-analytics-on-angular2/


https://unyscape.com/how-to-implement-google-analytics-in-an-angular2-app/ imp


domain name


https://github.com/angulartics/angulartics2

customazied context hub data layer


http://www.digitalbalance.com.au/our-blog/angularjs-and-analytics-with-dynamic-tag-management-dtm/

http://www.digitalbalance.com.au/our-blog/how-to-use-direct-call-rules-in-dtm/

http://www.maassmedia.com/what-we-say/blog/adobe-dynamic-tag-management-direct-call-rules/

https://www.disruptiveadvertising.com/analytics/adobe-dtms-new-custom-and-pushstate-hashchange-event-types/

https://webanalyticsfordevelopers.com/2016/06/21/tracking-single-page-applications/

https://github.com/angulartics/angulartics2/wiki/Google-Analytics
https://github.com/angulartics/angulartics2/wiki/Tracking-Events

https://github.com/angulartics/angulartics2/wiki/Google-Analytics
https://github.com/angulartics/angulartics2


https://marketing.adobe.com/resources/help/en_US/sc/implement/dtm/c_implement-with-dtm.html
https://helpx.adobe.com/experience-manager/using/analytics1.html






<!--/* Include the site client libraries (loading only the JS in the footer, CSS was loaded in the header) */-->
  <!--/*<sly data-sly-use.clientLib="/libs/granite/sightly/templates/clientlib.html" data-sly-call="${clientLib.js @ categories='app.angular2-demo'}" data-sly-unwrap/>*/-->

<!--/* Include Adobe Dynamic Tag Management libraries for the footer */-->
  <!--/*<sly data-sly-resource="${@ resourceType='cq/cloudserviceconfigs/components/servicecomponents'}" data-sly-unwrap/>

<!--/* Initializes the Experience Manager authoring UI */-->
  <!--/*<sly data-sly-include="/libs/wcm/core/components/init/init.jsp" data-sly-unwrap/>

<!--/* Initializes the Experience Manager paragraph system */-->
  <!--/*<div data-sly-resource="${'parsysContent' @ resourceType='wcm/foundation/components/parsys'}"></div> */-->



Adobe DTM


Dashboard
Navigation: Home > Dashboard
Company Overview
Navigation: Home > Dashboard > Company Overview
Property Overview
Navigation: Company Overview > Property Overview
Navigation: Property Overview > Installed Tools
DTM tools are built-in integrations that allow for quick deployment of solutions to your site.
Currently, DTM offers tool integrations for Adobe solutions as well as for Google Analytics and Nielsen. Each of these integrations is uniquely designed to make configuration and deployment of that particular solution easier.
 
Rules
Navigation: Property Overview > Rules
Clicking the Rules tab from the property overview page takes you to the property rules.
Rules in DTM are used to conditionally execute tools, tags, scripts, and HTML.
Regardless of the type, rules in DTM have two main components: the condition and the trigger. The condition indicates the scenario in which the rule will fire and the trigger indicates the item(s) that will execute when the rule fires.
 There are three types of rules in DTM:
•	Event-Based: Event-based rules are interaction driven. For example, if I wanted to track when a user clicks a certain button, I would use an event-based rule.
•	Page-Load: Page-load rules are tied to the page load. For example, if I wanted to add a specific block of code on load of certain pages on my site, I would use a page-load rule.
•	Direct-Call: Direct-call rules are used in scenarios when DTM cannot detect an event in the DOM. For example, if I want to track an AJAX event that can’t be detected in the DOM, I would use a direct call rule.
Regardless of the rule type, if the condition is met the trigger executes.
All rules types have the option to trigger third-party vendor tags or any other custom JavaScript or HTML via the Javascript / Third Party Tags modal.

Data Elements
Navigation: Property Overview > Rules > Data Elements
Clicking the Data Elements tab within the Rules tab displays the data element overview page.
 
Data elements are used to build a data mapping in DTM. Defining common data points as data elements enables those data points to be easily captured and leveraged within rules and tools in DTM

Workflow
An important concept in DTM is the idea of a single web property having both a staging library and a production library.
The staging library contains all of the rules, tools, and data elements configured in the web property. The production library includes only the rules, tools, and data elements that are approved and published.
Navigation: Property Overview > Approvals tab
When a rule, tool, or data element is added or changed in a property an approval is automatically generated.
 
Navigation: Property Overview > History tab
After an item is approved, it becomes available in the Unpublished Changes queue 0n the History tab. After an item is published, it becomes available in the production library.
 

This separation of libraries and associated workflow allows for more effective testing in staging without affecting production.

Installation
Navigation: Property Overview > Embed tab
Clicking the Embed tab takes you to the DTM installation page.
This tab contains the various library hosting options available. By default the property leverages Akamai hosting. This method is typically acceptable for most organizations; however, if additional control over the serving of the DTM library in needed two self-hosting options are available.
 
Expanding the Header Code section on the Embed tab reveals the staging and production embed codes for the property.
 
Notice there’s one embed code for staging and one for production. This is how DTM differentiates between the staging and production libraries discussed above. When the staging embed code is installed, the staging library loads. When the production embed code is installed, the production library loads.
After the header and footer embed codes are properly installed on a site, the associated DTM library loads automatically on each page load.
Leverage the DTM Switch Plugin to test in the web console. This helps you understand what DTM is doing on the page and allows you to locally switch to the staging library for more effective testing.
https://helpx.adobe.com/experience-manager/using/integrate-digital-marketing-solutions.html





AEM6.3 new feature

The platform of Adobe Experience Manager 6.3 build on top of updated versions of the OSGi-based framework (Apache Sling and Apache Felix) and the Java Content Repository: Apache Jackrabbit Oak 1.6.1.


The Quickstart uses Eclipse Jetty 9.2.19 as servlet engine


Content Repository
Main repository enhancements are:
•	Oak Segment Tar File Format: A new TarMK format for optimized runtime and maintenance performance.
•	Full support for Online Revision Cleanup, to be scheduled for frequent automatic execution as a maintenance task without system down-time. For more guidelines please see the Revision Cleanup Tutorial.



User Interface
•	AEM 6.3 implements the 2017 Adobe Marketing Cloud UI design. Further - the user interface has been fully transitioned to the Web Component based Coral 3 UI framework.
•	The Classic UI is included in AEM 6.3. Mind that most entry points from within the Touch-optimized UI, that were enabled by default in version 5.6-6.2, to switch to the Classic UI equivalent have been disabled by default.










Scheduling Jobs Using Sling
i
The Sling Commons Scheduler Service is a Sling-provided mechanism that is used to execute jobs at predefined times–either periodically or at a set time. Is is based on the Quartz scheduling library and can therefore make use of its syntax for defining the execution times of jobs, making it possible to precisely indicate times like “at 6:32pm on every Saturday and Sunday” or “at 2:30am on the first Friday of every month”. At the other end of the spectrum, a simple numeric value can be used to specify the interval–in seconds–between each execution of the job.
More information about the cron-like expressions used by Quartz can be found at http://docjar.com/docs/api/org/quartz/CronExpression.html.
Inside CQ, an OSGi component that implements the java.lang.Runnable or the org.quartz.Job interface will be started if it has a configuration property called either scheduler.expression (whose value must be a cron expression) or scheduler.period (whose value must be a number of seconds).
Thanks to OSGi annotations, one can simply define a scheduled jobs using code like the following:
@Component(immediate=true)
@Service(interface=“java.lang.Runnable”)
@Property(name=“scheduler.expression” value=“0 0⁄10 * * * ?”, type=“String”)
public class MyScheduledJob implements java.lang.Runnable {
public void run() {
// code to execute goes here
}
}
 
Notice that we specified “immediate=true” in the @Component declaration. This makes sure that the component is activated immediately when the bundle is registered, a thing which is necessary for it to be properly invoked by the scheduler.
The method run() of the above component will be executed every hour at 0, 10, 20, 30, 40, and 50 minutes, zero seconds. If we had simply wanted an execution every 10 minutes, we could have used the following annotation instead:
@Property(name="scheduler.period" value="600", type="Long")
Concurrent execution of the job, which might happen if the previous execution has not yet finished when a new one is scheduled, can be prevented by setting the scheduler.concurrent property to false:
@Property(name="scheduler.concurrent", propertyPrivate=true, boolValue=false)
In a real-world scenario, we might want to be able to specify the execution time using the CQ5 Web Console. To do this, we need to modify the declaration of the property as follows:
@Component(immediate=true, metatype=true)


 
Backup and Restore:

There are two ways to back up and restore repository content in AEM: 
•	You can create an external backup of the repository and store it in a safe location. If the repository breaks down, you can restore it to the previous state.
•	You can create internal versions of the repository content. These versions are stored in the repository along with the content, so you can quickly restore nodes and trees you have changed or deleted


General
The approach described here applies for system backup and recovery.
If you need to backup and/or recover a small amount of content, which is lost, a recovery of the system is not necessarily required:
•	Either you can fetch the data from another system via a package
•	or you restore the backup on a temporary system, create a content package and deploy it on the system, where this content is missing.


Do not run backup in parallel with the datastore garbage collection, as it might harm the results of both processes.

Offline Backup
You can always do an offline backup. This requires a downtime of AEM, but can be quite efficient in terms of required time compared to an online backup.
In most cases you will use a filesystem snapshot to create a read-only copy of the storage at that time. To create a offline backup perform these steps:
•	stop the application
•	make a snapshot backup
•	start the application
As the snapshot backup usually takes only a few seconds, the entire downtime is less than a few minutes.


Online Backup
This backup method creates a backup of the entire repository, including any applications deployed under it, such as AEM. The backup includes content, version history, configuration, software, hotfixes, custom applications, log files, search indexes, and so on. If you are using clustering and if the shared folder is a subdirectory of crx-quickstart (either physically, or using a softlink), the shared directory is also backed up.
You can restore the entire repository (and any applications) at a later point.
This method operates as a "hot" or "online" backup so it can be performed while the repository is running. Therefore the repository is usable while the backup is running. This method works for the default, Tar storage based, repository instances.
When creating a backup, you have the following options:
•	Backing up to a directory using AEM's integrated backup tool.
•	Backing up to a directory using a filesystem snapshot
In any case, the backup creates an image (or snapshot) of the repository. Then the systems backup agent should take care to actually transfer this image to a dedicated backup system (tape drive).
Note:
If AEM Online Backup feature is used on an AEM instance which has a custom blobstore configuration, it is recommended to configure the path of datastore to be outside the "crx-quickstart" directory and backup the datastore separately.
Caution:
The online backup only backs up the file system. If you store the repository content and/or the repository files in a database, that database needs to backed up separately. If you are using AEM with MongoDB, see documentation on how to use the MongoDB native backup tools.



AEM Online Backup
An online backup of your repository lets you create, download, and delete backup files. It is a "hot" or "online" backup feature, so can be executed while the repository is being used normally in the read-write mode.
Caution:
Do not run AEM Online Backup concurrently with Datastore Garbage Collection or Revision Cleanup. It will negatively affect the system performance.
When starting a backup you can specify a Target Path and/or a Delay.
Target Path
The backup files are usually saved in the parent folder of the folder holidng the quickstart jar file (.jar). For example, if you have the AEM jar file located under /InstallationKits/AEM, then the backup will be generated under/InstallationKits. You can also specify a target to a location of your choice.
If the TargetPath is a directory, the image of the repository is created in this directory. If the same directory is used multiple times (or always) to storing backup,
•	modified files in the repository are modified accordingly in the TargetPath
•	deleted files in the repository are deleted in the TargetPath
•	created files in the repository are created in the TargetPath


Note:
If TargetPath is set to filename with the extension .zip, the repository is backed up to a temporary directory and then the content of this temporary directory is compressed and stored in the ZIP file.
This approach is discouraged, because
•	it requires additional disk storage during the backup process (temporary directory plus the zip file)
•	the compression process is done by the repository and might influence its performance.
•	It delays the backup process.
•	Up to Java 1.6 Java is only able to create ZIP files up to a size of 4 gigabytes.
If you need to create a ZIP as backup format, you should backup to a directory and then use a  compression program to create the zip file.
Delay
Indicates a time delay (in milliseconds), so that repository performance is not affected. By default, the repository backup runs at full speed. You can slow down creating an online backup, so that it does not slow down other tasks.
When using a very large delay, ensure that online backup does not take more than 24 hours. If it did, discard this backup, as it may not contain all binaries.
A delay of 1 millisecond typically results in 10% CPU usage, and a delay of 10 milliseconds usually results in less than 3% CPU usage. The total delay in seconds can be estimated as follows: Repository size in MB, multiplied by delay in milliseconds, divided by 2 (if the zip option is used), or divided by 4 (when backing up to a directory). That means a backup to a directory of a 200 MB repository with 1 ms delay increases the backup time by about 50 seconds.
To create a backup:
1.	Log in to AEM as the administrator.
2.	Go to Tools - Operations - Backup.
3.	Click Create. The backup console will open.
4.	On the backup console, specify the Target Path and Delay.
Note:The backup console is also available using:
   http://<hostname>:<port-number>/libs/granite/backup/content/admin.html


5.	Click Save, a progress bar will indicate the progress of the backup.
6.	When the backup is complete, the zip files are listed in the backup window.




Automating AEM Online Backup
If possible, the online backup should be run when there is little load on the system, for example in the morning. 
Backups can be automated using the wget or curl HTTP clients. The following show examples of how to automate backup by using curl.
Backing up to the default Target Directory
Caution:
In the following example various parameters in the curl command might need to be configured for your instance; for example, the hostname (localhost), port (4502), admin password (xyz) and file name (backup.zip).
curl -u admin:admin -X POST http://localhost:4502/system/console/jmx/com.adobe.granite:type=Repository/op/startBackup/java.lang.String?target=backup.zip

The backup file/directory is created on the server in the parent folder of the folder containing the crx-quickstart folder (the same as if you were creating the backup using the browser). For example, if you have installed AEM in the directory /InstallationKits/crx-quickstart/, then the backup is created in the /InstallationKits directory.
The curl command returns immediately, so you must monitor this directory to see when the zip file is ready. While the backup is being created a temp directory (with the name based on that of the final zip file) can be seen, at the end this will be zipped. For example:
•	name of resulting zip file: backup.zip
•	name of temporary directory: backup.f4d5.temp



Backing up to a non-default Target Directory
Usually the backup file/directory is created on the server in the parent folder of the folder containing the crx-quickstart folder.

If you want to save your backup (of either sort) to a different location you can set an absolute path to the target parameter in the curl command.
For example, to generate backupJune.zip in the directory /Backups/2012:

1
curl -u admin:admin -X POST http://localhost:4502/system/console/jmx/com.adobe.granite:type=Repository/op/startBackup/java.lang.String?target=/Backups/2012/backupJune.zip"


Filesystem Snapshot Backup
The process described here is specially suited for large repositories.
Note:
If you want to use this backup approach, your system must support filesystem snapshots. For example, for Linux this means your filesystems should be placed on a logical volume.
•  Do a snapshot of the filesystem AEM is deployed on.
•  Mount the filesystem snapshot.
•  Perform a backup and unmount the snapshot.



How AEM Online Backup Works
AEM Online Backup is comprised of a series of internal actions to ensure the integrity of the data being backed up and the backup file(s) being created. These are listed below for those interested.


The online backup uses the following algorithm:

1.	When creating a zip file, the first step is to create or locate the target directory.

•	If backing up to a zip file, a temporary directory is created. The directory name starts with backup. and ends with .temp; for example backup.f4d3.temp.
•	If backing up to a directory, the name specified in the target path is used. An existing directory can be used, otherwise a new directory will be created.
An empty file named backupInProgress.txt is created in the target directory when the backup starts. This file is deleted when the backup is finished.

2.	The files are copied from the source directory to the target directory (or temporary directory when creating a zip file).  The segmentstore is copied before the datastore to avoid repository corruption. The index and cache data are omitted when creating the backup. As a result, data from crx-quickstart/repository/cache and crx-quickstart/repository/index is not included in the backup. The progress bar indicator of the process is between 0% - 70% when creating a zip file, or 0% - 100% if no zip file is created.  
3.	If the backup is being made to a pre-existing directory, then "old" files in the target directory are deleted. Old files are files that do not exist in the source directory.



The files are copied to the target directory in four stages:
Stage 1. In the first copy stage (progress indicator 0% - 63% when creating a zip file or 0% - 90% if no zip file is created), all files are copied while the repository is running normally. The process has two phases: 
                       Phase A - everything is copied except for the datastore (with delay).
                       Phase B - only the datastore is copied (with delay).

    Stage 2.  In the second copy stage (progress indicator 63% - 65.8% when creating a zip file or 90% - 94% if no zip file is created) only files that were created or modified in the source directory since the first copy stage was started are copied. Depending on the activity of the repository, this might range from no files at all, up to a significant number of files (because the first file copy stage usually takes a lot of time). The copy process is similar to the first stage (Phase A and Phase B with delay).

Stage 3.
  In the third copy stage (progress indicator 65.8% - 68.6% when creating a zip file or 94% -  98% if no zip file is created) only files that were created or modified in the source directory since the second copy stage was started are copied. Depending on the activity of the repository, there might be no files to copy, or a very small number of files (because the second file copy stage is usually fast). The copy process is similar to the second stage - Phase A and Phase B but without delay.

Stage 4. 
File copy stages one to three are all done concurrently while the repository is running. Only files that were created or modified in the source directory since the third copy stage was started are copied. Depending on the activity of the repository, there might be no files to copy, or a very, very small number of files (because the second file copy stage usually is very fast). Progress indicator 68.6% - 70% when creating a zip file or 98% - 100% if no zip file is created. The copy process is similar to the third stage.

Depending on the target:
•	If a zip file was specified, this is now created from the temporary directory. Progress indicator 70% - 100%. The temporary directory is then deleted.
•	If the target was a directory, the empty file named backupInProgress.txt is deleted to indicate that the backup is finished.




Restoring the Backup
You can restore a backup as follows:
•	In case you performed a Filesystem Snapshot Backup, you can simply restore an image of the system.
•	In case you created the backup as a zip file, just unzip the contents in a new folder and start AEM from that location.
Package Backup
To back up and restore content, you can use one of the Package Manager, which uses the Content Package format to back up and restore content. The Package Manager provides more flexibility in defining and managing packages.


Scope of Backup
When you back up nodes using either the Package Manager or the Content Zipper, CRX saves the following information: 
•	The repository content below the tree you have selected.
•	The Node type definitions that are used for the content you back up.
•	The Namespace definitions that are used for the content you back up.
When backing up, AEM loses the following information: 
•	The version history.

Sling Models

Design Goals- 

•	Entirely annotation driven. "Pure" POJOs.
•	Use standard annotations where possible.
•	Pluggable
•	OOTB, support resource properties (via ValueMap), SlingBindings, OSGi services, request attributes
•	Adapt multiple objects - minimal required Resource and SlingHttpServletRequest
•	Client doesn't know/care that these objects are different than any other adapter factory
•	Support both classes and interfaces.
•	Work with existing Sling infrastructure (i.e. not require changes to other bundles).

Basic Usage –

For class:
In the simplest case, the class is annotated with @Model and the adaptable class. Fields which need to be injected are annotated with @Inject:
@Model(adaptables=Resource.class)
public class MyModel {

    @Inject
    private String propertyName;
}
In the above case, a property named "propertyName" will be looked up from the Resource (after first adapting it to a ValueMap) and it is injected.

For an interface, it is similar:

@Model(adaptables=Resource.class)
public interface MyModel {
    @Inject
    String getPropertyName();
}

For constructor :
@Model(adaptables=Resource.class)
public class MyModel {    
    @Inject
    public MyModel(@Named("propertyName") String propertyName) {
      // constructor code
    }
}
Because the name of a constructor argument parameter cannot be detected via the Java Reflection API a @Named annotation is mandatory for injectors that require a name for resolving the injection.

** In order for these classes to be picked up, there is a header which must be added to the bundle's manifest:

<Sling-Model-Packages>
  org.apache.sling.models.it.models
</Sling-Model-Packages>


This header must contain all packages which contain model classes or interfaces. However, subpackages need not be listed individually.

Multiple packages can be listed in a comma-separated list (any whitespace will be removed):
<Sling-Model-Packages>
  org.apache.sling.models.it.models,
  org.apache.sling.other.models
</Sling-Model-Packages>
Alternatively it is possible to list all classes individually that are Sling Models classes via the Sling-Model-Classes header.
adaptTo()-

MyModel model = resource.adaptTo(MyModel.class)


  
Other Annotations-

@Named -

If the field or method name doesn't exactly match the property name, @Named can be used:
    @Inject @Named("secondPropertyName")
    private String otherName;


@Optional and @Required
@Injected fields/methods are assumed to be required. To mark them as optional, use @Optional:

    @Inject @Optional
    private String otherName;

If a majority of @Injected fields/methods are optional, it is possible (since Sling Models API 1.0.2/Impl 1.0.6) to change the default injection strategy by using adding defaultInjectionStrategy = DefaultInjectionStrategy.OPTIONAL to the @Model annotation:

@Model(adaptables=Resource.class, defaultInjectionStrategy=DefaultInjectionStrategy.OPTIONAL)
public class MyModel {

    @Inject
    private String otherName;
}
To still mark some fields/methods as being mandatory while relying on defaultInjectionStrategy = DefaultInjectionStrategy.OPTIONAL for all other fields, the annotation @Required can be used.
@Optional annotations are only evaluated when using the defaultInjectionStrategy = DefaultInjectionStrategy.REQUIRED (which is the default), 
@Required annotations only evaluated  if using defaultInjectionStrategy = DefaultInjectionStrategy.OPTIONAL.
@Default
A default value can be provided (for Strings & primitives):

    @Inject @Default(values="defaultValue")
    private String name;
Defaults can also be arrays:

    @Inject @Default(intValues={1,2,3,4})
    private int[] integers;
OSGi services can be injected:

    @Inject
    private ResourceResolverFactory resourceResolverFactory;




OSGi Service Filters


@Inject
    @Filter("(paths=/bin/something)")
    private List<Servlet> servlets;

PostConstruct Methods

The @PostConstruct annotation can be used to add methods which are invoked upon completion of all injections:

    @PostConstruct
    protected void sayHello() {
         logger.info("hello");
    }


@Via

In some cases, a different object should be used as the adaptable instead of the original adaptable. This can be done using the @Via annotation. By default, this can be done using a JavaBean property of the adaptable:

@Model(adaptables=SlingHttpServletRequest.class)
public interface MyModel {

    // will return request.getResource().getValueMap().get("propertyName", String.class)
    @Inject @Via("resource")
    String getPropertyName();
} 




Those annotations replace @Via, @Filter, @Named, @Optional, @Required, @Source and @Inject. Instead of using the deprecated annotation element optional you should rather use injectionStrategy with the values DEFAULT, OPTIONAL or REQUIRED (see also SLING-4155). @Default may still be used in addition to the injector-specific annotation to set default values. All elements given above are optional.
Deep Dive on Sling Models in AEM6.3 

How to start using Sling Models
1.Add maven dependency to the pom.xml. If you are working with AEM 6.3, Make sure you are using the recent sling model version (1.3.2) 
<dependency>
<groupId>org.apache.sling</groupId>
<artifactId>org.apache.sling.models.api</artifactId>
<version>1.3.2</version>
<scope>provided</scope>
</dependency>
2. Create a package under which you will be writing all sling models and make an entry of that package (here com.sling.models.core.models) in bundle(core) ‘s pom.xml in Sling-Model-Packages tag within maven-bundle-plugin.
Here:
<plugin>
<groupId>org.apache.felix</groupId>              <artifactId>maven-bundle-plugin</artifactId>
               <extensions>true</extensions>
              <configuration>
                   <instructions>
                       <Sling-Model-Packages>
                           com.sling.models.core.models
                       </Sling-Model-Packages>
                   </instructions>
                 </configuration>
</plugin>

Validate that your class is actually working as a sling model.
•	Go to Felix Console.
•	Click on Sling Adapters from the Sling tab.
 
Fig- Sling Adapters in Felix Console


•	Sling Model class must be visible over here.


How to write a basic sling model?
// This model gets the path of the resource . @Model(adaptables = Resource.class) 
public class TestModel {
@Inject 
Resource resource; 

public String getPath() { 
return resource.getPath(); 
} 
}

In the initial state of sling models, we used to use @Inject annotation to inject services, pagemanager, sling objects etc. This is a generic Injector.

•	@Inject queries all Injector implementations “First Match” wins based on the service ranking.
•	Usage of Injector-specific annotations (Introduced in sling models Impl 1.0.6) will reduce the overall work of the internal execution as it specify the source explicitly so it is good to use Injector specific annotations.

Injector Specific Annotations in Sling Model

In AEM Felix console, you can see all the available injectors in sling models 1.3.2
 
Fig - Injector Specific Annotations in Sling Model
 
Fig - List of specific injectors

1. Script Variable: This Injector is used to get the currentPage, PageManager, Design, PageProperties etc. This injector is adaptable to request.This injector is adaptable to SlingHttpServletRequest.
ScriptVariable annotation has these attributes:
•	name
•	injectionStrategy: The Strategy can be Optional, Required or Default.

@Model(adaptables = SlingHttpServletRequest.class)
public class TestModel {
  
 // Injects currentPage using ScriptVariable annotation
   @ScriptVariable(name="currentPage")
   Page page;

   public String getPagePath() {
       return  page.getPath();
   }
}
Note: Here it is mandatory to use the object name “currentPage”. If there is a need to change the name of page object(currentPage), the “name” attribute can help us to do so.
The sightly script to call a sling model is:
<div data-sly-use.example="com.sling.models.core.models.TestModel">
              ${example.pagePath}<br/>
</div>

2. ChildResource : This injector is adaptable to resource and is used to get the specific child of a resource.
The attributes of the ChildResource are:
•	name
•	injectionStrategy
•	via

It works like:
@Model(adaptables = Resource.class)
public class TestModel {

   // Injects the child of the resource using ChildResource annotation
   @ChildResource(name="content")
   Resource child;

   public String getChildPath() {
     return  child.getPath();
   }
}
 
Fig - Inject Child resource directly

ChildResource annotations with its attributes:
@Model(adaptables = SlingHttpServletRequest.class)
public class TestModel {

   // Injects the child of the resource using ChildResource annotation
   @ChildResource(name="content",injectionStrategy= InjectionStrategy.OPTIONAL,via = "resource")
   Resource child;

   public String getChildPath() {
      return child.getPath();
   }
}

Note: ChildResource is adaptable to resource,but in the above sample, adaptables is a request.So "via" attribute is used to tell the property that the property is supposed to be fetch via resource.
The Demonstration video on @ScriptVariable and @ChildResource annotation:


3.ValueMapValue: This injector is adaptable to resource.Through this injector,the properties of the resource can be directly injected in the sling models.
The attributes of the ValueMapValue is:
•	name
•	injectionStrategy
•	via

@Model(adaptables = Resource.class)
public class TestModel {
   // Injects Resource and get ValueMap from the resource 
   @SlingObject
   Resource resource;

   public String getTitle() {
       ValueMap valueMap = resource.adaptTo(ValueMap.class);
       return valueMap.get(“title”, String.class);
   }
}

In place of adapting valueMap from the resource and getting title from valueMap,we can directly use ValueMapValue annotation in sling models.
@Model(adaptables = Resource.class)
public class TestModel {
   // Injects title from ValuMapValue
   @ValueMapValue
   String title;

   public String getTitle() {
       return title;
   }
}
 
Fig - Value Map Sample

The ValueMapValue annotation using its attributes:
@Model(adaptables = SlingHttpServletRequest.class)
public class Test {
  // Injects title from ValuMap annotation using its attributes
  @ValueMapValue(name = "title",via = "resource",injectionStrategy = InjectionStrategy.REQUIRED)
   String pageTitle;

   public String getTitle() {
       return pageTitle;
   }
}


4.ResourcePath: 
➤ If a resource is having a property whose value is a path, you can directly use that property as a resource.
➤ You can directly inject a path as a resource using this annotation. 

The attributes of the ResourcePath annotation is:
•	name
•	injectionStrategy
•	path
•	paths[]

@Model(adaptables = Resource.class )
public class TestModel {
 
  //directly inject a path as a resource 
   @ResourcePath(path = ”/etc/social”)
   Resource pathResource;
@ResourcePath(name = "path")
   Resource resourcePath;
   @ResourcePath(paths = {"/etc/social","/etc/tags"})
   Resource[]  paths;
}
 
Fig - Get the Resource by passing the path dynamically in sling model


5. OSGiService: If we need to inject OSGiService in Sling Models, we can use it like this:

@Model(adaptables = Resource.class)
public class TestModel {
   @OSGiService
   SlingSettings slingSetttings;
}


6. SlingObject: Supports sling based Objects like request,response, ResourceResolver, Resource and Sling ScriptHelper.

@Model(adaptables = SlingHttpServletRequest.class)
public class TestModel {
 
   @SlingObject
   Resource resource;

   @SlingObject
   ResourceResolver resourceResolver;
}

7.Self:
➤ Injects the adaptable object itself.
➤ An object that can be adapted from it if self annotation is present.

The only attribute in Self annotation is injectionStrategy.

@Model(adaptables = SlingHttpServletRequest.class)
public class SelfExampleModel {

   @Self
  Node node;

   public String getNodePath() throws RepositoryException
  {
      return node.getPath();
  }
}

8. Request Attributes: When there are input parameters while initializing the sling model , and you want to get these parameters in the sling model, you can use this annotation.

The attributes of RequestAttribute annotation are:
•	name
•	injectionStrategy

@Model(adaptables = SlingHttpServletRequest.class)
public class TestModel {
  
   //Injects all the input parameters from sightly  injects as RequestAttribute in Sling Models
   @RequestAttribute(name = "color")
   String param;

public String getParam() {
      return param;
  }
}

The sightly script calls the sling Model using input parameter :
<div data-sly-use.example="${'com.sling.models.core.models.TestModel ’ @ color='red'}">
       ${example.param}<br/>
</div>


@Inject: This annotation is used to inject a property, resource, request anything.This is a generic annotation, which traverses all the sling model injectors based on service ranking.

@Model(adaptables = Resource.class)
public classTest {

  @Inject
  String path;

  public String getPath() {
      return path;
  }
}

@Named: If there is a need to change the getter of any attribute like (sling:resourceType, jcr:primaryType) @Named annotation helps to achieve this.


@Model(adaptables = Resource.class)
public class Test {


  @Inject @Named("sling:resourceType")
  String slingResourceType;

  public String getSlingResourceType() {
      return slingResourceType;
  }
}

@Default: A default value can be provided for Strings or primitive data types.If there is no value of that property, default value takes place.


@Model(adaptables = Resource.class)
public class Test {


  @Inject @Default(values = "/content/test")
  String path;

  public String getPath() {
      return path;
  }
}

@Optional and @Required: In the sling models, by default all the fields supposed to be required.Sometimes there is a need to mark them as optional and required specifically.So injector fields can be annotated with @Optional and @Required.

If a majority of @Injected fields/methods are optional, it is possible to change the default injection strategy by using adding defaultInjectionStrategy = DefaultInjectionStrategy.OPTIONAL to the @Model annotation:

@Model(adaptables = Resource.class)
public class Test {

  @Inject @Optional
  String path;

  @Inject @Required
  String title;

  public String getTitle() {
      return title;
  }

  public String getPath() {
      return path;
  }
}
@Source: If you are using @Inject annotation and you want to specifically tell the sling engine that which specific injector you want to inject, you can use this annotation.All the specific injectors can also be used with @Source annotations.Using this annotation is equivalent to using injector specific annotation in a different way.

@Model(adaptables = SlingHttpServletRequest.class)
public class Test {

  @Inject  @Source("script-bindings")
  Page currentPage;

  public String getPath() {
      return currentPage.getPath();
  }
}
@Via : SlingHttpServletRequest has more objects than resource. Sometimes there is a need of using two injectors one from request and one from resource, Then we need to tell annotation explicitly that you are coming via resource.

@Model(adaptables = SlingHttpServletRequest.class)
public class TestModel {
   
   // Injects ResourcePath with Via annotation
   @ResourcePath(path = "/etc/social") @Via("resource")
   Resource resource;
   
   // Injects currentPage from ScriptVariable adaptable to Request
   @ScriptVariable
   Page currentPage;
}
@PostConstruct: The @PostConstruct annotation can be used to add methods which are invoked upon completion of all injections: This method automatically gets called when a sling model instance is created.
Note:The name of the method doesn’t matter, only it is matters that on which method the PostConstruct annotation exist.


@Model(adaptables = SlingHttpServletRequest.class)
public class Test {

 @Inject @Source("script-bindings")
 Page currentPage;
 
  String path;

 @PostConstruct
 protected void postMethod() {
     path = currentPage.getPath();
 }

 public String getPath() {
     return path;
 }
}
The Demonstration video on @Inject, @Named, @Default, @Optional, @Required, @Source, @Via and @PostConstruct:


@AemObject Annotation by ACS Commons Package

ACS Commons package provides one more injector specific annotation named @AemObject.This annotation provides the support of a lot of objects shown below:
 
Fig- List of object in @AemObject annotation provided by ACS Common
This annotation is not the part of sling models, so if sling models itself has all your needed injectors, no need to go for it.But some Objects are not available with sling models like Tagmanager, WorkflowSession, WCMMode, at that time, this annotation can help you. Remember your project must have dependencies of ACS-Commons before using this annotation.

@Model(adaptables = SlingHttpServletRequest.class)
public class TestModel {

// Injects currentPage using ScriptVariable annotation
@AemObject
Page currentPage;

public String getPagePath() {
 currentPage.getPath();
}
}

List Injection From Child Resource(Since Sling Models Impl 1.0.6)

+- resource (being adapted)
|
+- content
   |
   +- subchild1
   |
   +- subchild

@Model(adaptables = Resource.class)
public classTest {

  @Inject
  List<Resource> content;
  
 public int getSize()
  {
      return content.size();
  }
}
Sling Adapter Framework
1.adaptTo: Apache Sling provides a way to adapt Sling related classes to our domain classes. The Resource and ResourceResolver interface provides the adaptTo method, which adapts the objects to other classes.
With the adaptTo API we can convert the Sling-related objects to our Model objects by using the AdapterFactory classes.
Test model = resource.adaptTo(Test .class)
As with other AdapterFactories, if the adaptation can't be made for any reason, adaptTo() returns null.
2.ModelFactory (Since1.2.0): Since Sling Models 1.2.0 there is another way of instantiating models. The OSGi service ModelFactory provides a method for instantiating a model that throws exceptions.There is no need of null checks and it is easier to see why sling model instantiation is failed. ModelFactory API provides a lot of methods, which can be efficiently used.


public class ModelServlet extends SlingSafeMethodsServlet {

@Reference
ModelFactory modelFactory;

@Override
protected void doGet(final SlingHttpServletRequest req,final SlingHttpServletResponse resp) throws ServletException, IOException {


 Resource resource = req.getResourceResolver().getResource("/content/community-components/en/tagcloud/jcr:content");


 Test test = modelFactory.createModel(resource, Test.class);
 resp.getWriter().println(test.getResourceType());
 resp.getWriter().println(modelFactory.canCreateFromAdaptable(resource, Test.class));
 resp.getWriter().println(modelFactory.canCreateFromAdaptable(req, Test.class));

}
}

@Model(adaptables = Resource.class)
public class Test {


 @Inject @Named("sling:resourceType")
  String resourceType;


  public String getResourceType()
  {
      return resourceType;
  }
}

@Self example
Let’s imagine, that we need to get suffix from the request in our Sling Model. Then, depending on it, we will return different content. So we will create our first model – the one, which extracts suffix from the request:
 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17	package com.taradevko.aem.model;
 
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.models.annotations.Model;
 
import javax.inject.Inject;
 
@Model(adaptables = SlingHttpServletRequest.class)
public class RequestAdapter {
 
    @Inject
    private SlingHttpServletRequest request;
 
    public String getSuffix() {
        return request.getRequestPathInfo().getSuffix();
    }
}
There we inject the request we adapted this model from and one method for returning suffix. Now we are ready to use @Self annotation:
 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25	package com.taradevko.aem.model;
 
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.models.annotations.Model;
import org.apache.sling.models.annotations.injectorspecific.Self;
 
import java.util.HashMap;
import java.util.Map;
 
@Model(adaptables = SlingHttpServletRequest.class)
public class SelfModel {
 
    private static final Map<String, String> CONTENT = new HashMap<>();
    static {
        CONTENT.put("/suffix1", "Content 1");
        CONTENT.put("/suffix2", "Content 2");
    }
 
    @Self
    private RequestAdapter requestAdapter;
 
    public String getContent() {
        return CONTENT.get(requestAdapter.getSuffix());
    }
}
Let’s go through the code snippet above:
•	we have a static map with demo content where the key is the suffix we expect to get from the user;
•	we inject RequestAdapter using @Self annotation;
•	method getContent, where we use our request adapter.
Finally, we will add next HTL markup to our component:
 
1
2
3
4	<pre data-sly-use.model="com.taradevko.aem.model.SelfModel">
    Your suffix brought next content:
    ${model.content}
</pre>
There we just initialize our model, call getter method on it and display the result. Let’s test it:
 
As you can see, we got the string which has been mapped for the suffix /suffix1, so it works!






AEM adobe analytics DTM target


/* Adobe Analytics */
		/* ***************************************************************************** */
		
		/* Secondary Approach For Analytics - AEM integrated environment ---Starts here--*/
		
               AEMSet('window.digitalData.car.carbrand', sel);
               AEMTrack('carBrandSelect');

		/* Secondary Approach For Analytics - AEM integrated environment ---Ends here-- */
		
		/* ***************************************************************************** */
export function AEMTrack(msg: string) {
  const w = <any>window;
  if (w && w._satellite &&  w._satellite.track && typeof w._satellite.track === 'function' ) {
    w._satellite.track(msg);
  }
}

export function AEMSet(propPath: string, value: any): void {
  const propPathParts = propPath.split('.');
  if (propPathParts[0].toLowerCase() === 'window') {
    propPathParts.shift();
  }
  propPathParts.reduce((currProp, pathPart, currIdx) => {
    if (currIdx === (propPathParts.length - 1)) {
      // last, set the val
      currProp[pathPart] = value;
    } else {
      if (!currProp[pathPart]) {
        currProp[pathPart] = {};
      }
      return currProp[pathPart];
    }
  }, window);
}

================

var event = digitalData.event.pop(); // take the last element

_satellite.notify("DCR carBrandLabel invoked, proceeding...");
console.log(event);
if(event &&
  event.eventInfo &&
  event.eventInfo.eventName &&
  event.eventInfo.eventName=="carBrandLabel"){
  _satellite.notify("WORKS! - event name equals carBrandLabelclicked");
  s.clearVars();
  s.events = "event101";
 // s.eVar101 = event.details.hero.id;
  //s.eVar102 = event.details.hero.name;
  s.tl();
}
else{
  _satellite.notify("error - event name [" + event.eventInfo.eventName + "] does not equal heroclicked");
}



You can create Adobe Experience Manager (AEM) solutions that integrate with these Ditigal Marketing products: Adobe Analytics, Adobe Target, and Dynamic Tag Manager (DTM).
Adobe Analytics is the industry-leading solution that lets digital marketers analyze and optimize integrated data from all online initiatives across multiple marketing channels. It provides marketers with actionable, real-time web analytics intelligence about digital strategies and marketing initiatives.
Adobe Target is a personalization solution that lets you easily identify content through tests that are easy to execute. Therefore, you can deliver the best experience to your web visitors. In this article, personalization of the landing page is driven by Target. AEM will import Audiences from Target so that they can be used right within AEM to create activities to personalize our page. AEM then synchronizes the activity to Target.
DTM is a Digital Marketing cloud service that allows a marketer to manage Adobe and third-party tags used for tracking or other analytic purposes. It is done through client-side scripting that injects tag related code throughout the pages of the site.
Adobe DTM
Create the DTM rule
DTM uses rule-based scripts that consist of user interaction and associated data. When the criteria specified in your rule is met, the rule triggers the tool, script, or HTML you identified. A rule consists of two parts:
•	identifier
•	trigger
An identifier is what the rule looks for:
•	An event-¬based rule is dependent on user interaction with the page.
•	A page load rule is dependent on the URL, site section, or on the user’s site visit length.
•	A direct call rule is dependent on a specific call that is initiated by a custom script.
You can define rules in DTM web interface and use them within AEM web pages. In this development article, a page load rule is created that is invoked when a page is opened.
To create a DTM rule, perform these steps:
1. Log into DTM at http://dtm.adobe.com.
2. Create a web property by clicking on the Add Property button within the Company page. A Property is defined per domain basis.
 
 
The Add Property button



Complete the property form using these values:
•	Name  - AEM_TARGET_ANALYTICS_VIA_DTM
•	URL- http://localhost:4502
 
 
Create Property View

4. Click Create Property and then at home page you will see this property added. Click the property name to configure it.
5. The new property requires approval from an Admin. Once approved it will go to Active state, which means you’re now ready to start configuring the Property.
5. From the Web Properties tab, click on the AEM property, as shown here.
 



7.	 Click the Rules tab, then from the left hand menu, select Page Load Rules and then click Create New Rule. This action opens the Create New Page Load Rule screen. 

 
8.	Name the rule AlertJS. Also select Onload for the Trigger rule at drop-down, as shown in the following illustration. 
 



Under the Javascript /Third Party Tags section, select the Non-Sequential tab then click on the Add New Script button. 
9 From the editor popup, enter HelloDTM for the Tag Name and enter the following code:
alert("DTM Activation");
10. Click Save Code, Save Rule.
Activate the AlertJS rule
After you create the AlertJS rule, you have to activate it before you can use it. To activate the rule, select Activate Rule from the Actions drop-down as shown in the following illustration. Once you perform this task, you can use it within an AEM web page.


 

Configure the deployment options
Click the Embed tab and select one of the available deployment options in the left sidebar. In this example, select the Akamai option.
 

Copy the Staging Embed Code for Header and Footer code. 

This is the script that is referenced when you configure AEM (in the next step). This script value is required for this rule to be used in an AEM web page. 

 

Configure AEM to use DTM Rules
Setup a connection to DTM by using Cloud Services.
When setting up a DTM connection within AEM, you have to specify a title of the connection, as shown below. 

 

When you configure DTM, you need an API Token from your DTM account to successfully connect from AEM to DTM. You can also test the connection from the DTM dialog by clicking Connect to DTM, as shown in this illustration. Ensure that you unclick the Include Production Code on Author checkbox.

 


You can retrieve the API Token from DTM by clicking on Account Settings. The API Token value is located near the bottom of the screen, as shown in this illustration.  

 

To configure an AEM connection to DTM, perform these steps.
1.	From the side rail in AEM 6.2, click the Hammer icon, Deployment, and then Cloud Services.
2.	Under Dynamic Tag Management, click Show Configurations.
3.	Click Configure Now if this is the first configuration. Click Show Configurations and then click the + link beside Available Configurations if one or more configurations have been created.
4.	Type AEM-DTM-Connection as the title for the configuration and then click Create.
5.	In the API Token field, enter the value of the API Token property of your Dynamic Tag Management user account.
6.	Click Connect to DTM. AEM authenticates with Dynamic Tag Management and retrieves the list of companies that your account is associated with.
7.	Select the Company, and then select the Property (AEM_TARGET_ANALYTICS_VIA_DTM).
If you are using staging code on the author instance, deselect Include Production Code On Author.
8.	Provide the script values for the properties on the Staging Settings tab and the Production Settings tab (make sure the self hosting checkbox is un-checked), then click OK.
Note: At this point, you have created a connection from AEM to DTM named AEM-DTM-Connection. This connection references the DTM Property that you created named AEM_TARGET_ANALYTICS_VIA_DTM.



Embed DTM rules in AEM web pages

Embed DTM rules into an AEM web page by using Page properties that belong to the AEM site. In this example, embed DTM rules into the Geometrix Media site. First, login to the AEM author instance and go to
http://localhost:4502/siteadmin#/content/geometrixx-media
as displayed in this illustration.
 

Right click on the page (in this example, English) and select properties. Next, select the Cloud Services tab. Then click the Add Service button. This brings up a list of Digital Marketing Cloud Services, as shown in this illustration.

 



Select Dynamic Tag Management and click Ok. In the Dynamic Tag Management drop-down, select the AEM/DTM connection that you setup (AEM-DTM-Connection). Now rules associated with this configuration will show up in the AEM site. 
 



Now rules defined in DTM appears in the Geometrixx Media sample site. When you open a geometrixx-media page, an alert box is displayed, as shown in the following illustration. 
 


Setup Adobe Target
Setup  Target by performing these steps:
1. Login to Marketing Cloud at marketing.adobe.com.
2. Select Target and launch it, as shown in the following illustration. 
 
 

.  Click Setup in the top menu.  

 

Integrate Target into DTM Rules
You can integrate Target into the DTM rule that you created. Perform these steps: 
1. Go to the AEM_TARGET_ANALYTICS_VIA_DTM property that you created in DTM.
2. From the Overview, click Add one now?
 
Add Tools


. Select Adobe Target.
4. Enter the following information in the Adobe Target Setting Page: 
•	Tool Type - Adobe Target
•	Tool Name - Adobe Target
•	Library retrieval method - automatic
•	Client code retrieval method - manual
•	Client code - enter the client code from Target
5. Click Save Changes.
6. Activate and publish the new tool.
Congratulations Target is configured through use of DTM.


Create the Target Activity
Activities enable you to test page designs and target content to specific audiences. Create an Activity in Adobe Target by performing these steps.
1. Click Activities from the menu.


 
\

Click Create Activity, A/B Test, Form-based.
3. Under Experience A, Select target-global-mbox.
 


Add an experience by clicking Add experience (Left column).
6. Go to Refinements,  Add rules.
7. Add a query rule, as mentioned in the image below. The query here specifies that if there is a query parameter in the givenURL with K=1, then Target responds. It displays either experience A or B based on the Target algorithm.
 
 


Under the Content section, select HTML Content and add your HTML code there.
9. Click NEXT.
 
 
Target settings


Click Next. 
11. Select the Primary Goal as Engagement, measure as Page Views. Click Save.
 


 Click Activate to activate the target activity. You will see the following message. 
 
Activating the Target activity



Test the Target Activity in AEM
Go to Geometrixx-outdoors English page (where you setup DTM integration) and add query parameters:
http://localhost:4502/content/geometrixx-outdoors/en.html?test=1
Open the link in some incognito windows because the experience will have 50% chance to come up in new windows. This is the Result/Confirmation that Target is working properly.
 
Target results in AEM




Integrate Adobe Analytics
You can integrate Adobe Analytics into this Digital Marketing Cloud example. To integrate Adobe Analytics, perform these steps: 
1. Login to Adobe Analytics at sc.omniture.com.
2. Go to Admin, User Management, Users, Search for you name, Edit the profile.
3. Now search for Web Service Credentials. These are required for setting up Analytics by using DTM. Save User name and Shared Secret.
 
Integrate Analytics into DTM
Integrate Adobe Analytics into DTM by performing these steps: 
1. Go to the AEM_TARGET_ANALYTICS_VIA_DTM property in DTM.
2. Click Overview, Add Tool.
3. Add Web User Credentials that you saved in Adobe Analytics.
 


 Click Create tool.

 Add the Report Suit where you would like the data to be present. Add for both Production and Staging.
In General Section add:
•	Char Set:  UTF-8
•	Currency code:  USD
6. In the Library Management section:
•	 Code Configuration:  Managed by Adobe
 
 


 Click Save Changes.


How to use DTM for single page application.


A Single Page Application (SPA) is a web application or website that loads all of the resources required to navigate throughout the site on the first page load. As the user clicks links and interacts with the page, subsequent content is loaded dynamically. The application will often update the URL in the address bar to emulate traditional page navigation, but another full page request is never made.



Method 1 - Direct Call Rules (DCR’s)


Fire a Direct Call Rule, like _satellite.track(“page view”) on everything considered as a page view, whether it’s a fresh new DOM or not.

Method 2 - Push state or hash change

The pushState or hashchange event can be used with Single Page Apps (SPAs) in which a page does not reload, but its content changes. Common development frameworks that can be used to create SPAs include Angular and React. This event type lets you create event-based rules without relying ondevelopers. These rules fire when common functions in SPAs occur, such as:
•	The URL path changed based on use of the HTML5 History pushState API.
•	The hash changed due to the user changing views or locations on the page.

Step 1: Create a new Event based rule and choose event type as “Push State or Hashchange”
 
Step 2: Under rule condition choose criteria as “Hash” and then specify the hash parameter
 
Please note that in case of SPA’s two or more image request are made on the same page. Therefore, it is required to clear the values of the previously-set variables.
For s.tl() i.e. Link Tracking calls, this can be accomplished by:
•	Writing a simple JavaScript function to clear the Adobe variables
•	Set the linkTrackVars and linkTrackEvents variables if you have not already done it in the s_code.js / App Measurement file
•	Set the values appropriate for the changed content, namely the pageName variable.
•	After the variables are set, call the tl() function


Sample Code :
1
2
3	s.linkTrackVars="prop1,eVar1,events"; s.linkTrackEvents="event1"; 
s.prop1="some value"; s.eVar1="another value"; s.events="event1"; 
s.tl(this,'o','My Link Name');
For s.t()  i.e. Page View calls, this can be accomplished by:
Clearing any values on the s object that you do not want to persist. if you are using AppMeasurement for JavaScript, you can call s.clearVars(). If you are using H code, write a simple routine to set variables to an empty string.
Sample Code :
1
2
3
4	s.clearVars(); 
s.pageName="New Page"
s.prop1="some value"
void(s.t());
Method 3 - Custom Event Based rule
DTM can also react to custom events that happens on the page. A custom event triggered from DOM can be tracked using Event based rules with event type as “Custom Event”.
Let’s take an example of an Ecommerce SPA where idea is to fire “Page view” calls when the person browses from one page to another on SPA without loading the new page.
Step 1: Create a new Event based rule and choose event type as “Custom Event” and specify the  friendly name “Custom_Page_View” for triggered event type. “#content” is specified in the “Element Type or Selector” field, because that field is where the event is dispatched. Select the “Apply event handler directly to element” check box, the rule wouldn’t fire without it.
 

Step 2:  In Analytics section of the rule, check the radio button for “s.t()” tracking as it is required to track a “page view “ in this use case. 

 

Step 3: Put the code into your site that creates and dispatches the event.


 

We can reference the data sent through the event using %event.detail.pageName% in the Analytics section of the rule.
 
Note: Regardless of any of the above three method used, we may need to suppress the initial page view beacon the Analytics tool will want to set by default. Otherwise, in the example above where the developers are firing a direct call rule or EBR on all page views, you’d get TWO beacons on the first page and 1 on all subsequent pages. Please see the sample code to suppress the initial page view beacon from Analytics tool.
•	 Add "return false" to any Analytics Tool custom code block that runs on that page.
 



Discusses how to display dynamic content based on user preference using campaigns, segments, and teasers.  

Perform these tasks:
1.	Register example users for the Geometrixx Media site.
2.	Create a campaign.
3.	Create teasers used in the campaign.
4.	Create segments.
5.	Map segments to user preferences.
6.	Link segments and teasers.
7.	Create a new geometrixx media page.
Note:
STATIC OR EDITABLE TEMPLATE? AN IN-DEPTH COMPARISON AND GUIDE
Editable templates

Template Creation
For static template, it’s developed by developers with a cq:Template type and has a jcr:content node with sling:resourceType of the page component. After code is deployed to AEM, the temple will be available to use.

For editable template, a project specific folder is recommended to be created under /conf, AEM comes with /conf/global by default and you can use that if it must (but that needs to be enabled also before use).


You can create the conf project folder (or enable /conf/global folder) by going to Tools -> General -> Configuration, check the “Editable Templates” box. If you prefer, you can also create it in your project code repository and deploy to AEM.
The folder should have /conf/<your-project>/settings/wcm/templates, which holds all editable templates for this project; /conf/<your-project>/settings/wcm/policies, which holds all page and component content policies; and /conf/<your-project>/settings/wcm/template-types (not a must, if you only use OOTB template types), which is kinda the template of an editable template and is copied over to the template (after that, only a static reference between template type and the template created from it). 


There are several OOTB template types:
/libs/settings/wcm/template-types/html5page
/libs/settings/wcm/template-types/afpage
/apps/settings/wcm/template-types/coreCmpPage (came with AEM Core WCM Components).
Structure

•	Template location

For static template, template code is usually stored at /apps/<your-project>/templates.

For editable template, template code is stored at /conf/<your-project>/settings/wcm/templates. The template types and policies, however, can be stored at /conf, /apps and /libs. They follow the same order in resource resolution strategy as well.

•	Structure in repository
For static template, /apps/<your-project>/templates and /apps/<your-project>/components/structure should be created by default from the Adobe AEM project maven archetype.
For editable template, you can create the /conf/<your-project> structure in either ui.content or ui.apps module in your project.

•	Page/component design

For static template, design is stored at /etc/designs/<my-site>/jcr:content/<page-component-name>/<component-name> (if page has a design path of /etc/designs/<my-site>) 

or /etc/designs/default/jcr:content/<page-component-name>/<component-name>.
For editable template, design is stored at /conf/<your-project>/settings/wcm/policies.
•	Template node structure

       For static template, it looks like:
1.	/apps/<your-project>/templates/
2.	<your-template-name> [cq:Template]
3.	jcr:content [cq:PageContent]
4.	(optional)<list-of-components> [nt:unstructured]

For editable template, it looks like:
1.	/conf/<your-project>/settings/wcm/templates/
2.	<your-template-name> [cq:Template]
3.	initial [cq:Page]
4.	jcr:content [cq:PageContent]
5.	policies [cq:Page]
6.	structure [cq:Page]
7.	(optional)thumbnail.png


•	Page structure

Page created from a static template has initial nodes from the template, while page created from editable template usually has a “root” node and will have initial nodes under /<your-template-name>/initial, they are editable components. The page will also render with non-editable components defined in /<your-template-name>/structure. These components have a “lock” status and don’t have property editable = “{Boolean}true”.




Page Creation
Before page can be created, you need to make sure either static or editable template is allowed in the designated path. Usually you can set Allowed Templates on (root) page properties, or you can set allowedPaths property in the cq:Template node. Precedence and detail can be found here.

 

There is no difference in page creation process, content authors cannot tell editable template from static template in the create page wizard. Both are displaying template title and thumbnail.

 
After page is created, page from editable template will not have design mode option. And there will be dynamic connection between the template and page. A change in /<your-template-name>/structure may hide component/content in existing page. Page from static template, however, will not have dynamic connection to the template after the page is created, changes to the template will not affect existing pages.


Permissions
Permission is not applicable to static template except to set up the standard authoring permissions and privileges for content authors. However, editable template is required to set up the default template authors group and configure the required access rights (ACLs) for these authors to create and edit templates in the /conf/<your-project>. That means they will need full access under /conf/<your-project>/settings/wcm/templates and /conf/<your-project>/settings/wcm/policies, and they will need at least read access under /conf/<your-project>/settings/wcm/template-types.

Tips and Tricks
1.	If you create the editable template structure manually in your code base or CRXDE, make sure you have a /settings/wcm/templates node (even is empty), otherwise the folder won’t show up in the templates console.
2.	It’s also good to have a /settings/wcm/policies node, otherwise the content policies may write to /apps/settings/wcm/policies.
3.	If you have custom template types, it’s best to put the /settings/wcm/template-types node in the same path as where you put your /templates and /policies nodes.
4.	In your module’s /META-INF/vault/filter.xml, set filter properly so it doesn’t overwrite other folders inside /conf, or the project’s templates (/conf/<your-project>/settings/wcm/templates) and policies (/conf/<your-project>/settings/wcm/policies), since they will have authored content in JCR.
5.	Component code may require update if it needs to be drag and drop onto the editable template.
6.	In order to show the mobile emulator in toolbar and use the Layout mode, make sure your page resource type is added to com.day.cq.wcm.mobile.core.impl.MobileEmulatorProvider-<app-name>.xml.
7.	Set access rights properly if you use editable template, see Permission section.
8.	Put internationalization in mind when creating the editable template.
9.	Set up template availability strategically so correct templates show up in the right page path and easy to track and modify, test thoroughly for your use cases, see Page Creation section.
10.	If you already have a custom content policy, you can change the cq:policy in /conf/<your-project>/settings/wcm/policies, otherwise there are default policies you can use from wcm/foundation/components.
11.	Reference to ootb templates, Adobe sample projects when you are stuck, see References section.


Considerations
Static Template:
Being the legacy way of using and developing template, if your company have been on AEM for a while, your developer and content authors may have already got comfortable with static template, it has a smaller learning curve. Structure wise, I find static template simpler and straight forward, usually everything is defined in the page component. But the major drawback is that it is a developer only task. Developer develops and provides all the variations of template in the code, the template cannot be changed without a code release. Template cannot be visualized in AEM before a page is created. You may find yourself writing more code in the page component to include different business requirements. You may also end up having a new template and/or page component with small variations.


AEM --Content As AService

AEM 6.3’s Content as a Service (CaaS) is an editor-empowered tool to provide an aggregated view of content within the JCR. That content can be assets, content fragments or pages, intended for external consumption. Uses would typically be mobile applications, portals, external web applications, or even an AEM site itself.
CaaS is disabled by default. Use the AEM system console to enable via the AEM Content Services Feature Flag:
 
Create the service (Caas)-

Using Touch UI, click Mobile, then Spaces:
 
 
Create a space.
 
 

Entities are the content you are expositing, and can be either an Asset Model or Page Model (additional models can be created). The space you created above is a container for entities. Create an entity:

 

Choose the Asset Model.

 

Fill-in the information, and click Create:

 


Once you’ve created the entity, click Open:

 

We’ve already created a couple of example content fragments, so let’s choose those. Click the +Add button:
 
Select the content fragments:

 

Click Save under Save & Close:
 

You should see a success message:

 
PREVIEW THE SERVICE ON AUTHOR
Click on the Preview link and you’ll what the service looks like in jSON format. Note that you can change the selector name and depth.
 


 

 

PREVIEW THE SERVICE ON PUBLISH
To preview on Publish, we must first publish the service (which will also publish the content). Click Save & Close:
 
Click Publish Tree:
 

 

Click Open on Publish:

 

 

To fetch the asset, click on the href and download the content fragment:

 

Open the downloaded fragment in an editor:
 
The fragment:
 

This is the way the fragment looks back in the Content Fragment Editor.




 

Editable Template:
With editable template, you give template authors the flexibility to create and modify the template as they want. It acts as a central place to manage everything about the template (structure, initial content, layout) and components used in the template. It’s more modular as you can control what components author can see and use on the page, if the component is editable or not, what design properties the page/components have, how should the component display on different devices, or even hide it on small screens. With the granularity level editable template supports, it has a more complex node structure than static template. If you are migrating to use editable template, make sure you accessed the requirements for not only the template but also the components. Expect bugs as you use template editor. For example, iparsys doesn’t work in template editor based pages. Since it’s new and more complex, time should be allocated and POC should be performed to set up the environment and foundation, so the transition can be smooth for production. Also training is recommended to admin, developers, template authors and content authors.
To build all the modules run in the project root directory the following command with Maven 3:
mvn clean install
If you have a running AEM instance you can build and package the whole project and deploy into AEM with
mvn clean install -PautoInstallPackage
Or to deploy it to a publish instance, run
mvn clean install -PautoInstallPackagePublish
Or to deploy only the bundle to the author, run
mvn clean install -PautoInstallBundle


AEM/CQ5 On/Off Time vs Activate Later On Content and Understanding
Activate later and On-Off Time of Content are two different behavior in CQ5/AEM 6. When you apply activate later on any content , that content gets activated at given time and exist in publish instance until it is deactivated or deleted.

On-Off time is little different . It adds additional attribute as properties to the content but it does not activate content. To make it available on publish, it has to be activated. The On and Off Time gets applied on publish site. When Off time matches or greater than current time , CQ5 OSGI Services consider that content as dead and if you try to access using HTTP, CQ5 would return 404 error.
However that content resides in JCR opposite to deactivate feature that deletes content from Publish JCR.That’s the catch and generally Developer thinks  that off time would make content disappear but that’s not the fact.
Off time related content can be checked in CQ5 Component like this.
<% currentPage.isValid()%> or You can use ResourceUtil Class that will return false because Off time has been applied and even that exist in Publish JCR would be considered as dead content.
How to Re-use dialog tabs for Touch UI in AEM 6.x versions
Classic ui –
xtype="cq:include"
path="foundation/components/page/cq:dialog/content/items/tabs/items/basic.infinity.json"
touch ui – 
sling:resourceType="granite/ui/components/foundation/include"
path="foundation/components/page/cq:dialog/content/items/tabs/items/basic"


 AEM Code Snippets : How to get Page object based on path ?
page = pageManager.getContainingPage(pagePath);

OOTB multifield control which is part of AEM 6.3 and the main advantage of this is we do not need to use ACS touch UI multifield control.
 For one thing, you do not need to write a JS script or use the ACS-Commons package as is typically required when using a granite/ui/components/foundation/form/multifield
For creating layout of dialogbox touch UI
Authoring dialogs-  sling:resourceType="granite/ui/components/coral/foundation/container”
Tabs-
sling:resourceType="granite/ui/components/coral/foundation/tabs"
Fixed coulmns-
sling:resourceType="granite/ui/components/coral/foundation/fixedcolumns"
Container –
sling:resourceType="granite/ui/components/coral/foundation/container"
Mulitfield-
sling:resourceType="granite/ui/components/coral/foundation/form/multifield"
Forms- 
sling:resourceType="granite/ui/components/coral/foundation/form/textfield" or textarea

for linkurl-sling:resourceType="granite/ui/components/coral/foundation/form/pathfield" 



Example- 
Multifield with two widget
Linkurl and linktext
1.	Create Model pojo class ,  @Model(adaptables = Resource.class)
Inject Node that countain mulitfield property as resource 
    // Inject the products node under the current node
2.	Refer the the model class in slightly 
3.	<data-sly-use.multiItems="com.htl.community.coral.core.models.Multifield">
4.	Here, data-sly-list.head maps to all of the items in the multifield using ${multiItems.products.listChildren}.

How to acces the child node
Resource childResource = getResource().getChild("items"); 

Touch UI validations
Go to the title node of page component and add “validation=regex.validation” property, using this property we are going to find out object of text field in javascript
Create a file validations.js and add below code
(function($) {
   var REGEX_SELECTOR = "regex.validation",

    foundationReg = $(window).adaptTo("foundation-registry");
    foundationReg.register("foundation.validation.validator", {
        selector: "[data-validation='" + REGEX_SELECTOR +"']",
        validate: function(el) {
           var regex_pattern = /^[a-zA-Z]$/;
            var error_message = "This field allows alphabets only.";
            var result = el.value.match(regex_pattern);
            if (result === null) {
                return error_message;
            }
        }
    });}(jQuery));
AEM 301 Redirect Handler
when someone requested a page instead of that if you want to redirect the user to some other page without affecting SEO then we can use 301 redirect handler
This is very useful when it comes to migration project’s, there are some pages which are on legacy system and other pages are on AEM, and if you want to serve legacy pages from the AEM domain then you can  implement 301 redirect handler
Let us take a simple example, I have initially published an article in grey area.in domain after some point of time I thought of migrating entire content to the keys and strokes domain without affecting SEO, what I did was added some rewrite rules at apache level, you can use Apache if you want to migrate entire thing but what if I want to redirect only certain pages, then we need to implement 301 redirections at a page level, the next section covers how can we do this in AEM
  Touch UI in AHow to Re-use dialog tab 301 RedirectHandler In AEM
s fo6.x versionsEM 6.x versions
Adpative image

Image node

Property 
Class-cq-droptarget
Sling :resourcetype cq/gui/components/authoring/dialog/fileupload
Filenameparam
Filereferenceparam
Mimetypes	 The browse and selection filter for file selection. E.g: [”.png”,”.jpg”] or [“image/*”].
allowUpload="{Boolean}false
uploadUrlstring
The URL where to upload the file, you can use ${suffix.path} to use the current suffix
autoStartstring
true to make the upload starts automatically once the file is selected.

Editconfig
Cqdroptarget
Image (cq:droptargetconfig 
Property  propertyname=./filereference
Accept – mimetype
Group media
•	AdvancedSelect
o	AdvancedSelectStatus
•	Autocomplete
o	AutocompleteList
o	AutocompleteTags
•	Checkbox
•	ColorPicker
•	DatePicker
•	Field
•	FieldSet
•	FileUpload
•	Hidden
•	Layouts
o	ActionField
•	Multifield
•	NestedCheckboxList
•	NumberField
•	Password
•	Radio
•	RadioGroup
•	Reset
•	SearchField
•	Select
•	Selector
•	Submit
•	Switch
•	Textarea
•	TextField
•	UserPicker
Previous topic
By default, the fileupload component in the Touch UI allows for files to be “dragged and dropped” into it from the DAM and also to be chosen from the local file system using a popup dialog. This is all fine and dandy unless it is undesirable to allow the uploading of files from the local file system (which is a frequent request from our customers). Uploading from the local file system can often lead to broken, or missing assets, or at the very least unmanaged assets. We strongly do not recommend allowing authors to do this.

Coral UI granite mutifiled in AEM 6.3 using WCMPOJO

A Coral/Granite multi-field is based on granite/ui/components/coral/foundation/form/multifield. There are several advantages to working with Coral/Granite multi-field. For one thing, you do not need to write a JS script or use the ACS-Commons package as is typically required when using a Granite multi-field.
However, there are also some differences too. One important difference to understand is how the data is stored in the JCR. By default, Coral/Granite multi-field data is stored as child nodes, as shown in the illustration. Notice that each multi-field is a separate node, as shown here.
 

Because data is stored a child nodes, this changes the way you read the multi-field data when using Java business logic (for a Granite multi-field, data can be stored as JSON). For example, item0 represents the first multi-field and item1 represents the second multi-field. The properties of these nodes represents the values that the author entered into the dialog.

You can develop Java business logic in a WCMUsePojo class to read the dialog values and then display the data in the HTL component. This is covered in this development article. 

The next step is to add Java files to the com.htl.community.coral.core package:
•	TouchMultiComponent - this class is the Java side of the HTL component and extends com.adobe.cq.sightly.WCMUsePojo, which is an abstract class that implements the Use interface. 
TouchMultiBean - stores values used in the multifield, including a data member for each field in the multifield. (setter getter)



The TouchMultiComponent class is the Java part of the AEM HTL component. This class extends the WCMUsePojoclass. You override the activate method in this class.
The first task that this class does is retrieve the current node. The nodes that contain the multi-field classes are grandchildren to the current node. There can be a 1 to many relationship as well. That is, an author may have only filled in one multi-field or many. As a result, you have to create JCR application logic to drill down into the grandchildren nodes and read the values.
 
The TouchMultiComponent class is the Java part of the AEM HTL component. This class extends the WCMUsePojoclass. You override the activate method in this class.
The first task that this class does is retrieve the current node. The nodes that contain the multi-field classes are grandchildren to the current node. There can be a 1 to many relationship as well. That is, an author may have only filled in one multi-field or many. As a result, you have to create JCR application logic to drill down into the grandchildren nodes and read the values.
 
 

In the previous illustration, notice the node named sample_collapsible_m. This is the node retrieved by using thie code: 
Node currentNode = getResource().adaptTo(Node.class);
Now you must get the grandchildren of this node by using this logic:  
NodeIterator ni = currentNode.getNodes() ; 

//get the grandchild node of the currentNode -
while (ni.hasNext()) {

    Node child = (Node)ni.nextNode(); 
    NodeIterator ni2 = child.getNodes() ; 
    setMultiFieldItems(ni2); 
}
private List<TouchMultiBean> setMultiFieldItems(NodeIterator ni2) {}

public List<TouchMultiBean> getMultiFieldItems() {
return submenuItems
private List<TouchMultiBean> submenuItems = new ArrayList<TouchMultiBean>();
Creating a HTL Repeating Data Set 6.3 Component that uses Sling Models
The next step is to add Java files to the com.htl.community.coral.core.models package named Multifield. This class uses the @Model annontation. It injects a Resource based on the node in the component dialog that corresponds to thegranite/ui/components/coral/foundation/form/multifield sling type. 
@Model(adaptables = Resource.class)
public class Multifield {
 
    // Inject the products node under the current node
    @Inject
    @Optional
    public Resource products;

    // No need of a post construct as we don't have anything to modify after the
    // model is constructed
}
data-sly-use.multiItems="com.htl.community.coral.core.models.Multifield">
    <div data-sly-list.head="${multiItems.products.listChildren}">


@Model(adaptables = Resource.class)
public class Multifield {
    // Inject the products node under the current node
    @Inject
    @Optional
    public Resource products;
     // No need of a post construct as we don't have anything to modify after the
    // model is constructed
} 


Adobe target
An activity test and target content to specific audience.
It has start date(when)
It has measurable goal (why)
Define experience to each audience shoud see.(what ,where, to whom)	


Types of Activity
A/B test – testing of one variation of content against other to determine which one perform best to different audience
Multivariate test- testing multiple element in design or content to determine optimal performance for different audience.
Experience targeting – rule based targeting of content to an audience.
Automatic personalization – machine learning algorithm
Personalization

Channels- 
Web or mobile sites
Offsite –email and acquisition channel /partnering sites
Mobile app
IoT – Internet connected device

Threes teps workflow
1.	create
2.	Target
3.	Goal and settings


Activity Audience Offer setup 

Adaptive image component in AEM 6.3

Step 1:  Create folder directory structure /apps/core/wcm/components/image
              Cq:dialog [
              Widget: files 
                    {  sling:resourcetype=cq/gui/components/authoring/dialog/fileupload, 
                       mimeTypes string[]= image/*,
                       Multiple =false,
                       Name=./file,
                       uploadUrl= ${suffix.path},
                       usehtml5= true   }
            widget:decorative 
                       {  sling:resourcetype=    
                                  granite/ui/components/coral/foundation/form/checkbox,
                       }
             Widget:alt
              { sling:resourcetype=    
                     granite/ui/components/coral/foundation/form/textfield,
             }
         Widget:linkUrl
           { sling:resourcetype= granite/ui/components/coral/foundation/form/pathfield,
             rootPath=/content }
         Widget:  Caption
           { sling:resourcetype= granite/ui/components/coral/foundation/form/textfield }   
       }                
]

     Create Cq:droptargets :     
            [Cq:droptargets(ni:unstrutured)/image(cq:dropTargetConfig)]
    Create image node(cq:dropTargetConfig)- Add properties
                    Accept – image/*,
                    Group=media,
                    propertyName=./filereferencename
  create parameter node (image/parameter(nt:unstructured))- Add properties
          imageCrop
          imageRotate
       image Map
   

Step 2:  Create project specific structure in /apps/{projecr name}/image
Step3:   Create component folder 
Step 4:  Create image component , set sling:resourceSuperType=      
             core/wcm/components/image            
Step 5: Overlay the required node using sling resource merger
             /apps/{projecr name}/image

Now if we use the Adaptive image component in AEM page
 Following structure created
     /content/{page path}/jcr:content/parsys/image
Important- this {image} node defined as cq :dropTargetConfig
Dragged and drop image stored in the property filereferencename. This is the DAM path in AEM
  
Properties- 
propertyName= String ./fileReference
in content structure –
image stored in /as 
fileReference String {some dam path of image}

Versioning ClientLibs in AEM
Use case – Cached Clientlibs and recache whenever it change
The Versioned ClientLibs ACS AEM Commons feature uses a Sling rewriter to add an MD5 hash to the paths of your clientlibs, forcing them to recache after every modification. Typically Adobe Experience Manager will use the lastModified property to determine when to recache, however versioned-clientlibs is a more reliable approach.
To implement the versioned-clientlibs feature, simply copy the node from /libs/cq/config/rewriter/default to some path inside your application. In this example, we’ll choose /apps/acslibs/config/rewriter. For the most part this path is arbitrary, however the config node must be inside a four-level-deep path that ends in config/rewriter to work.
Your config file should be named versioned-clientlibs.xml and should look something like this:
<?xml version="1.0" encoding="UTF-8"?>
    <jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0"
              jcr:primaryType="sling:Folder"
              contentTypes="[text/html]"
              enabled="{Boolean}true"
              generatorType="htmlparser"
              order="{Long}1"
              serializerType="htmlwriter"
              transformerTypes="[linkchecker,versioned-clientlibs]"/>
Along with your config for the versioned-clientlibs, you should also copy down the default config node and make sure versioned-clientlibs is added to the transformTypes. Here’s an example of the content.xml for the default config:
    <?xml version="1.0" encoding="UTF-8"?>
    <jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
        jcr:primaryType="nt:unstructured"
        contentTypes="[text/html]"
        enabled="{Boolean}true"
        generatorType="htmlparser"
        order="-1"
        serializerType="htmlwriter"
        transformerTypes="[linkchecker,mobile,mobiledebug,contentsync,versioned-clientlibs]">
        <transformer-mobile
            jcr:primaryType="nt:unstructured"
            component-optional="{Boolean}true"/>
        <transformer-mobiledebug
            jcr:primaryType="nt:unstructured"
            component-optional="{Boolean}true"/>
        <transformer-contentsync
            jcr:primaryType="nt:unstructured"
            component-optional="{Boolean}true"/>
    </jcr:root>
Along with the rewriter configuration, you’ll also need to configure Apache to send the right headers. Here’s an example of what the config should look like:
    SetEnvIf Request_URI "(\.min)?\.[a-f0-9]+\.js" long_expires=true
    SetEnvIf Request_URI "(\.min)?\.[a-f0-9]+\.css" long_expires=true
    Header set Cache-Control max-age=2592000 env=long_expires

That’s it. Now your clientlibs should recompile every time there’s a change to them.
These are the files this rewriter will NOT support:
•	URIs embedded in CSS or JavaScript, including: background-images, web fonts, etc.
•	Relative URIs, e.g., etc/clientlibs/mysite/styles.css
•	URIs including a scheme or protocol-relative location, e.g., http://example.com/etc/clientlibs/mysite/styles.css and //example.com/etc/clientlibs/mysite/styles.css
•	URIs to non-AEM HtmlClientLibrary resources, e.g., /etc/designs/mysite.css
•	Tags contained in conditional comments
•	Clientlibs included by JavaScript (e.g., when leveraging the property channels)
AEM Objects Sling Models Injector
Allows for Sling Models classes and interfaces to be injected with common AEM-related objects, namely those made available using <cq:defineObjects/>:
•	resource
•	resourceResolver
•	componentContext
•	pageManager
•	currentPage
•	resourcePage
•	designer
•	currentDesign
•	resourceDesign
•	currentStyle
•	session
•	xssApi
Most injections are available when adapting either a Resource or SlingHttpServletRequest object, with these exceptions, which only work when adapting a SlingHttpServletRequest object:
•	currentPage
•	componentContext
•	xssApi
•	currentDesign


HTL has inbuilt XSS protection rather than as before. So when you use context = 'unsafe' , it will completely disable the XSS protection. Once that is disabled your site may be vulnerable to cross site scripting through those unsafe properties.

@Inject
  @Required
  private SlingRequestProcessor requestProcessor;

  /** Service to create HTTP Servlet requests and responses */
  @Inject
  @Required
  private RequestResponseFactory requestResponseFactory;


My favourite CQ5 util classes
ResourceUtil
http://dev.day.com/docs/en/cq/current/javadoc/org/apache/sling/api/resource/ResourceUtil.html
// checks if the resource exists
ResourceUtil.isNonExistingResource(myResource);
// always gets a ValueMap from a Resource
ResourceUtil.getValueMap(myResource);
DamUtil
http://dev.day.com/docs/en/cq/current/javadoc/com/day/cq/dam/commons/util/DamUtil.html
//check if the Resource is an Asset
DamUtil.isAsset(myResource);
ISO8601
http://jackrabbit.apache.org/api/2.4/org/apache/jackrabbit/util/ISO8601.html
//formats the Calendar into ISO8601 format
ISO8601.format(calendar);
JcrUtil
http://dev.day.com/docs/en/cq/current/javadoc/com/day/cq/commons/jcr/JcrUtil.html
// creates a valid JCR-name
JcrUtil.createValidName(myCustomName);
JcrUtils
http://dev.day.com/docs/en/cq/current/javadoc/org/apache/jackrabbit/commons/JcrUtils.html
// if the folder doesn’t exist, it will be created
JcrUtils.getOrAddFolder(parent, name);
PropertiesUtil
http://dev.day.com/docs/en/cq/current/javadoc/org/apache/sling/commons/osgi/PropertiesUtil.html
// gets a boolean property when starting an OSGi-component
@Activate
protected void activate(ComponentContext context) {
PropertiesUtil.toBoolean(context.getProperties().get(“myproperty”), false);
}
ServiceTracker
http://www.osgi.org/javadoc/r4v42/org/osgi/util/tracker/ServiceTracker.html
// gets the references to services loaded in the OSGi-container
serviceTracker.getServiceReference()
JcrResourceUtil.html
http://dev.day.com/docs/en/cq/current/javadoc/org/apache/sling/jcr/resource/JcrResourceUtil.html
// creates a full path, with autosave if needed
JcrResourceUtil.createPath(… )
TagUtil
http://dev.day.com/docs/en/cq/current/javadoc/org/apache/sling/scripting/jsp/util/TagUtil.html
// gets the SlingRequest/SlingResponse when you are creating custom tags
PageContext pageContext = (PageContext) getJspContext();
SlingHttpServletRequest slingRequest = TagUtil.getRequest(pageContext);
SlingHttpServletResponse slingResponse = TagUtil.getResponse(pageContext);
UserPropertiesUtil
http://dev.day.com/docs/en/cq/current/javadoc/com/day/cq/personalization/UserPropertiesUtil.html
// check to see if a real user is logged in
boolean realuser = ! UserPropertiesUtil.isAnonymous(request);
Microservices architecture for AEM
In the AEM world we also have the ability to create modular applications as AEM is built on top of OSGi – a framework which is designed to support modular systems. And it works well. Pieces of functionality are gathered into logical units called bundles, they communicate with other bundles through clearly defined interface (OSGi services).

However, AEM-based applications are often very complex systems providing not only pure CMS capabilities, but also consisting of multiple integrations with other systems like room booking, real-time stock market data, identity management, federated search, etc. Thanks to OSGi modularization, you can implement all of the integrations as separate modules and run them all on an AEM instance. Such an approach seems quite natural for AEM-based systems - everything is deployed into single AEM instance and if your system expects more traffic you can scale it horizontally by adding another instance. Simple and it works. At least in theory.
However, AEM-based applications are often very complex systems providing not only pure CMS capabilities, but also consisting of multiple integrations with other systems like room booking, real-time stock market data, identity management, federated search, etc. Thanks to OSGi modularization, you can implement all of the integrations as separate modules and run them all on an AEM instance. Such an approach seems quite natural for AEM-based systems - everything is deployed into single AEM instance and if your system expects more traffic you can scale it horizontally by adding another instance. Simple and it works. At least in theory.
In practice, we can often observe that some parts of a complex system are used much more extensively than others and require far more resources. Scaling of such a system may be challenging since the only option we have is to add another AEM instance. Unfortunately, this is not an easy operation, especially if you don’t use MongoDB setup. Additionally, it may generate significant costs on infrastructure and licencing. As a result, even if a system is designed to be modular, from scalability point of view it’s still a monolith - particular parts of the system can’t be scaled independently. So how can we deal with such issue?
If we think of highly-scalable enterprise systems it’s worth considering moving from AEM-based design to microservices architecture. In this approach, some bigger logical parts are deployed separately, outside of AEM – all of these parts are called services. Of course, AEM is still there (it’s another service) and plays one of the most important roles - it delivers the user experience, i.e. websites, pages, their layout and static content. Most of the dynamic content though, is provided by other services deployed e.g. as a stand-alone applications on Tomcat or Node.js servers. The assembly of pages served by AEM and the dynamic content from other services is done with use of… another service. Sounds complicated? Although from deployment point of view it’s more complex than simple AEM-based approach, it brings a couple of significant advantages:
•	Improved scalability – each service can be scaled separately. If you expect a lot of traffic and the majority of processing is related e.g. to search, then you can add another instance of search service only. You don’t need to replicate the whole system.
•	Easier deployment – since the services are independent you can upgrade each of them easily whereas other services remain untouched.
•	Faster development – you are not limited to OSGi technology, so you can develop each service with solutions which best suit the service needs.
•	Reduced cost and time-to-market – thanks to above, the overall cost of change implementation and time needed to deploy it to production is reduced significantly

Hotjar Implementation
Installing Hotjar
Implementing Hotjar tracking code 
Hotjar installation verification
Masking Elements in Heatmaps/Recordings (ensuring PII non-processing)
Hotjar Funnel setup (analytics)

